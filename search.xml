<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Apache-Commons-Email发送邮件</title>
    <url>/Apache-Commons-Email%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>使用Apache-Commons-Email发送邮件<div align=center><img src="../../../../images/2018-3/java-email/index.jpg" algin="center"/></div></p>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>Maven的pom.xml 文件中引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-email<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="一个简单的纯文本邮件"><a href="#一个简单的纯文本邮件" class="headerlink" title="一个简单的纯文本邮件"></a>一个简单的纯文本邮件</h1><h2 id="HTTP模式下"><a href="#HTTP模式下" class="headerlink" title="HTTP模式下"></a>HTTP模式下</h2><p>第一个例子是创建一个简单的email。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.mail.EmailException;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.mail.SimpleEmail;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 类名: TestSimpleEmail.java &lt;br/&gt;</span></span><br><span class="line"><span class="comment">* 详细描述: 一个简单的纯文本邮件   &lt;br/&gt;</span></span><br><span class="line"><span class="comment">* 发布版本： V1.0  &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSimpleEmail</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		   SimpleEmail email = <span class="keyword">new</span> SimpleEmail();</span><br><span class="line">	        <span class="comment">//设置发送主机的服务器地址(如果不设置，默认是&quot;mail.host&quot;)</span></span><br><span class="line">	        email.setHostName (<span class="string">&quot;smtp.163.com&quot;</span>);</span><br><span class="line">        	<span class="comment">// 开启debug模式</span></span><br><span class="line">        	email.setDebug(<span class="keyword">true</span>);</span><br><span class="line">	        <span class="comment">//设置端口号</span></span><br><span class="line">	        email.setSmtpPort(<span class="number">25</span>);<span class="comment">//默认也是25</span></span><br><span class="line">	        <span class="comment">//如果要求身份验证，设置用户名、密码，分别为发件人在邮件服务器上注册的用户名和密码</span></span><br><span class="line">	        email.setAuthentication ( <span class="string">&quot;from@163.com&quot;</span>, <span class="string">&quot;password&quot;</span> );</span><br><span class="line">	        <span class="keyword">try</span> &#123;</span><br><span class="line">	        	<span class="comment">//设置收件人邮箱以及名称</span></span><br><span class="line">	        	email.addTo (<span class="string">&quot;to@qq.com&quot;</span>, <span class="string">&quot;收件人名称&quot;</span>);</span><br><span class="line">	        	<span class="comment">//发件人邮箱以及名称</span></span><br><span class="line">		        <span class="comment">//email.setFrom (&quot;from@163.com&quot;, &quot;发件人名称&quot;);</span></span><br><span class="line">	        	<span class="comment">//发件人邮箱以及名称，邮件编码格式</span></span><br><span class="line">		        email.setFrom(<span class="string">&quot;from@163.com&quot;</span>, <span class="string">&quot;发件人名称&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">		        <span class="comment">//设置邮件的主题</span></span><br><span class="line">		        email.setSubject (<span class="string">&quot;这是邮件主题内容&quot;</span>);</span><br><span class="line">		        <span class="comment">//邮件正文消息</span></span><br><span class="line">		        email.setMsg (<span class="string">&quot;这是邮件内容！&quot;</span>);</span><br><span class="line">		        <span class="comment">// 发送</span></span><br><span class="line">		        email.send ();</span><br><span class="line">		        System.out.println (<span class="string">&quot;Send email successful!&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (EmailException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;       </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果遇到乱码情况可以通过以下方案解决：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置主题的字符集为UTF-8</span></span><br><span class="line">email.setCharset(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//设置内容的字符集为UTF-8,先buildMimeMessage才能设置内容文本</span></span><br><span class="line">email.getMimeMessage().setText(<span class="string">&quot;测试邮件内容&quot;</span>,<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="开启了HTTPS"><a href="#开启了HTTPS" class="headerlink" title="开启了HTTPS"></a>开启了HTTPS</h2><p>需要添加ssl端口，以及开启SSLOnConnect。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.mail.EmailException;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.mail.SimpleEmail;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 类名: TestSimpleSSLEmail.java &lt;br/&gt;</span></span><br><span class="line"><span class="comment">* 详细描述: 一个简单的纯文本邮件 --开启了https的情况下   &lt;br/&gt;</span></span><br><span class="line"><span class="comment">* 发布版本： V1.0  &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSimpleSSLEmail</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">		    SimpleEmail email = <span class="keyword">new</span> SimpleEmail ();</span><br><span class="line">	        <span class="comment">// smtp host</span></span><br><span class="line">	        email.setHostName (<span class="string">&quot;smtp.qq.com&quot;</span>);</span><br><span class="line">	        <span class="comment">//端口号</span></span><br><span class="line">	        email.setSslSmtpPort(<span class="string">&quot;465&quot;</span>);</span><br><span class="line">	        <span class="comment">// 登陆邮件服务器的用户名和密码</span></span><br><span class="line">	        email.setAuthentication (<span class="string">&quot;from@qq.com&quot;</span>, <span class="string">&quot;password&quot;</span>);<span class="comment">//注意qq邮箱需要授权，在设置那里生成一个随机码，然后填写到密码框。</span></span><br><span class="line">	        <span class="comment">// 接收人</span></span><br><span class="line">	        email.setSSLOnConnect(<span class="keyword">true</span>);</span><br><span class="line">	        <span class="keyword">try</span> &#123;</span><br><span class="line">	        	<span class="comment">//设置收件人邮箱以及名称</span></span><br><span class="line">				email.addTo (<span class="string">&quot;to@qq.com&quot;</span>, <span class="string">&quot;to&quot;</span>);</span><br><span class="line">				<span class="comment">// 发送人</span></span><br><span class="line">		        <span class="comment">//email.setFrom (&quot;from@163.com&quot;, &quot;from&quot;);</span></span><br><span class="line">		        email.setFrom(<span class="string">&quot;from@qq.com&quot;</span>, <span class="string">&quot;from&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">		        <span class="comment">//设置邮件的主题</span></span><br><span class="line">		        email.setSubject (<span class="string">&quot;这是邮件主题内容&quot;</span>);</span><br><span class="line">		        <span class="comment">//邮件正文消息</span></span><br><span class="line">		        email.setMsg (<span class="string">&quot;这是邮件内容！--一个简单的纯文本邮件 --开启了https的情况下  &quot;</span>);</span><br><span class="line">		        <span class="comment">// 发送</span></span><br><span class="line">		        email.send ();</span><br><span class="line">		        System.out.println (<span class="string">&quot;Send email successful!&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (EmailException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别要注意的是qq邮箱进行了加密，所以需要到qq账户设置里面拿到开启stmp发信客户端的密码。</p>
<div align=center><img src="../../../../images/2018-3/java-email/QQ-1.png" algin="center"/></div>

<div align=center><img src="../../../../images/2018-3/java-email/QQ-2.png" algin="center"/></div>

<p>取到一串字符串，然后填写到密码处。不然会报以下的错误。而不是填写QQ账号密码到密码认证处。详细也可以参照<a href="http://service.mail.qq.com/cgi-bin/help?subtype=1&&id=28&&no=331"><em><strong>QQ客户端说明文档</strong></em></a>。</p>
<div align=center><img src="../../../../images/2018-3/java-email/QQ-Exception.png" algin="center"/></div>

<h1 id="发送带附件的邮件"><a href="#发送带附件的邮件" class="headerlink" title="发送带附件的邮件"></a>发送带附件的邮件</h1><p>发送带附件的邮件得用MultiPartEmail 类来给邮件添加附件。除过覆盖attach()方法来给邮件添加附件外，这个类就和SimpleEmail类差不多。对于内联或是加入附件的个数是没有限制的。但附件必须是MIME编码。最简单的添加附件的方式是用 EmailAttachment类。</p>
<h2 id="本地附件"><a href="#本地附件" class="headerlink" title="本地附件"></a>本地附件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.mail.EmailAttachment;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.mail.EmailException;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.mail.MultiPartEmail;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 类名: TestEmailAttachment.java &lt;br/&gt;</span></span><br><span class="line"><span class="comment">* 详细描述:发送带附件的邮件--读取本地路径的文件  &lt;br/&gt;</span></span><br><span class="line"><span class="comment">* 发布版本： V1.0  &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEmailAttachment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		  <span class="comment">// 创建一个Email附件</span></span><br><span class="line">		  EmailAttachment attachment = <span class="keyword">new</span> EmailAttachment();</span><br><span class="line">           <span class="comment">// 本地资源需要存在</span></span><br><span class="line">		  attachment.setPath(<span class="string">&quot;E:\\qrcode.jpg&quot;</span>);</span><br><span class="line">		  attachment.setDisposition(EmailAttachment.ATTACHMENT);</span><br><span class="line">		  attachment.setDescription(<span class="string">&quot;图片&quot;</span>);</span><br><span class="line">           <span class="comment">// 自定义文件名，并且格式要一致，不然附近收到的话，有可能读不出来。</span></span><br><span class="line">		  attachment.setName(<span class="string">&quot;qrcode.jpg&quot;</span>);</span><br><span class="line">		 </span><br><span class="line">		  <span class="comment">// Create the email message</span></span><br><span class="line">		  MultiPartEmail email = <span class="keyword">new</span> MultiPartEmail();</span><br><span class="line">		  <span class="comment">// smtp host</span></span><br><span class="line">	      email.setHostName (<span class="string">&quot;smtp.163.com&quot;</span>);</span><br><span class="line">	      <span class="comment">//设置端口号</span></span><br><span class="line">	      email.setSmtpPort(<span class="number">25</span>);<span class="comment">//默认也是25</span></span><br><span class="line">	      <span class="comment">// 登陆邮件服务器的用户名和密码</span></span><br><span class="line">	      email.setAuthentication (<span class="string">&quot;from@163.com&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br><span class="line">		  <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//设置收件人邮箱以及名称</span></span><br><span class="line">                email.addTo (<span class="string">&quot;to@qq.com&quot;</span>, <span class="string">&quot;收件人名称&quot;</span>);</span><br><span class="line">                <span class="comment">//发件人邮箱以及名称</span></span><br><span class="line">                <span class="comment">//email.setFrom (&quot;from@163.com&quot;, &quot;发件人名称&quot;);</span></span><br><span class="line">                <span class="comment">//发件人邮箱以及名称，邮件编码格式</span></span><br><span class="line">                email.setFrom(<span class="string">&quot;from@163.com&quot;</span>, <span class="string">&quot;发件人名称&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                <span class="comment">//设置邮件的主题</span></span><br><span class="line">                email.setSubject (<span class="string">&quot;这是邮件主题内容&quot;</span>);</span><br><span class="line">                <span class="comment">//邮件正文消息</span></span><br><span class="line">                email.setMsg (<span class="string">&quot;这是邮件内容！&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// add the attachment</span></span><br><span class="line">                email.attach(attachment);</span><br><span class="line">                <span class="comment">// send the email</span></span><br><span class="line">                email.send();</span><br><span class="line">                System.out.println (<span class="string">&quot;Send email successful!&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (EmailException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;	  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="远程附件"><a href="#远程附件" class="headerlink" title="远程附件"></a>远程附件</h2><p>如果没有本地文件，可以用 EmailAttachment 添加任何可用的URL。当邮件发送后，文件会自动加载并加入到邮件内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.mail.EmailAttachment;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.mail.EmailException;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.mail.MultiPartEmail;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 类名: TestEmailAttachment.java &lt;br/&gt;</span></span><br><span class="line"><span class="comment">* 详细描述:发送带附件的邮件--读取本地路径的文件  &lt;br/&gt;</span></span><br><span class="line"><span class="comment">* 发布版本： V1.0  &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEmailAttachment2</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">		</span><br><span class="line">		  <span class="comment">// 创建一个Email附件</span></span><br><span class="line">		  EmailAttachment attachment = <span class="keyword">new</span> EmailAttachment();</span><br><span class="line">		  attachment.setURL(<span class="keyword">new</span> URL(<span class="string">&quot;http://www.apache.org/images/asf_logo_wide.gif&quot;</span>));</span><br><span class="line">		  attachment.setDisposition(EmailAttachment.ATTACHMENT);</span><br><span class="line">		  attachment.setDescription(<span class="string">&quot;Apache logo&quot;</span>);</span><br><span class="line">           <span class="comment">// 自定义文件名，并且格式要一致，不然附近收到的话，有可能读不出来</span></span><br><span class="line">		  attachment.setName(<span class="string">&quot;asf_logo_wide.gif&quot;</span>);</span><br><span class="line">		 </span><br><span class="line">		  <span class="comment">// Create the email message</span></span><br><span class="line">		  MultiPartEmail email = <span class="keyword">new</span> MultiPartEmail();</span><br><span class="line">		  <span class="comment">// smtp host</span></span><br><span class="line">	      email.setHostName (<span class="string">&quot;smtp.163.com&quot;</span>);</span><br><span class="line">	      <span class="comment">//设置端口号(默认25)</span></span><br><span class="line">	      email.setSmtpPort(<span class="number">25</span>);</span><br><span class="line">	      <span class="comment">// 登陆邮件服务器的用户名和密码</span></span><br><span class="line">	      email.setAuthentication (<span class="string">&quot;from@163.com&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br><span class="line">		  </span><br><span class="line">		  <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 设置收件人邮箱以及名称</span></span><br><span class="line">                email.addTo (<span class="string">&quot;to@qq.com&quot;</span>, <span class="string">&quot;收件人名称&quot;</span>);</span><br><span class="line">                <span class="comment">// 发件人邮箱以及名称</span></span><br><span class="line">                <span class="comment">// email.setFrom (&quot;from@163.com&quot;, &quot;发件人名称&quot;);</span></span><br><span class="line">                <span class="comment">// 发件人邮箱以及名称，邮件编码格式</span></span><br><span class="line">                email.setFrom(<span class="string">&quot;from@163.com&quot;</span>, <span class="string">&quot;发件人名称&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                <span class="comment">// 设置邮件的主题</span></span><br><span class="line">                email.setSubject (<span class="string">&quot;这是邮件主题内容&quot;</span>);</span><br><span class="line">                <span class="comment">// 邮件正文消息</span></span><br><span class="line">                email.setMsg (<span class="string">&quot;这是邮件内容！&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 添加附件</span></span><br><span class="line">                email.attach(attachment);</span><br><span class="line">                <span class="comment">// 发送邮件</span></span><br><span class="line">                email.send();</span><br><span class="line">                System.out.println (<span class="string">&quot;Send email successful!&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (EmailException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;	  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="发送带HTML格式的邮件"><a href="#发送带HTML格式的邮件" class="headerlink" title="发送带HTML格式的邮件"></a>发送带HTML格式的邮件</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.mail.EmailException;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.mail.HtmlEmail;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 类名: TestHtmlEmail.java &lt;br/&gt;</span></span><br><span class="line"><span class="comment">* 详细描述: 发送带HTML格式的邮件&lt;br/&gt;</span></span><br><span class="line"><span class="comment">* 发布版本： V1.0  &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHtmlEmail</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建HTML邮件</span></span><br><span class="line">		HtmlEmail email = <span class="keyword">new</span> HtmlEmail();</span><br><span class="line">	    <span class="comment">// 设置发送主机的服务器地址</span></span><br><span class="line">        email.setHostName (<span class="string">&quot;smtp.163.com&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置端口号(默认25)</span></span><br><span class="line">        email.setSmtpPort(<span class="number">25</span>);</span><br><span class="line">        <span class="comment">// 如果要求身份验证，设置用户名、密码，分别为发件人在邮件服务器上注册的用户名和密码</span></span><br><span class="line">        email.setAuthentication (<span class="string">&quot;from@163.com&quot;</span>, <span class="string">&quot;password&quot;</span> );</span><br><span class="line">		  <span class="keyword">try</span> &#123;</span><br><span class="line">			  URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://www.apache.org/images/asf_logo_wide.gif&quot;</span>);</span><br><span class="line">			  String cid = email.embed(url, <span class="string">&quot;Apache logo&quot;</span>);</span><br><span class="line">			  </span><br><span class="line">			  <span class="comment">//设置收件人邮箱以及名称</span></span><br><span class="line">	          email.addTo (<span class="string">&quot;to@qq.com&quot;</span>, <span class="string">&quot;收件人名称&quot;</span>);</span><br><span class="line">	          <span class="comment">//发件人邮箱以及名称</span></span><br><span class="line">		      <span class="comment">//email.setFrom (&quot;from@163.com&quot;, &quot;发件人名称&quot;);</span></span><br><span class="line">	          <span class="comment">//发件人邮箱以及名称，邮件编码格式</span></span><br><span class="line">		      email.setFrom(<span class="string">&quot;from@163.com&quot;</span>, <span class="string">&quot;发件人名称&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">		      <span class="comment">//设置邮件的主题</span></span><br><span class="line">		      email.setSubject (<span class="string">&quot;这是邮件主题内容-发送带HTML格式的邮件&quot;</span>);</span><br><span class="line">			 </span><br><span class="line">		      <span class="comment">// HTML信息</span></span><br><span class="line">			  email.setHtmlMsg(<span class="string">&quot;&lt;html&gt;The apache logo - &lt;img src=\&quot;cid:&quot;</span> + cid + <span class="string">&quot;\&quot;&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">			  <span class="comment">// set the alternative message</span></span><br><span class="line">			  email.setTextMsg(<span class="string">&quot;Your email client does not support HTML messages&quot;</span>);</span><br><span class="line">			  <span class="comment">// 发送邮件</span></span><br><span class="line">			  email.send();</span><br><span class="line">			  System.out.println (<span class="string">&quot;Send email successful!&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (EmailException | MalformedURLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>embed()方法返回一个字符串。该字符串是一个随机生成的标识符，必须在图像标记中引用图像的图像。</li>
<li>没有调用setmsg()这个例子。因为如果HTML内容里有内联图片的话，这个方法是不能用的。这样我们可以用setHtmlMsg和setTextMsg方法。</li>
</ul>
<h1 id="发送带嵌入图片的HTML文本"><a href="#发送带嵌入图片的HTML文本" class="headerlink" title="发送带嵌入图片的HTML文本"></a>发送带嵌入图片的HTML文本</h1><p>前面说的是创建带嵌入图片的HTML邮件，但是用HTML邮件模板来处理图片是很麻烦的。ImageHtmlEmail类能解决这个问题，它能很方便的将所有外部图片转化为内联图片。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.mail.EmailException;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.mail.ImageHtmlEmail;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.mail.resolver.DataSourceUrlResolver;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 类名: TestHtmlEmail.java &lt;br/&gt;</span></span><br><span class="line"><span class="comment">* 详细描述: 发送带HTML格式的邮件--嵌入图片的HTML文本 &lt;br/&gt;</span></span><br><span class="line"><span class="comment">* 发布版本： V1.0  &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHtmlEmail2</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// create the email message</span></span><br><span class="line">	    ImageHtmlEmail email = <span class="keyword">new</span> ImageHtmlEmail();</span><br><span class="line">		<span class="comment">// 设置发送主机的服务器地址</span></span><br><span class="line">	    email.setHostName (<span class="string">&quot;smtp.163.com&quot;</span>);</span><br><span class="line">	    <span class="comment">// 设置端口号(默认25)</span></span><br><span class="line">        email.setSmtpPort(<span class="number">25</span>);</span><br><span class="line">        <span class="comment">// 如果要求身份验证，设置用户名、密码，分别为发件人在邮件服务器上注册的用户名和密码</span></span><br><span class="line">        email.setAuthentication ( <span class="string">&quot;from@163.com&quot;</span>, <span class="string">&quot;password&quot;</span> );</span><br><span class="line">		<span class="comment">// load your HTML email template</span></span><br><span class="line">		 String htmlEmailTemplate = <span class="string">&quot;嵌入图片的HTML文本:&lt;img src=\&quot;http://www.apache.org/images/feather.gif\&quot;&gt; ....&quot;</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://www.apache.org&quot;</span>);</span><br><span class="line">			email.setDataSourceResolver(<span class="keyword">new</span> DataSourceUrlResolver(url));</span><br><span class="line">			<span class="comment">// 设置收件人邮箱以及名称</span></span><br><span class="line">			email.addTo(<span class="string">&quot;to@sina.com&quot;</span>, <span class="string">&quot;收件人名称&quot;</span>);</span><br><span class="line">			<span class="comment">// 发件人邮箱以及名称</span></span><br><span class="line">			<span class="comment">// 发件人邮箱以及名称，邮件编码格式</span></span><br><span class="line">			email.setFrom(<span class="string">&quot;from@qq.com&quot;</span>, <span class="string">&quot;发件人名称&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">			<span class="comment">// 设置邮件的主题</span></span><br><span class="line">			email.setSubject(<span class="string">&quot;这是邮件主题内容&quot;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// set the html message</span></span><br><span class="line">			email.setHtmlMsg(htmlEmailTemplate);</span><br><span class="line">			email.setCharset(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// set the alternative message</span></span><br><span class="line">			email.setTextMsg(<span class="string">&quot;Your email client does not support HTML messages&quot;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 发送邮件</span></span><br><span class="line">			email.send();</span><br><span class="line">			System.out.println(<span class="string">&quot;Send email successful!&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (MalformedURLException | EmailException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>JavaMail API支持调试选项，通过调用setDebug(true)来开启调试。调试信息会通过System.out打印出来。</p>
<p>commons-email的安全设置的特性。可以用EmailLiveTest和EmailConfiguration类在真正的SMTP服务器上测试commons-email。</p>
<h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><p>如果要对SMTP服务器进行认证，可以在发邮件前调用setAuthentication(userName,password)方法测试。这将会在JavaMail API发送邮件时创建DefaultAuthenticator实例，要支持此方法得让你的服务器支持RFC255协议。</p>
<p>可以用javax.mail.Authenticator的子类来完成更加复杂的认证，如弹出个对话框等。当想收集并处理用户信息时，必须覆盖getPasswordAuthentication()方法。用Email.setAuthenticator方法可以创建新的Authenticator类。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><em><strong><a href="http://commons.apache.org/proper/commons-email/userguide.html">http://commons.apache.org/proper/commons-email/userguide.html</a></strong></em></p>
<p><a href="http://www.souvc.com/?p=499"><em><strong>Apache Commons Email 发送邮件的用法介绍以及实战练习</strong></em> </a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>Bug简记-Spring返回字符串加引号</title>
    <url>/Bug%E7%AE%80%E8%AE%B0-Spring%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%BC%95%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在开发过程中会遇到这种各样的bug，也是自己吃过的亏。以后在这里会把自己遇到的bug记录下来，吸取教训，避免犯同样的错误。<div align=center><img width="220" height="160" src="../../../../images/2018-8/bug.jpg" algin="center"/></div><span id="more"></span></p>
<h1 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><p>在与第三方对接的接口中，对方推送消息接口定义如果接收成功返回<em>success</em>，反之返回其他字符串，如果不是<em>success</em>字符串就会再重复推送三次。自己在代码中为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">callBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...something</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码自我感觉没问题，但是线上发现即使返回的是<em>success</em>字符串也会重复推送。让对方排查了下，对方说我们推送的不是<em>success</em>字符串。WTF？看了日志*result[success]*没问题啊，直到自己亲自调试了下接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求自己接口获取返回值</span></span><br><span class="line">String result = getResult();</span><br><span class="line"><span class="comment">// 返回true</span></span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>\success\<span class="string">&quot;&quot;</span>.equals(result));</span><br></pre></td></tr></table></figure>

<p>发现接口返回值<em>success</em>被加上了双引号。</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p><strong>在SpringMVC中使用@ResponseBody注解时会强制返回json格式，在返回字符串时会默认加上双引号</strong>。这才导致返回的字符串多了双引号。</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>解决方法也很简单。只需要添加字符串解析器，避免String类型直接解析成JSON。</p>
<p>方法一：jackson</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 避免string类型直接解析成json--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;utf8charset&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;writeAcceptCharset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;objectMapper&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serializationInclusion&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">value</span> <span class="attr">type</span>=<span class="string">&quot;com.fasterxml.jackson.annotation.JsonInclude.Include&quot;</span>&gt;</span>NON_NULL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>方法二：fastjson</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 避免String类型直接解析成json--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 避免IE执行AJAX时,返回JSON出现下载文件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fastJsonHttpMessageConverter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 这里顺序不能反，一定先写text/html,不然ie下出现下载提示 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html;charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json;charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Bug简记-长轮训Response</title>
    <url>/Bug%E7%AE%80%E8%AE%B0-%E9%95%BF%E8%BD%AE%E8%AE%ADResponse/</url>
    <content><![CDATA[<p>客服系统服务中使用Servlet3.0异步长轮训，服务压力大时，导致消息错乱。</p>
<div align=center><img width="220" height="160" src="../../../../images/2018-8/bug.jpg" algin="center"/></div><span id="more"></span>

<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>对Servlet请求应答对象的生命周期理解不够深入，IM服务在服务压力大，并且Nginx断开请求回收资源后，依然将用户消息进行下发，最后导致消息下发到其他请求中。</p>
<h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><h2 id="错误代码伪代码"><a href="#错误代码伪代码" class="headerlink" title="错误代码伪代码"></a>错误代码伪代码</h2><p>服务使用异步的Servlet方法进行长轮训</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(asyncSupported = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CometServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动异步请求</span></span><br><span class="line">        AsyncContext context = request.startAsync();</span><br><span class="line">        <span class="comment">//设置超时</span></span><br><span class="line">        context.setTimeout(TIMEOUT);</span><br><span class="line">        <span class="comment">//异步执行</span></span><br><span class="line">        context.start(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这行只是伪代码，具体为业务逻辑</span></span><br><span class="line">            Thread.sleep(<span class="number">27</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//下发应答。如果接收到消息这返回应答</span></span><br><span class="line">            response.getWriter().write(...);</span><br><span class="line">            context.complete();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ol>
<li>如果发生超时或者Nginx因为某些原因频繁断开与Tomcat之间的连接，Request以及Response对象会被Tomcat发现并且执行清理。</li>
<li>如果清理只是销毁对象的话也还不会导致问题，但查看源码发现，Tomcat是把对象回收，交给下一个请求使用。当Tomcat回收Repsonse对象，交给下一个请求使用后，回调函数依然会继续执行，Response虽然是同一个对象，但已经是其他请求正在使用的了，继续往里面下发消息则导致了整个事件的发生。</li>
</ol>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>而在Tomcat提供的AsyncContext里面会感知到连接异常，并且提供清理操作，以下是AsyncContextImpl源码节选。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncContextImpl</span> <span class="keyword">implements</span> <span class="title">AsyncContext</span>, <span class="title">AsyncContextCallback</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ServletRequest servletRequest = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ServletResponse servletResponse = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动异步时，保存request以及response对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStarted</span><span class="params">(Context context, ServletRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">                           ServletResponse response, <span class="keyword">boolean</span> originalRequestResponse)</span> </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">        <span class="keyword">this</span>.servletRequest = request;</span><br><span class="line">        <span class="keyword">this</span>.servletResponse = response;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接异常、超时等情况，会对这个AsyncContext的资源进行清理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            logDebug(<span class="string">&quot;recycle    &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        context = <span class="keyword">null</span>;</span><br><span class="line">        dispatch = <span class="keyword">null</span>;</span><br><span class="line">        event = <span class="keyword">null</span>;</span><br><span class="line">        hasOriginalRequestAndResponse = <span class="keyword">true</span>;</span><br><span class="line">        instanceManager = <span class="keyword">null</span>;</span><br><span class="line">        listeners.clear();</span><br><span class="line">        request = <span class="keyword">null</span>;</span><br><span class="line">        clearServletRequestResponse();</span><br><span class="line">        timeout = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清理request以及response对象以免外部调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearServletRequestResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        servletRequest = <span class="keyword">null</span>;</span><br><span class="line">        servletResponse = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查状态机状态，如果不处于正常状态，则抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// AsyncContext has been recycled and should not be being used</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(sm.getString(<span class="string">&quot;asyncContextImpl.requestEnded&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//每次获取request以及response对象，都检查请求以及应答对象是否已经被回收</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRequest <span class="title">getRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        check();</span><br><span class="line">        <span class="keyword">if</span> (servletRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(sm.getString(<span class="string">&quot;asyncContextImpl.request.ise&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> servletRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//每次获取request以及response对象，都检查请求以及应答对象是否已经被回收</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletResponse <span class="title">getResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        check();</span><br><span class="line">        <span class="keyword">if</span> (servletResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(sm.getString(<span class="string">&quot;asyncContextImpl.response.ise&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> servletResponse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结果及处理"><a href="#结果及处理" class="headerlink" title="结果及处理"></a>结果及处理</h1><p>以上源码分析可以看到，Tomcat的AsyncContext针对连接断开、超时等情况是有做特殊保护处理的，而IM服务所用的方式并没有用上Tomcat的保护，直接将应答对象写入了错误的应答。</p>
<p><strong>正确的使用方式很简单：</strong></p>
<p>**只需要把response.getWriter().write(…); **</p>
<p><strong>修改为context.getResponse().getWriter().write(…)即可，就是这么一行代码，导致了整个事件的发生。</strong></p>
<p>另外，使用Spring提供的DeferredResult已完全封装了异步请求，可避免此问题。</p>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker常用命令总结</title>
    <url>/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div align=center><img src="../../../../images/2021/7-9/docker-r.png" algin="center"/></div><span id="more"></span>

<h1 id="图示命令"><a href="#图示命令" class="headerlink" title="图示命令"></a>图示命令</h1><div align=center><img src="../../../../images/2021/7-9/docker-command.png" algin="center"/></div><!-- more -->

<h1 id="docker服务"><a href="#docker服务" class="headerlink" title="docker服务"></a>docker服务</h1><table>
<thead>
<tr>
<th>COMMAND</th>
<th>DESC</th>
</tr>
</thead>
<tbody><tr>
<td>docker info</td>
<td>系统级别docker信息。包含镜像和容器数量等。</td>
</tr>
<tr>
<td>docker version</td>
<td>查看docker版本信息</td>
</tr>
<tr>
<td>docker -v</td>
<td>查看docker简要信息</td>
</tr>
<tr>
<td>systemctl enable docker</td>
<td>设置开机自启</td>
</tr>
<tr>
<td>systemctl start docker</td>
<td>启动docker</td>
</tr>
<tr>
<td>systemctl stop docker</td>
<td>关闭docker</td>
</tr>
<tr>
<td>service docker restart</td>
<td>重启docker服务</td>
</tr>
<tr>
<td>service docker stop</td>
<td>停止docker服务</td>
</tr>
</tbody></table>
<h1 id="docker镜像"><a href="#docker镜像" class="headerlink" title="docker镜像"></a>docker镜像</h1><p>docker官方镜像地址：<a href="https://hub.docker.com/">https://hub.docker.com</a></p>
<table>
<thead>
<tr>
<th>COMMAND</th>
<th>DESC</th>
</tr>
</thead>
<tbody><tr>
<td>docker search &lt;镜像名称&gt;</td>
<td>搜索docker镜像</td>
</tr>
<tr>
<td>docker pull &lt;镜像名称&gt;</td>
<td>拉取镜像</td>
</tr>
<tr>
<td>docker images</td>
<td>列出所有镜像信息</td>
</tr>
<tr>
<td>docker images -qa</td>
<td>列出所有镜像ID</td>
</tr>
<tr>
<td>docker rmi &lt;镜像ID&gt;</td>
<td>单个删除镜像</td>
</tr>
<tr>
<td>docker rmi $(docker rmi -qa)</td>
<td>删除所有镜像</td>
</tr>
</tbody></table>
<h1 id="docker容器"><a href="#docker容器" class="headerlink" title="docker容器"></a>docker容器</h1><table>
<thead>
<tr>
<th>COMMAND</th>
<th>DESC</th>
</tr>
</thead>
<tbody><tr>
<td>docker inspect &lt;容器ID&gt;</td>
<td>查看容器元信息</td>
</tr>
<tr>
<td>docker ps</td>
<td>查看所有运行中的容器</td>
</tr>
<tr>
<td>docker ps -a</td>
<td>查看所有容器</td>
</tr>
<tr>
<td>docker run &lt;容器ID&gt;</td>
<td>新建并启动容器</td>
</tr>
<tr>
<td>docker start &lt;容器ID |容器名称&gt;</td>
<td>启动已终止容器</td>
</tr>
<tr>
<td>docker stop &lt;容器ID |容器名称&gt;</td>
<td>停止运行中容器</td>
</tr>
<tr>
<td>docker restart &lt;容器ID |容器名称&gt;</td>
<td>重启容器</td>
</tr>
<tr>
<td>docker kill &lt;容器ID |容器名称&gt;</td>
<td>强制杀死容器</td>
</tr>
<tr>
<td>docker rm &lt;容器ID |容器名称&gt;</td>
<td>删除单个容器</td>
</tr>
<tr>
<td>docker rm $(docker ps -qa)</td>
<td>删除所有容器</td>
</tr>
<tr>
<td>docker exec -it &lt;容器ID&gt; /bin/bash</td>
<td>交互式进入容器</td>
</tr>
<tr>
<td>docker top &lt;容器ID&gt;</td>
<td>查看容器中的进程信息</td>
</tr>
</tbody></table>
<h1 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h1><table>
<thead>
<tr>
<th>COMMAND</th>
<th>DESC</th>
</tr>
</thead>
<tbody><tr>
<td>docker network ls</td>
<td>查看docker网络</td>
</tr>
<tr>
<td>docker network inspect &lt;网络ID&gt;</td>
<td>查看网络详情</td>
</tr>
<tr>
<td>docker network create –driver bridge –subnet <subnet> –gateway <gateway> &lt;网络名称&gt;</td>
<td>创建docker自定义网络。例：<br />docker network create –driver bridge –subnet 192.168.0.0/16 –gateway 192.168.0.1 mynet</td>
</tr>
</tbody></table>
<h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><table>
<thead>
<tr>
<th>COMMAND</th>
<th>DESC</th>
</tr>
</thead>
<tbody><tr>
<td>docker logs &lt;容器ID&gt;</td>
<td>查看容器日志</td>
</tr>
<tr>
<td>docker cp &lt;本机文件&gt; &lt;容器ID&gt;:&lt;容器文件路径&gt;</td>
<td>拷贝宿主机文件到容器</td>
</tr>
<tr>
<td>docker cp &lt;容器ID&gt;:&lt;容器文件&gt; &lt;本机路径&gt;</td>
<td>拷贝容器文件到宿主机</td>
</tr>
<tr>
<td>docker volume ls</td>
<td>查看挂载卷列表</td>
</tr>
<tr>
<td>docker inspect &lt;volume名称&gt;</td>
<td>查看挂载卷详情</td>
</tr>
<tr>
<td>docker volume prune</td>
<td>清理无效挂载卷</td>
</tr>
</tbody></table>
<h1 id="常用镜像"><a href="#常用镜像" class="headerlink" title="常用镜像"></a>常用镜像</h1><ul>
<li><mark class="hl-label red">-d</mark> ：表示以后台方式运行</li>
<li><mark class="hl-label red">-p</mark> ：端口映射。<宿主机端口>:<容器暴露端口></li>
<li><mark class="hl-label red">-P</mark> ：随机指定端口</li>
<li><mark class="hl-label red">-v</mark> ：挂载卷。<宿主机目录>:<容器目录></li>
<li><mark class="hl-label red">--name</mark> ：容器名称</li>
<li><mark class="hl-label red">--net</mark> ：自定义网络</li>
</ul>
<h2 id="Portainer"><a href="#Portainer" class="headerlink" title="Portainer"></a>Portainer</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> windows环境安装。使用手册见 https://hub.docker.com/r/portainer/portainer-ce</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 访问端口为9000</span></span><br><span class="line">docker run -d -p 9000:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data -v \\.\pipe\docker_engine:\\.\pipe\docker_engine --name prtainer portainer/portainer-ce</span><br></pre></td></tr></table></figure>

<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 数据库密码为123456</span></span><br><span class="line">docker run -d -p 3306:3306 -v G:\volumes\mysql\conf:/etc/mysql/conf.d -v G:\volumes\mysql\data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql mysql:8.0.26</span><br></pre></td></tr></table></figure>

<h2 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 访问端口为3000</span></span><br><span class="line">docker run -d -p 3000:3000 --name grafana grafana/grafana</span><br></pre></td></tr></table></figure>

<h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 访问端口为8848</span></span><br><span class="line">docker run -dp 8848:8848 -e MODE=standalone --name nacos nacos/nacos-server:latest</span><br></pre></td></tr></table></figure>

<h2 id="Xxl-job"><a href="#Xxl-job" class="headerlink" title="Xxl-job"></a>Xxl-job</h2><ol>
<li>需要在本地新建挂载文件 application.properties。 路径为<a href="https://github.com/xuxueli/xxl-job/blob/master/xxl-job-admin/src/main/resources/application.properties">https://github.com/xuxueli/xxl-job/blob/master/xxl-job-admin/src/main/resources/application.properties</a></li>
<li>修改MySQL的用户名和密码</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问端口为9090。挂载配置路径为G:\volumes\xxl-job\application.properties</span></span><br><span class="line">docker run -dp <span class="number">9090</span>:<span class="number">9090</span> -v <span class="attr">G:</span>\volumes\xxl-job\application.<span class="attr">properties:</span><span class="regexp">/application.properties -e PARAMS=&#x27;--spring.config.location=/</span>application.properties<span class="string">&#x27; --name xxl-job-admin xuxueli/xxl-job-admin:2.3.0</span></span><br></pre></td></tr></table></figure>

<h2 id="ElasticSearch相关"><a href="#ElasticSearch相关" class="headerlink" title="ElasticSearch相关"></a>ElasticSearch相关</h2><p><code>docker-compose.yaml</code> 如下所示</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">cerebro:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">lmenezes/cerebro:0.9.3</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">cerebro</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9300:9000&quot;</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">-Dhosts.0.host=http://elasticsearch:9200</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">es7net</span></span><br><span class="line">  <span class="attr">elasticsearch-head:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mobz/elasticsearch-head:5-alpine</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es-head</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9100:9100&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">es7net</span>      </span><br><span class="line">  <span class="attr">kibana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">kibana:7.9.3</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kibana</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">I18N_LOCALE=zh-CN</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">XPACK_GRAPH_ENABLED=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TIMELION_ENABLED=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">XPACK_MONITORING_COLLECTION_ENABLED=&quot;true&quot;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5601:5601&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">es7net</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elasticsearch:7.9.3</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=maxTest</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es7_01</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es7_01</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es7_01</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">es7data1:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">es7net</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">es7data1:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">es7net:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>cerebro访问端口为9300</li>
<li>elasticsearch-head访问端口为9100</li>
<li>kibana访问端口为6501</li>
<li>elasticsearch访问端口为9200</li>
</ol>
</blockquote>
<p>若想要<strong>elasticsearch-head</strong>连接<strong>es</strong>，需要在<strong>es</strong>容器<strong>config</strong>路径<strong>elasticsearch.yml</strong>配置文件中添加</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Apollo"><a href="#Apollo" class="headerlink" title="Apollo"></a>Apollo</h2><p>官方文档：<a href="https://www.apolloconfig.com/#/zh/deployment/quick-start-docker">https://www.apolloconfig.com/#/zh/deployment/quick-start-docker</a></p>
<h2 id="Yapi"><a href="#Yapi" class="headerlink" title="Yapi"></a>Yapi</h2><p>官方文档：<a href="https://github.com/fjc0k/docker-YApi">https://github.com/fjc0k/docker-YApi</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-VS-SVN</title>
    <url>/Git-VS-SVN/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在软件开发过程中，版本控制是非常重要的一环。常用的版本控制工具有<code>Git</code>和<code>SVN</code>。</p>
<div align=center><img src="../../../../images/2018-5/Git-vs-SVN/index.png" algin="center"/></div><span id="more"></span>

<p>Git是目前世界上最先进的分布式版本控制系统，其实 Git 跟 SVN 一样有自己的集中式版本库或服务器，但是Git 更倾向于被使用于分布式模式，也就是每个开发人员从中心版本库/服务器上<em>chect out</em>代码后会在自己的机器上<strong>克隆一个跟中心版本库一模一样的本地版本库</strong>。可以这样说，如果你被困在一个不能连接网络的地方时，你仍然能够提交文件，查看log（历史版本记录），创建项目分支等。</p>
<h1 id="Git和SVN的差别"><a href="#Git和SVN的差别" class="headerlink" title="Git和SVN的差别"></a>Git和SVN的差别</h1><p><strong>1、Git只关心文件数据的整体是否发生变化，而SVN这类版本控制系统则只关心文件内容的具体差异。</strong></p>
<p>​    这类系统（如SVN）每次记录有哪些文件做了更新，以及都更新了哪些行的什么内容，然而Git 并不保存这些前后变化的差异数据。实际上，Git更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。</p>
<p><strong>2、在Git 中的绝大多数操作都只需要访问本地文件和资源，不必联网就可以看到所有的历史版本记录，而SVN 却需要联网。</strong></p>
<p>​    因为 Git 在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快，但我们需要浏览项目的历史更新摘要，Git 不用跑到外面的服务器上去取数据回来，而直接从本地数据库读取后展示给你看<strong>。如果想要看当前版本的文件和一个月前的版本之间有何差异，Git 会取出一个月前的快照和当前文件作一次差异运算。</strong></p>
<p><strong>3、SVN 断开网络或者断开VPN就无法commit代码，但是Git 可以先commit到本地仓库。</strong></p>
<p>​    用SVN的话，没有网络或者断开VPN时，你当然也可以继续在本地开发，但是无法commit代码，因为SVN 每次commit都必须联网，长时间不commit代码会丢失大量开发进程的历史纪录。有个比喻是：不能commit就像用word写文档不能save一样危险。而且有网络的情况下每一次commit都会花上数秒甚至更长时间。但用 Git 的话，就算你在飞机或者火车上，都可以非常愉快地<strong>频繁</strong>提交更新，因为是在本地仓库commit所以几乎不需要时间，而且<strong>commit一定要频繁，不然无法记录你的改动，</strong>如果你一天commit一次，中间的修改你就找不回来，然后等到了有网络的时候再<strong>将版本纪录和代码一起上传到远程仓库。</strong></p>
<p>4、<strong>Git 的内容完整性要优于SVN。</strong></p>
<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p>Git上的分支远比SVN上的强大。</p>
<h2 id="分支是什么"><a href="#分支是什么" class="headerlink" title="分支是什么"></a>分支是什么</h2><h3 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h3><ul>
<li>在 <strong>SVN</strong> 这类的版本控制系统上，<strong>分支（branch）是一个完整的目录，且这个目录拥有完整的实际文件</strong>。如果工作成员想要开启新的分支，那将会影响“全世界”！每个人都会拥有和你一样的分支。如果你的分支是用来对系统模块进行<strong>安全检查测试</strong>的，那将会像传染病一样，你改一个分支，还得让其他人重新切分支重新下载，而且这些代码很可能对稳定版本还是具有破坏性的。</li>
</ul>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ul>
<li>在 <strong>Git</strong>上，每个工作成员可以任意在自己的<strong>本地版本库</strong>开启无限个分支。举例：当我想尝试破坏自己的程序（安检测试），并且想保留这些被修改的文件供日后使用， 我可以开一个分支，做我喜欢的事。完全不需担心妨碍其他工作成员。<strong>只要我不合并及提交到主要版本库，没有一个工作成员会被影响</strong>。等到我不需要这个分支时， 我只要把它从我的本地版本库删除即可，无痛无痒。</li>
</ul>
<h2 id="什么时候需要创建分支"><a href="#什么时候需要创建分支" class="headerlink" title="什么时候需要创建分支"></a>什么时候需要创建分支</h2><p>   举个例子：我们需要开发一个新的网站，我们已经在主分支（master分支）上开发出了1.0发布版本，这个时候我们需要开发某个新的功能模块，那就需要创建一个分支（dev分支），而不是在主分支上继续开发，这样做有两个好处：</p>
<ul>
<li>我们在开发新的功能模块时，可能会遇到各种bug或者冲突，如果我们还在<strong>主分支</strong>上开发，万一冲突很严重，造成当前稳定版本的分支出问题，就会很麻烦。如果主分支始终保留着最新的稳定版本，在新的分支上开发，冲突严重时，最多也就是把当前分支删掉，从那个稳定分支重新分一支出来，这样处理起来就方便了，<strong>而且分支还可以保留开发中可能出现的各种bug方便修复但不影响主分支多的使用。</strong></li>
<li>当我们需要切换分支，例如切换到主分支（master）时候，会保存当前分支（dev）的状态，以便日后继续开发，防止丢失开发进度。举个例子：你突然接到一个电话说1.0发布版本有个很严重的问题需要紧急修补，而我们正在<strong>dev分支</strong>上开发新的功能模块，这时我们先返回到主分支，为这次紧急修补建立一个新分支（<strong>repair分支</strong>），并在其中修复问题。通过测试后，回到<strong>主分支</strong>，将<strong>repair分支合并进来</strong>，然后push到远程仓库。最后，我们切换到之前开发新需求的<strong>dev分支</strong>，继续工作而不会丢失掉已经开发的进度。</li>
</ul>
<p>可以在Git的任意一个提交点（commit point）开启分支！（其中一个方法是使用gitk –all 可观察整个提交记录，然后在任意点开啟分支）</p>
<h3 id="Git具有以下特点"><a href="#Git具有以下特点" class="headerlink" title="Git具有以下特点"></a>Git具有以下特点</h3><ul>
<li>Git 中每个克隆(clone)的版本库都是平等的。可以从任何一个版本库的克隆来创建属于自己的版本库，同时你的版本库也可以作为源提供给他人，只要你愿意。</li>
<li>Git 的每一次提取操作，实际上都是一次<strong>对代码仓库的完整备份</strong>。</li>
<li>提交完全在本地完成，无须别人给你授权，你的版本库你作主，并且提交总是会成功。</li>
<li>Git 的提交不会被打断，直到你的工作完全满意了，PUSH给他人或者他人PULL你的版本库，<strong>合并会发生在PULL和PUSH过程中</strong>，不能自动解决的冲突会提示你手工完成。</li>
</ul>
<h3 id="Git缺点"><a href="#Git缺点" class="headerlink" title="Git缺点"></a>Git缺点</h3><ul>
<li>Git 没有严格的权限管理控制，一般通过系统设置文件读写权限的方式来做权限控制。</li>
<li>工作目录只能是整个项目。比如 check out、建分支，都是基于整个项目的。而 SVN 可以基于项目中的某一个目录。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/hellow__world/article/details/72529022"><em><strong>详细透彻解读Git与SVN的区别（集中式VS分布式</strong></em>）</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Grafana搭建</title>
    <url>/Grafana%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Grafana是一款可视化工具，有着非常漂亮的图表和布局展示，功能齐全的度量仪表盘和图形编辑器，大多使用在时序数据的监控方面。同时提供监控告警功能。<div align=center><img width="400" height="200" src="../../../../images/2020/5-8/grafana.png" algin="center"/></div><span id="more"></span></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>Grafana</code>是一个跨平台的开源的度量分析和可视化工具，可以通过将采集的数据查询然后可视化的展示，并及时通知。它主要有以下特点：</p>
<p>1、展示方式：快速灵活的客户端图表，面板插件有许多不同方式的可视化指标和日志，官方库中具有丰富的仪表盘插件，比如热图、折线图、图表等多种展示方式；</p>
<p>2、通知提醒：以可视方式定义最重要指标的警报规则，Grafana将不断计算并发送通知，在数据达到阈值时通过Slack、PagerDuty等获得通知；</p>
<p>3、混合展示：在同一图表中混合使用不同的数据源，可以基于每个查询指定数据源，甚至自定义数据源；支持白天和夜间模式；</p>
<p>4、注释：使用来自不同数据源的丰富事件注释图表，将鼠标悬停在事件上会显示完整的事件元数据和标记；</p>
<p>5、过滤器：Ad-hoc过滤器允许动态创建新的键/值过滤器，这些过滤器会自动应用于使用该数据源的所有查询。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><p><code>grafana</code>下载地址：<a href="https://grafana.com/grafana/download/7.5.3">https://grafana.com/grafana/download/7.5.3</a></p>
<p><code>piechart</code>(图表)下载地址：<a href="https://grafana.com/grafana/plugins/grafana-piechart-panel/">https://grafana.com/grafana/plugins/grafana-piechart-panel/</a></p>
<p>将 <strong>grafana.rpm</strong>、<strong>grafana.ini</strong>、<strong>grafana-piechart-panel.zip</strong> 复制到 <strong>Linux</strong> 中</p>
<h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>将所有文件移动至指定目录，便于管理。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /app/grafana</span><br><span class="line">mv grafana-v7.4.2.rpm grafana.ini grafana-piechart-panel-1.6.1.zip /app/grafana</span><br></pre></td></tr></table></figure>

<h1 id="安装grafana"><a href="#安装grafana" class="headerlink" title="安装grafana"></a>安装grafana</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /app/grafana</span><br><span class="line">rpm -Uvh grafana-v7.4.2.rpm</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>grafana配置详解：<a href="https://grafana.com/docs/grafana/latest/administration/configuration/">https://grafana.com/docs/grafana/latest/administration/configuration/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp grafana.ini /etc/grafana</span><br></pre></td></tr></table></figure>

<blockquote>
<p>grafana.ini文件主要需要关注的配置为</p>
<p>domain = 当前域名</p>
<p>http_port = 80</p>
<p>enable_gzip = true</p>
<p>auth.anonymous enabled = false</p>
</blockquote>
<h2 id="服务操作命令"><a href="#服务操作命令" class="headerlink" title="服务操作命令"></a>服务操作命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 刚安装完需要重载systemd配置</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动服务</span></span><br><span class="line">systemctl start grafana-server</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看状态</span></span><br><span class="line">systemctl status grafana-server</span><br><span class="line"><span class="meta">#</span><span class="bash">设置开机启动</span></span><br><span class="line">systemctl enable grafana-server.service</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重载systemd配置</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启</span></span><br><span class="line">systemctl start grafana-server</span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止</span></span><br><span class="line">systemctl stop grafana-server</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启</span></span><br><span class="line">systemctl restart grafana-server</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看状态</span></span><br><span class="line">systemctl status grafana-server</span><br></pre></td></tr></table></figure>

<h2 id="相关文件位置"><a href="#相关文件位置" class="headerlink" title="相关文件位置"></a>相关文件位置</h2><ol>
<li>访问地址<br>IP:3000</li>
<li>默认账号密码<br>admin/admin</li>
<li>环境文件<br>/etc/sysconfig/grafana-server</li>
<li>日志文件<br>/var/log/grafana</li>
<li>数据库<br>/var/lib/grafana/grafana.db</li>
<li>配置文件<br>/etc/grafana/grafana.ini</li>
</ol>
<h1 id="升级Grafana"><a href="#升级Grafana" class="headerlink" title="升级Grafana"></a>升级Grafana</h1><p>官方提供的升级文档：<a href="https://grafana.com/docs/installation/upgrading/">Upgrading Grafana</a></p>
<ol>
<li><p>下载新版本Grafana</p>
</li>
<li><p>停止旧版本Grafana</p>
</li>
<li><p>执行命令进行升级(兼容性问题请查看官网)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -Uvh grafana-latest.rpm</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="Pie插件"><a href="#Pie插件" class="headerlink" title="Pie插件"></a>Pie插件</h1><p>安装Pie插件，可使用饼图展示数据。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">unzip -q grafana-piechart-panel-1.6.1.zip</span><br><span class="line"><span class="meta">#</span><span class="bash"> 移动到grafana插件目录下</span></span><br><span class="line">mv grafana-piechart-panel /var/lib/grafana/plugins/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启grafana</span></span><br><span class="line">systemctl restart grafana-server</span><br></pre></td></tr></table></figure>

<h1 id="检查服务"><a href="#检查服务" class="headerlink" title="检查服务"></a>检查服务</h1><p>启动服务，打开浏览器，输入IP+端口，3000为Grafana的默认侦听端口。</p>
<div align=center><img src="../../../../images/2020/5-8/grafana_result.png" algin="center"/></div>]]></content>
      <categories>
        <category>工具</category>
        <category>Linux</category>
        <category>安装</category>
      </categories>
      <tags>
        <tag>tips</tag>
        <tag>grafana</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS协议</title>
    <url>/HTTPS%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>HTTP和HTTPS协议是互联网上应用最为广泛的网络协议，现在为了安全，很多网站从HTTP的阵营转向HTTPS。近两年，Google、Baidu、Facebook 等这样的互联网巨头，不谋而合地开始大力推行 HTTPS， 国内外的大型互联网公司很多也都已经启用了全站 HTTPS，这也是未来互联网发展的趋势。<div align=center><img src="../../../../images/2018-5/HTTPS/https.jpg" algin="center"/></p>
</div><span id="more"></span>

<h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><h2 id="TCP协议的三次握手与四次挥手"><a href="#TCP协议的三次握手与四次挥手" class="headerlink" title="TCP协议的三次握手与四次挥手"></a>TCP协议的三次握手与四次挥手</h2><p>先来一张网络模型图（应表会传网数物），可以看到TCP、UDP协议处于传输层。</p>
<div align=center><img src="../../../../images/2018-5/HTTPS/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.gif" algin="center"/>


</div>

<p>建立TCP需要三次握手才能建立，而断开连接连接则需要四次挥手。整个过程如下图：</p>
<div align=center><img src="../../../../images/2018-5/HTTPS/tcp.gif" algin="center"/></div>

<h2 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h2><div align=center><img src="../../../../images/2018-5/HTTPS/tcp_1.png" algin="center"/></div>

<p>   1、<code>Client</code>端发送连接请求报文。</p>
<p>   2、<code>Server</code>端接受连接后回复ACK报文，并为这次连接分配资源。</p>
<p>   3、<code>Client</code>端接收到ACK报文后也向Server段发送报文，并分配资源</p>
<p>这就是TCP的<strong>三次握手建立连接</strong>阶段。</p>
<h2 id="四次挥手断开连接"><a href="#四次挥手断开连接" class="headerlink" title="四次挥手断开连接"></a>四次挥手断开连接</h2><div align=center><img src="../../../../images/2018-5/HTTPS/tcp_2.png" algin="center"/></div>

<p>中断连接端可以是Client端，也可以是Server端。</p>
<p>   1、假设<code>Client</code>端发起中断请求，也就是发送FIN报文。</p>
<p>   2、<code>Server</code>端接到FIN报文后，告诉Client端，“你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。</p>
<p>   3、当<code>Server</code>端确定数据已发送完成，则向Client端发送FIN报文。告诉Client端，”好了，我这边数据发完了，准备好关闭连接了”。</p>
<p>   4、<code>Client</code>端收到FIN报文后，就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。Server端收到ACK后，就知道可以断开连接了。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那Client端也可以关闭连接了。</p>
<p>这就是TCP四次挥手断开连接。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、为什么连接的时候是三次握手，关闭的时候却是四次握手？</p>
<blockquote>
<p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
</blockquote>
<p>二、为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间Maximum Segment Lifetime)才能返回到CLOSE状态？</p>
<blockquote>
<p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p>
</blockquote>
<h1 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h1><p>HTTPS（Hypertext Transfer Protocol over Secure Socket Layer，基于SSL的HTTP协议）使用了HTTP协议，但HTTPS使用不同于HTTP协议的默认端口及一个加密、身份验证层（HTTP与TCP之间）。HTTPS是一个安全通信通道，用于在客户计算机和服务器之间交换信息。它使用安全套接字层(SSL)进行信息交换，简单来说它是HTTP的安全版。</p>
<ul>
<li><strong>内容加密：</strong>建立一个信息安全通道，来保证数据传输的安全；</li>
<li><strong>身份认证：</strong>确认网站的真实性；</li>
<li><strong>数据完整性：</strong>防止内容被第三方冒充或者篡改；</li>
</ul>
<div align=center><img src="../../../../images/2018-5/HTTPS/compare.jpg" algin="center"/></div>

<h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>有流式、分组两种。<strong>加密和解密都是使用的同一个密钥</strong>。</p>
<p>例如：<em>DES、AES-GCM、ChaCha20-Poly1305</em>等。</p>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p><strong>加密使用的密钥和解密使用的密钥是不相同的</strong>，分别称为：公钥、私钥，公钥的算法是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。</p>
<p>例如：<em>RSA、DSA、ECDSA、 DH、ECDHE</em>。</p>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且<strong>算法不可逆</strong>。</p>
<p>例如：<em>MD5、SHA-1、SHA-2、SHA-256</em> 等</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过。hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改。</p>
<h2 id="请求过程"><a href="#请求过程" class="headerlink" title="请求过程"></a>请求过程</h2><p>HTTPS其实是有两部分组成：<strong>HTTP + SSL/TLS</strong>，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。</p>
<div align=center><img src="../../../../images/2018-5/HTTPS/HTTPS.png" algin="center"/></div>

<h3 id="客户端发起HTTPS请求"><a href="#客户端发起HTTPS请求" class="headerlink" title="客户端发起HTTPS请求"></a>客户端发起HTTPS请求</h3><p>用户在浏览器里输入一个https网址，连接到server的443端口。</p>
<h3 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><p>采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p>
<h3 id="传送证书"><a href="#传送证书" class="headerlink" title="传送证书"></a>传送证书</h3><p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p>
<h3 id="客户端解析证书"><a href="#客户端解析证书" class="headerlink" title="客户端解析证书"></a>客户端解析证书</h3><p>这部分工作是有<strong>客户端的TLS来完成</strong>的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p>
<h3 id="传送加密信息"><a href="#传送加密信息" class="headerlink" title="传送加密信息"></a>传送加密信息</h3><p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p>
<h3 id="服务端解密信息"><a href="#服务端解密信息" class="headerlink" title="服务端解密信息"></a>服务端解密信息</h3><p>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p>
<h3 id="传输加密后的信息"><a href="#传输加密后的信息" class="headerlink" title="传输加密后的信息"></a>传输加密后的信息</h3><p>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p>
<h3 id="客户端解密信息"><a href="#客户端解密信息" class="headerlink" title="客户端解密信息"></a>客户端解密信息</h3><p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HTTPS请求连接的全过程可简化理解为：客户端拿到服务端非对称加密的公钥验证其身份后，将对称加密的私钥通过非对称加密的公钥加密后传输给服务端，服务端通过非对称加密的私钥解密后得到对称加密的私钥，其后客户端和服务端通过对称加密的私钥对数据进行加密传输。</p>
<p>相比 HTTP 协议，HTTPS 协议增加了很多握手、加密解密等流程，虽然过程很复杂，但其可以保证数据传输的安全。然而，加密和解密过程需要耗费系统大量的开销，严重降低机器的性能，相关测试数据表明使用HTTPS协议传输数据的工作效率只有使用HTTP协议传输的十分之一。所谓鱼与熊掌不可兼得，适当的选择HTTP和HTTPS协议非常重要。</p>
]]></content>
      <categories>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>HttpClient后台跨域</title>
    <url>/HttpClient%E5%90%8E%E5%8F%B0%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>跨域可以说是一个经常遇到的问题，最近在联调一个身份证识别接口，该接口由python语言编写，Java语言调用，刚开始采用了CORS（Cross-Origin Resource Sharing）跨域，在IE8上一直出现兼容性问题，固定的思维容易出现错误，自己一直想着前端Ajax跨域而忽略了后台HttpClient的跨域，最后还是用HttpClient顺利解决问题，避免了浏览器跨域带来的兼容性问题。<div align=center><img width="700" height="200" src="../../../../images/2018-01-20/HTTPClient.png" algin="center"/></div><span id="more"></span></p>
<h1 id="HttpClient-VS-Jsonp"><a href="#HttpClient-VS-Jsonp" class="headerlink" title="HttpClient VS Jsonp"></a>HttpClient VS Jsonp</h1><p>之前的博客有说过Jsonp的跨域方式，<strong>jsonp的核心则是动态添加<code>&lt;script&gt;</code>标签来调用服务器提供的js脚本</strong>。相比于HttpClient，Jsonp有两个很大的缺点：</p>
<p>1、它只能发送get请求，如果发送post请求会造成无法解析获取不到数据的问题。</p>
<p>2、如果返回的数据没有经过配置相应的编码文件来处理，拿到的数据可能会是一堆乱码。</p>
<p>问题总是能解决，HttpClient则没那么多约束，HttpClient封装了http协议的jar包，基本的请求方法get、post、put、 delete都能实现，当然得在web.xml文件中配置相应的filter拦截器拦截请求后再设好编码，一般返回的参数都是Json字符串，而我们只需要导入Jackson或者fastJson或者别的jar包来解析这对象把他转换成你所需要的数据即可。</p>
<h1 id="整合Spring"><a href="#整合Spring" class="headerlink" title="整合Spring"></a>整合Spring</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="封装方法"><a href="#封装方法" class="headerlink" title="封装方法"></a>封装方法</h2><p>新建HttpClientUtil工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doGet</span><span class="params">(String url, Map&lt;String, String&gt; param)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建Httpclient对象</span></span><br><span class="line">		CloseableHttpClient httpclient = HttpClients.createDefault();</span><br><span class="line"></span><br><span class="line">		String resultString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 创建uri</span></span><br><span class="line">			URIBuilder builder = <span class="keyword">new</span> URIBuilder(url);</span><br><span class="line">			<span class="keyword">if</span> (param != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (String key : param.keySet()) &#123;</span><br><span class="line">					builder.addParameter(key, param.get(key));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			URI uri = builder.build();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 创建http GET请求</span></span><br><span class="line">			HttpGet httpGet = <span class="keyword">new</span> HttpGet(uri);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 执行请求</span></span><br><span class="line">			response = httpclient.execute(httpGet);</span><br><span class="line">			<span class="comment">// 判断返回状态是否为200</span></span><br><span class="line">			<span class="keyword">if</span> (response.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;</span><br><span class="line">				resultString = EntityUtils.toString(response.getEntity(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">					response.close();</span><br><span class="line">				&#125;</span><br><span class="line">				httpclient.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> resultString;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doGet</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> doGet(url, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doPost</span><span class="params">(String url, Map&lt;String, String&gt; param)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建Httpclient对象</span></span><br><span class="line">		CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line">		CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">		String resultString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 创建Http Post请求</span></span><br><span class="line">			HttpPost httpPost = <span class="keyword">new</span> HttpPost(url);</span><br><span class="line">			<span class="comment">// 创建参数列表</span></span><br><span class="line">			<span class="keyword">if</span> (param != <span class="keyword">null</span>) &#123;</span><br><span class="line">				List&lt;NameValuePair&gt; paramList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">				<span class="keyword">for</span> (String key : param.keySet()) &#123;</span><br><span class="line">					paramList.add(<span class="keyword">new</span> BasicNameValuePair(key, param.get(key)));</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 模拟表单</span></span><br><span class="line">				UrlEncodedFormEntity entity = <span class="keyword">new</span> UrlEncodedFormEntity(paramList);</span><br><span class="line">				httpPost.setEntity(entity);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 执行http请求</span></span><br><span class="line">			response = httpClient.execute(httpPost);</span><br><span class="line">			resultString = EntityUtils.toString(response.getEntity(), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				response.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> resultString;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doPost</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> doPost(url, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doPostJson</span><span class="params">(String url, String json)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建Httpclient对象</span></span><br><span class="line">		CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line">		CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">		String resultString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 创建Http Post请求</span></span><br><span class="line">			HttpPost httpPost = <span class="keyword">new</span> HttpPost(url);</span><br><span class="line">			<span class="comment">// 创建请求内容</span></span><br><span class="line">			StringEntity entity = <span class="keyword">new</span> StringEntity(json, ContentType.APPLICATION_JSON);</span><br><span class="line">			httpPost.setEntity(entity);</span><br><span class="line">			<span class="comment">// 执行http请求</span></span><br><span class="line">			response = httpClient.execute(httpPost);</span><br><span class="line">			resultString = EntityUtils.toString(response.getEntity(), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				response.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> resultString;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//创建一个httpclient对象</span></span><br><span class="line">		CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line">		<span class="comment">//创建一个GET对象</span></span><br><span class="line">		HttpGet get = <span class="keyword">new</span> HttpGet(<span class="string">&quot;http://www.sogou.com&quot;</span>);</span><br><span class="line">		<span class="comment">//执行请求</span></span><br><span class="line">		CloseableHttpResponse response = httpClient.execute(get);</span><br><span class="line">		<span class="comment">//取响应的结果</span></span><br><span class="line">		<span class="keyword">int</span> statusCode = response.getStatusLine().getStatusCode();</span><br><span class="line">		System.out.println(statusCode);</span><br><span class="line">		HttpEntity entity = response.getEntity();</span><br><span class="line">		String string = EntityUtils.toString(entity, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">		System.out.println(string);</span><br><span class="line">		<span class="comment">//关闭httpclient</span></span><br><span class="line">		response.close();</span><br><span class="line">		httpClient.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGetWithParam</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="comment">//创建一个httpclient对象</span></span><br><span class="line">		CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line">		<span class="comment">//创建一个uri对象</span></span><br><span class="line">		URIBuilder uriBuilder = <span class="keyword">new</span> URIBuilder(<span class="string">&quot;http://www.sogou.com/web&quot;</span>);</span><br><span class="line">		uriBuilder.addParameter(<span class="string">&quot;query&quot;</span>, <span class="string">&quot;花千骨&quot;</span>);</span><br><span class="line">		HttpGet get = <span class="keyword">new</span> HttpGet(uriBuilder.build());</span><br><span class="line">		<span class="comment">//执行请求</span></span><br><span class="line">		CloseableHttpResponse response = httpClient.execute(get);</span><br><span class="line">		<span class="comment">//取响应的结果</span></span><br><span class="line">		<span class="keyword">int</span> statusCode = response.getStatusLine().getStatusCode();</span><br><span class="line">		System.out.println(statusCode);</span><br><span class="line">		HttpEntity entity = response.getEntity();</span><br><span class="line">		String string = EntityUtils.toString(entity, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">		System.out.println(string);</span><br><span class="line">		<span class="comment">//关闭httpclient</span></span><br><span class="line">		response.close();</span><br><span class="line">		httpClient.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建一个post对象</span></span><br><span class="line">		HttpPost post = <span class="keyword">new</span> HttpPost(<span class="string">&quot;http://localhost:8082/httpclient/post.action&quot;</span>);</span><br><span class="line">		<span class="comment">//执行post请求</span></span><br><span class="line">		CloseableHttpResponse response = httpClient.execute(post);</span><br><span class="line">		String string = EntityUtils.toString(response.getEntity());</span><br><span class="line">		System.out.println(string);</span><br><span class="line">		response.close();</span><br><span class="line">		httpClient.close();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPostWithParam</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line">	 </span><br><span class="line">		<span class="comment">//创建一个post对象  </span></span><br><span class="line">		HttpPost post = <span class="keyword">new</span> HttpPost(<span class="string">&quot;http://localhost:8082/httpclient/post.action&quot;</span>);</span><br><span class="line">		<span class="comment">//创建一个Entity。模拟一个表单</span></span><br><span class="line">		List&lt;NameValuePair&gt; kvList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		kvList.add(<span class="keyword">new</span> BasicNameValuePair(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;张三&quot;</span>));</span><br><span class="line">		kvList.add(<span class="keyword">new</span> BasicNameValuePair(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123&quot;</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//包装成一个Entity对象 </span></span><br><span class="line">		StringEntity entity = <span class="keyword">new</span> UrlEncodedFormEntity(kvList, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">		<span class="comment">//设置请求的内容 </span></span><br><span class="line">		post.setEntity(entity);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//执行post请求</span></span><br><span class="line">		CloseableHttpResponse response = httpClient.execute(post);</span><br><span class="line">		String string = EntityUtils.toString(response.getEntity());</span><br><span class="line">		System.out.println(string);</span><br><span class="line">		response.close();</span><br><span class="line">		httpClient.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="项目实例"><a href="#项目实例" class="headerlink" title="项目实例"></a>项目实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单处理Service</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Title: OrderServiceImpl&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Description: &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;ORDER_BASE_URL&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String ORDER_BASE_URL;</span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;ORDER_CREATE_URL&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String ORDER_CREATE_URL;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">createOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用order的服务提交订单。</span></span><br><span class="line">		String json = HttpClientUtil.doPostJson(ORDER_BASE_URL + ORDER_CREATE_URL, JsonUtils.objectToJson(order));</span><br><span class="line">		<span class="comment">//把json转换成taotaoResult</span></span><br><span class="line">		TaotaoResult taotaoResult = TaotaoResult.format(json);</span><br><span class="line">		<span class="keyword">if</span> (taotaoResult.getStatus() == <span class="number">200</span>) &#123;</span><br><span class="line">			Object orderId = taotaoResult.getData();</span><br><span class="line">			<span class="keyword">return</span> orderId.toString();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>HttpClient与Jsonp能够轻易的解决跨域问题，从而得到自己想要的数据(来自不同IP，协议，端口)，唯一的不同点是，HttpClient是在后台Java代码中进行跨域访问，而Jsonp是在前台js中进行跨域访问。跨域还有一级跨域，二级跨域，更多内容值得研究。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA实现HTML转PDF</title>
    <url>/JAVA%E5%AE%9E%E7%8E%B0HTML%E8%BD%ACPDF/</url>
    <content><![CDATA[<p>​    最近公司里面有一个任务，在线题卡，就是把客户在线编辑的题卡样式保存下来，然后可以导出为PDF格式。于是上网找了一系列的资料，找到了以下两种方法：</p>
<ol>
<li>使用<code>wkhtmltox</code></li>
<li>使用<code>iText+Flying Saucer</code></li>
</ol>
<p>但是还是强烈推荐用第一种方法。<div align=center><img width="450" height="200" src="../../../../images/2017-9-13/additional/html_to_pdf.png" algin="center"/></div><span id="more"></span></p>
<h1 id="使用wkhtmltox-推荐"><a href="#使用wkhtmltox-推荐" class="headerlink" title="使用wkhtmltox(推荐)"></a>使用wkhtmltox(推荐)</h1><p>wkhtmltox实现网页转换成图片或PDF</p>
<h2 id="命令实现"><a href="#命令实现" class="headerlink" title="命令实现"></a>命令实现</h2><ol>
<li>进入wkhtmltox官网软件下载  ：<a href="https://wkhtmltopdf.org/downloads.html">https://wkhtmltopdf.org/downloads.html</a></li>
<li>安装完成后进入${home}/bin目录下有两个exe文件，通过名称就可以辨别<code>wkhtmltoimage.exe</code>是将HTML转化为image，<code>wkhtmltopdf.exe</code>是将HTML转化为PDF文件，这正是我们想要的。</li>
</ol>
<p><img src="../../../../images/2017-8-27/HtmlToPdf/HtmlToPdf.png" alt="path"></p>
<ol start="3">
<li>进入${home}/bin目录下打开cmd输入以下命令验证 </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">wkhtmltopdf HTML路径 保存路径</span><br><span class="line">如： wkhtmltopdf www.baidu.com d:\test.pdf</span><br></pre></td></tr></table></figure>

<p><img src="../../../../images/2017-8-27/HtmlToPdf/command.png" alt="command"></p>
<p>生成完成后会出现Done。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>JAVA代码中调用wkhtmltopdf生成PDF文件，以下为代码片段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HTMLTOPPDF</span></span><br><span class="line"><span class="comment"> * 利用wkhtmltopdf生成PDF</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HtmlToPDF</span> </span>&#123;</span><br><span class="line">    <span class="comment">//wkhtmltopdf.exe安装路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String toPdfTool = <span class="string">&quot;E:\\SmallTools\\wkhtmltox\\wkhtmltopdf\\bin\\wkhtmltopdf.exe&quot;</span>;</span><br><span class="line">    <span class="comment">//需要生成PDF的URL</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String srcPath = <span class="string">&quot;http://www.jianshu.com/p/4d65857ffe5e&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"> 		<span class="comment">//设置纸张大小: A4, Letter, etc.</span></span><br><span class="line">        String pageSize = <span class="string">&quot;A4&quot;</span>;</span><br><span class="line">		<span class="comment">//生成后存放路径</span></span><br><span class="line">        String destPath = <span class="string">&quot;E:\\PDF生成教程及讲解.pdf&quot;</span>; </span><br><span class="line">        convert(pageSize, destPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">convert</span><span class="params">(String pageSize, String destPath)</span></span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(destPath);</span><br><span class="line">        File parent = file.getParentFile();</span><br><span class="line">        <span class="keyword">if</span> (!parent.exists())&#123;</span><br><span class="line">            parent.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder cmd = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        cmd.append(toPdfTool).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        cmd.append(<span class="string">&quot;--page-size &quot;</span>);</span><br><span class="line">        cmd.append(pageSize).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        cmd.append(srcPath).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        cmd.append(destPath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(cmd.toString());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细参数说明可参考：<a href="http://www.jianshu.com/p/4d65857ffe5e">http://www.jianshu.com/p/4d65857ffe5e</a></p>
<h1 id="使用iText-Flying-Saucer"><a href="#使用iText-Flying-Saucer" class="headerlink" title="使用iText+Flying Saucer"></a>使用iText+Flying Saucer</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">itext可实现 </span><br><span class="line">1.可以进行块的创建</span><br><span class="line">2.表格的使用</span><br><span class="line">3.设置页面的事件</span><br><span class="line">4.字体的设置</span><br><span class="line">5.图片的设置（包含水印）</span><br><span class="line">6.HTML转化成PDF（支持css,javascript）</span><br><span class="line">7.表单创建</span><br><span class="line">8.PDF之间的操作等详细的内容可以查看网站的说明。</span><br></pre></td></tr></table></figure>

<h2 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itextpdf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itextpdf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xhtmlrenderer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flying-saucer-pdf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成pdf，添加生成pdf所使用的字符集.注：这里字符集要和模板中使用的字符集一一致。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HtmlToPDF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Document document = <span class="keyword">new</span> Document(PageSize.A4.rotate()); <span class="comment">//设置为A4纸大小</span></span><br><span class="line"></span><br><span class="line">        ITextRenderer renderer = <span class="keyword">new</span> ITextRenderer();</span><br><span class="line">        ITextFontResolver fontResolver = renderer.getFontResolver();</span><br><span class="line">        fontResolver.addFont(<span class="string">&quot;D:/simsun.ttc&quot;</span>, BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED);</span><br><span class="line">        <span class="comment">// step 2</span></span><br><span class="line">        PdfWriter writer = PdfWriter.getInstance(document, <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\pdf.pdf&quot;</span>));</span><br><span class="line">        <span class="comment">// step 3</span></span><br><span class="line">        document.open();</span><br><span class="line">        <span class="comment">// step 4</span></span><br><span class="line">        XMLWorkerHelper.getInstance().parseXHtml(writer, document,</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:/a.html&quot;</span>));</span><br><span class="line">        <span class="comment">//step 5</span></span><br><span class="line">        document.close();</span><br><span class="line">        System.out.println( <span class="string">&quot;PDF Created!&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li><p>.输入的HTML页面必须是标准的XHTML页面。页面的顶上必须是这样的格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li>生成PDF，添加生成PDF所使用的字符集.注：这里字符集要和模板中使用的字符集一一致。 比如:java中使用宋体 renderer.getFontResolver().addFont(“C:/Windows/Fonts/simsun.ttc”, BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED); 那么HTML的body中样式必须加上 style=’font-family:SimSun’，要是使用其他字符生成pdf时候，中文就会不显示生成PDF</li>
<li>设置PDF的页面大小模板页面中添加该样式：@page { size: 8.5in 11in; }这时候生成PDF页面正好是A4纸大小</li>
<li>所需的jar包，<a href="../../../../images/2017-8-27/HtmlToPdf/flyingsaucer.zip">下载点我</a>。核心jar是修改后的</li>
</ol>
<h1 id="比较和总结"><a href="#比较和总结" class="headerlink" title="比较和总结"></a>比较和总结</h1><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>itext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. java生成PDF大部分都是用itext，itext的确是java开源组件的第一选择。不过itext也有局限，就是要自己写模版，系统中的表单数量有好几百个，为每个表单做一个导出模版不现实。</span><br><span class="line">2. 并且itext中文适配不是很好和换行问题。</span><br><span class="line">3. 且对HTML格式要求严格。</span><br></pre></td></tr></table></figure>

<p>wkhtmltopdf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 生成PDF时会自动根据你在HTML页面中H标签生成树形目录结构。</span><br><span class="line">2. 小巧方便，转换速度快。</span><br><span class="line">3. 跨平台，在Liunx下用，在win下也可以用。</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    综上比较，wkhtmltopdf是将HTML转为图片或是PDF最好的选择。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA定时调度 Timer和Executors</title>
    <url>/JAVA%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6-Timer%E5%92%8CExecutors/</url>
    <content><![CDATA[<p>近期在公司做了一个关于定时执行任务的功能（没有使用框架定时），查了一下资料，有<strong>Thread</strong>、<strong>Timer</strong>和<strong>Executors</strong>三种方法，之前使用的是Timer，但是详细查了资料觉得<strong>Executors更优</strong>，所以在这里比较一下它们的区别。<span id="more"></span></p>
<h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><p>这是最基本的，创建一个Thread，然后让它在while循环里一直运行着，通过sleep方法来达到定时任务的效果。这样可以快速简单的实现，代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task1</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// run in a second  </span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> timeInterval = <span class="number">1000</span>;  </span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">                    <span class="comment">// ------- code for task to run  </span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Hello !!&quot;</span>);  </span><br><span class="line">                    <span class="comment">// ------- ends here  </span></span><br><span class="line">                    <span class="keyword">try</span> &#123;  </span><br><span class="line">                        Thread.sleep(timeInterval);  </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                        e.printStackTrace();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);  </span><br><span class="line">        thread.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>Thread的做定时任务的几率不大，因为不可控制启动停止时间、不能指定想要的delay时间。</p>
</blockquote>
<h2 id="Timer类"><a href="#Timer类" class="headerlink" title="Timer类"></a>Timer类</h2><ol>
<li><p>于第一种方式相比，优势 :</p>
<p>(1) 当启动和去取消任务时可以控制 ;</p>
<p>(2) 第一次执行任务时可以指定你想要的delay时间。</p>
</li>
<li><p>在实现时，Timer类可以调度任务，TimerTask则是通过在run()方法里实现具体任务。 Timer实例可以调度多任务，它是线程安全的。 </p>
</li>
<li><p>当Timer的构造器被调用时，它创建了一个线程，这个线程可以用来调度任务。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task2</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        TimerTask task = <span class="keyword">new</span> TimerTask() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="comment">// task to run goes here  </span></span><br><span class="line">                System.out.println(<span class="string">&quot;Hello !!!&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();  </span><br><span class="line">        <span class="keyword">long</span> delay = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">long</span> intevalPeriod = <span class="number">1</span> * <span class="number">1000</span>;  </span><br><span class="line">        <span class="comment">// schedules the task to be run in an interval  </span></span><br><span class="line">        timer.scheduleAtFixedRate(task, delay, intevalPeriod);  </span><br><span class="line">    &#125; <span class="comment">// end of main  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>缺点：如果TimerTask抛出未检查的异常，Timer将会产生无法预料的行为。Timer线程并不捕获异常，所以 TimerTask抛出的未检查的异常会终止timer线程。这种情况下，Timer也不会再重新恢复线程的执行了;它错误的认为整个Timer都被取消了。此时，已经被安排但尚未执行的TimerTask永远不会再执行了，新的任务也不能被调度了。</p>
</blockquote>
<h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><ol>
<li><p><code>ScheduledExecutorService</code>是从Java SE5的java.util.concurrent里，做为并发工具类被引进的，这是最理想的定时任务实现方式。  </p>
</li>
<li><p>相比于上两个方法，它有以下好处 : </p>
<p>(1) 相比于Timer的单线程，它是通过线程池的方式来执行任务的 ;</p>
<p>(2) 可以很灵活的去设定第一次执行任务delay时间 ;</p>
<p>(3) 提供了良好的约定，以便设定执行的时间间隔 。</p>
</li>
<li><p>下面是实现代码，我们通过ScheduledExecutorService展示这个例子，通过代码里参数的控制，首次执行加了delay时间。 </p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task3</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="comment">// task to run goes here  </span></span><br><span class="line">                System.out.println(<span class="string">&quot;Hello !!&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">        ScheduledExecutorService service = Executors  </span><br><span class="line">                .newSingleThreadScheduledExecutor();  </span><br><span class="line">        <span class="comment">// 第二个参数为首次执行的延时时间，第三个参数为定时执行的间隔时间  </span></span><br><span class="line">        service.scheduleAtFixedRate(runnable, <span class="number">10</span>, <span class="number">1</span>, TimeUnit.SECONDS);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>线程池能按时间计划来执行任务，允许用户设定计划执行任务的时间。</li>
<li>当任务较多时，线程池可能会自动创建更多的工作线程来执行任务 。</li>
<li>支持多个任务并发执行。</li>
</ol>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Timer</code>是单线程的。所以task都是串行执行。假如其中一个task执行需要很长的时间，那其他的task只能干巴巴的等着。</p>
<p><code>ScheduledThreadPoolExecutor</code>是一个可以重复执行任务的<code>线程池</code>，并且可以指定任务的间隔和延迟时间。它作为比Timer/TimerTask更加通用的替代品。因为它允许多个服务线程，接受不同的时间单位，且不需要继承TimeTask（仅仅需要实现Runnable接口）。配置ScheduledThreadPoolExecutor为单线程，则与使用Timer等效。</p>
<p><strong>上述，基本说明了在以后的开发中尽可能使用ScheduledExecutorService(JDK1.5以后)替代Timer。</strong></p>
<p>下面是自己做的功能，通过短信API定时查询教师回复信息并更新数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定时查询教师回复状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStatusSchedule</span><span class="params">(<span class="keyword">final</span> Date replyEnd)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">final</span> SendMessage sendMsg = <span class="keyword">new</span> SendMessage();</span><br><span class="line">	<span class="keyword">final</span> ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">	</span><br><span class="line">	service.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Date nowDate = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).parse(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date()));<span class="comment">//当前时间</span></span><br><span class="line">				<span class="comment">//若截至时间在当前时间之前执行定时任务 否则不执行</span></span><br><span class="line">				<span class="keyword">if</span> (!nowDate.before(replyEnd)) &#123;</span><br><span class="line">					service.shutdown();  <span class="comment">//停止任务</span></span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					Map&lt;String,Object&gt; map = sendMsg.getReplyMsg();  <span class="comment">//获取回复信息</span></span><br><span class="line">					<span class="keyword">if</span>(!map.isEmpty())&#123;		 <span class="comment">//当map不为空时执行						</span></span><br><span class="line">						updateMsgStatus(map);   <span class="comment">//更新数据库</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.MINUTES); <span class="comment">//执行后第一次查询在1分钟之后，每隔1分钟查询一次。 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA实现简单网络爬虫</title>
    <url>/JAVA%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<div align=center><img width="700" height="300" src="../../../../images/2017-4-1/%E7%88%AC%E8%99%AB.jpg" algin="center"/></div><span id="more"></span>

<h2 id="爬虫基本理解"><a href="#爬虫基本理解" class="headerlink" title="爬虫基本理解"></a>爬虫基本理解</h2><blockquote>
<p>通俗一点，<code>爬虫</code>是用来快速、批量获取我们在网络需要的东西，过滤掉不需要的东西，比如我可以爬一个网站的所有图片省的一张一张去保存，也可以爬其他数据来做研究、统计、数据分析，即是：</p>
<p>(1) 对抓取目标的描述或定义；</p>
<p>(2) 对网页或数据的分析与过滤；</p>
<p>(3) 对URL的搜索策略。</p>
<p>很多语言都可以做爬虫，在这里记录JAVA做一个简单的爬虫，等以后学会其他语言了再用其他语言做爬虫，哈哈…</p>
</blockquote>
<h2 id="实现爬虫需要"><a href="#实现爬虫需要" class="headerlink" title="实现爬虫需要"></a>实现爬虫需要</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>简单<strong>HTML、CSS、JS</strong>等前端知识</li>
<li><a href="http://deerchao.net/tutorials/regex/regex.htm"><strong>正则表达式</strong></a>（很重要，用于过滤不需要的信息）</li>
<li>JAVA<strong>语言知识</strong>（可换成其他语言）</li>
</ul>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ol>
<li>首先你要给它一个种子链接<code>URL</code></li>
<li>在种子链接的页面查找其他的URL，重复1步骤</li>
<li>有链接有页面，然后你可以在页面中查找需要的内容</li>
</ol>
<h2 id="简单爬虫代码"><a href="#简单爬虫代码" class="headerlink" title="简单爬虫代码"></a>简单爬虫代码</h2><p>在这里做个示例：把网站<code>https://www.baidu.com/home/news/data/newspage?nid=7953839918275534&amp;n_type=0&amp;p_from=1</code>  图片全部down下来并保存到本地磁盘的操作。</p>
<h3 id="JAVA基本方式"><a href="#JAVA基本方式" class="headerlink" title="JAVA基本方式"></a>JAVA基本方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reptile</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doGet</span><span class="params">(String urlStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		URL url;</span><br><span class="line">		String html = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			url = <span class="keyword">new</span> URL(urlStr);</span><br><span class="line">			HttpURLConnection connection = (HttpURLConnection) url.openConnection();</span><br><span class="line">			connection.setRequestProperty(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">			connection.setRequestProperty(<span class="string">&quot;Accept-Charset&quot;</span>, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">			connection.setRequestProperty(<span class="string">&quot;Accept-Language&quot;</span>, <span class="string">&quot;en-US,en&quot;</span>);</span><br><span class="line">			connection.setRequestProperty(<span class="string">&quot;User-Agent&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.22 (KHTML, like Gecko) 					Chrome/25.0.1364.160 Safari/537.22&quot;</span>);</span><br><span class="line">			connection.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">			connection.setConnectTimeout(<span class="number">5000</span>);</span><br><span class="line">			connection.setDoInput(<span class="keyword">true</span>);</span><br><span class="line">			connection.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">			<span class="keyword">if</span> (connection.getResponseCode() == <span class="number">200</span>) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;已连接，正在解析。。。。。。&quot;</span>);</span><br><span class="line">				InputStream in = connection.getInputStream();</span><br><span class="line">				html = StreamTool.inToStringByByte(in);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(connection.getResponseCode());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;get请求失败&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> html;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Reptile reptile = <span class="keyword">new</span> Reptile()</span><br><span class="line">		String htmlStr = Reptile.doGet(<span class="string">&quot;https://www.baidu.com/home/news/data/</span></span><br><span class="line"><span class="string">                                       newspagenid=7953839918275534&amp;n_type=0&amp;p_from=1&quot;</span>);</span><br><span class="line"></span><br><span class="line">		File f = <span class="keyword">new</span> File(<span class="string">&quot;E://imgs&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (!f.exists()) &#123;</span><br><span class="line">			f.mkdirs();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Pattern pattern = Pattern.compile(<span class="string">&quot;&lt;img.*src=(.*?)[^&gt;]*?&gt;&quot;</span>); <span class="comment">//匹配Imag标签</span></span><br><span class="line">		Matcher matcher = pattern.matcher(htmlStr); <span class="comment">// 定义一个matcher用来做匹配</span></span><br><span class="line">      </span><br><span class="line">		System.out.println(<span class="string">&quot;正在下载&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">			String imgs = matcher.group();</span><br><span class="line">			Matcher srcMatcher = Pattern.compile(<span class="string">&quot;https:\&quot;?(.*?)(\&quot;|&gt;|\\s+)&quot;</span>).matcher(imgs);</span><br><span class="line">			<span class="keyword">while</span> (srcMatcher.find()) &#123;</span><br><span class="line">				String src = srcMatcher.group().substring(<span class="number">0</span>,srcMatcher.group().length() - <span class="number">1</span>);</span><br><span class="line">				System.out.println(src);</span><br><span class="line">              	 <span class="comment">// 获取后缀名</span></span><br><span class="line">				String imageName = src.substring(src.lastIndexOf(<span class="string">&quot;/&quot;</span>) + <span class="number">1</span>,src.length());</span><br><span class="line">				reptile.downLoad(src, imageName);   <span class="comment">//下载图片到本地</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//下载图片到本地</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downLoad</span><span class="params">(String src, String imageName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		URL url = <span class="keyword">new</span> URL(src);</span><br><span class="line">      </span><br><span class="line">		URLConnection uri = url.openConnection();</span><br><span class="line">		InputStream is = uri.getInputStream(); <span class="comment">// 获取数据流</span></span><br><span class="line">		<span class="comment">// 写入数据流</span></span><br><span class="line">		OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;E://imgs&quot;</span>, imageName));</span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> ((len = is.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">			os.write(buf, <span class="number">0</span>, len);</span><br><span class="line">		&#125;</span><br><span class="line">		os.close();</span><br><span class="line">		is.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JAVA基本方法主要是利用JAVA中的正则表达式匹配我们我需要的元素，然后再进行其他操作。简单、粗暴。</p>
</blockquote>
<h3 id="Jsoup方式"><a href="#Jsoup方式" class="headerlink" title="Jsoup方式"></a><a href="http://baike.baidu.com/link?url=utl_VUDcVYjjpjXYnY1NKXoTbfToHXosLWBr9qmIjSe0DuYkIUv-zgBbXbJsMPoVjp6YGRMjt_B95v4mRKCdK_">Jsoup</a>方式</h3><blockquote>
<p><code>Jsoup</code> 是一个 Java 的开源HTML解析器，可直接解析某个URL地址、HTML文本内容。同时提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。可以直接使用DOM或者JQuery方法和表达式取出数据。</p>
<p>需要下载JAR包，下载地址：<a href="../../../../images/2017-4-1/jsoup-1.10.2.jar"><em>点我</em></a></p>
<p><code>Jsoup API</code>：详见：<em><a href="http://www.open-open.com/jsoup/">http://www.open-open.com/jsoup/</a></em></p>
</blockquote>
<p><strong>工具类StreamTool</strong> ：将byte对象转化为String对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTool</span> </span>&#123;</span><br><span class="line"><span class="comment">//  将byte对象转化为String对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">inToStringByByte</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ByteArrayOutputStream outStr = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">		<span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">		StringBuilder content = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">while</span> ((len = in.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">			content.append(<span class="keyword">new</span> String(buffer, <span class="number">0</span>, len, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		outStr.close();</span><br><span class="line">		<span class="keyword">return</span> content.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基本实现类Reptile</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reptile</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doGet</span><span class="params">(String urlStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		URL url;</span><br><span class="line">		String html = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			url = <span class="keyword">new</span> URL(urlStr);</span><br><span class="line">			HttpURLConnection connection = (HttpURLConnection) url.openConnection();</span><br><span class="line">			<span class="comment">//伪装爬虫，不然会报403错误</span></span><br><span class="line">			connection.setRequestProperty(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;text/html&quot;</span>); </span><br><span class="line">			connection.setRequestProperty(<span class="string">&quot;Accept-Charset&quot;</span>, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">			connection.setRequestProperty(<span class="string">&quot;Accept-Language&quot;</span>, <span class="string">&quot;en-US,en&quot;</span>);</span><br><span class="line">			connection.setRequestProperty(<span class="string">&quot;User-Agent&quot;</span>,<span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64)</span></span><br><span class="line"><span class="string">              AppleWebKit/537.22 (KHTML, like Gecko) Chrome/25.0.1364.160 Safari/537.22&quot;</span>);</span><br><span class="line">			</span><br><span class="line">			connection.setRequestMethod(<span class="string">&quot;GET&quot;</span>); <span class="comment">// 定义请求方式</span></span><br><span class="line">			connection.setConnectTimeout(<span class="number">5000</span>);</span><br><span class="line">			connection.setDoInput(<span class="keyword">true</span>); <span class="comment">//设置是否向httpUrlConnection输出， 默认情况下是false;</span></span><br><span class="line">			connection.setDoOutput(<span class="keyword">true</span>); <span class="comment">// 设置是否从httpUrlConnection读入，默认情况下是true; </span></span><br><span class="line">			<span class="keyword">if</span> (connection.getResponseCode() == <span class="number">200</span>) &#123; <span class="comment">//连接成功</span></span><br><span class="line">				System.out.println(<span class="string">&quot;已连接，正在解析。。。。。。&quot;</span>);</span><br><span class="line">				InputStream in = connection.getInputStream();</span><br><span class="line">				html = StreamTool.inToStringByByte(in);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(connection.getResponseCode());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;get请求失败&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> html;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      	URL url ;</span><br><span class="line">     	InputStream is = <span class="keyword">null</span>;</span><br><span class="line">		OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">     	String urlStr = <span class="string">&quot;https://www.baidu.com/home/news/data/newspage?nid=7953839918275534&amp;n_type=0&amp;p_from=1&quot;</span>;</span><br><span class="line">      </span><br><span class="line">		String htmlStr = Reptile.doGet(urlStr);</span><br><span class="line">		Document doc = Jsoup.parse(htmlStr); <span class="comment">// 将获取的网页 HTML 源代码转化为 Document对象</span></span><br><span class="line"></span><br><span class="line">		File f = <span class="keyword">new</span> File(<span class="string">&quot;E://imgs&quot;</span>);  <span class="comment">//把文件存在E://imgs</span></span><br><span class="line">		<span class="keyword">if</span> (!f.exists()) &#123;</span><br><span class="line">			f.mkdirs();</span><br><span class="line">		&#125;</span><br><span class="line">		Elements pngs = doc.select(<span class="string">&quot;img[src]&quot;</span>);  <span class="comment">//获取所有图片</span></span><br><span class="line"><span class="comment">//		Elements pngs = doc.select(&quot;img[src$=.png]&quot;);只爬取png图片</span></span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">1</span>;	 <span class="comment">//计数</span></span><br><span class="line">		<span class="keyword">for</span> (Element e : pngs) &#123;</span><br><span class="line">			String src = e.attr(<span class="string">&quot;src&quot;</span>);  <span class="comment">// 获取img中的src路径</span></span><br><span class="line">			String imageName = src.substring(src.lastIndexOf(<span class="string">&quot;/&quot;</span>) + <span class="number">1</span>,</span><br><span class="line">             		src.length());	<span class="comment">// 获取后缀名</span></span><br><span class="line"></span><br><span class="line">			System.out.println(<span class="string">&quot;正在下载第&quot;</span> + i + <span class="string">&quot;张图片：&quot;</span>+ imageName);</span><br><span class="line">			</span><br><span class="line">			URL url = <span class="keyword">new</span> URL(src); 	<span class="comment">// 连接url</span></span><br><span class="line">			URLConnection uri = url.openConnection();</span><br><span class="line">			</span><br><span class="line">			is = uri.getInputStream();	 <span class="comment">// 获取数据流</span></span><br><span class="line">			os = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;E://imgs&quot;</span>,imageName));<span class="comment">// 写入数据流</span></span><br><span class="line">			<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">			<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> ((len = is.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">				os.write(buf, <span class="number">0</span>, len);</span><br><span class="line">			&#125;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">      		os.close();</span><br><span class="line">      		is.close();</span><br><span class="line">		System.out.println(<span class="string">&quot;共有&quot;</span> + (i-<span class="number">1</span>) + <span class="string">&quot;张图片。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这里只做个一个简单的爬虫示例，<strong>通过两种方式的比较后，发现Jsoup更佳。</strong></p>
<p><code>JAVA</code>基本的方式能用正则表达式来匹配所需要的元素，灵活性不高。</p>
<p><code>Jsoup</code>这个强大的工具提供了DOM和JQuery方法，可以直接操作节点，同时也支持正则表达式，更加的灵活、省力，同时选择性、可玩性和扩展性更高。Jsoup更多的方法可以查看<a href="http://www.open-open.com/jsoup/"><em>Jsoup的API</em></a>。</p>
<p>现在已经有很多开源的爬虫的框架供我们选择，比如webmagic、Heritrix等，可以适当选择。</p>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>还有一种更为简单强大的方式，在<code>Linux环境</code>下，利用<code>wget命令</code>只需要一行命令就可以实现以上功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -m -H -nd -l 1 -t 1 -A .jpg,.png,.jpeg,.JPEG -e robots=off -P /opt/download --no-check-certificate https://www.baidu.com/home/news/data/newspage?nid=7953839918275534&amp;n_type=0&amp;p_from=1</span><br></pre></td></tr></table></figure>

<p>在下篇博客写一下Linux的基本命令。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM类加载机制</title>
    <url>/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>之前的博客说了Java虚拟机的运行时数据区域、GC算法、垃圾回收器等知识。距离深入了解还有一段距离，包括虚拟机的类加载机制、性能调优、线程并发等等还都没有涉及到，一直在看周志明的《深入理解Java虚拟机》，越深入去读发现这本书写的真的是经典，解决了自己很多的疑惑。</p>
<p>JVM的类加载机制。虚拟机把描述类的数据从class文件加载到内存中，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。<div align=center><img src="../../../../images/2017/12/ClassLoader/0.png" algin="center"/></p>
</div><span id="more"></span>

<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><p>类被加载到虚拟机内存中开始，到卸载出内存为止。它的生命周期分7个阶段，加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（Unloading）。其中验证、准备、解析三个部分统称为连接（Linking）。</p>
<div align=center><img src="../../../../images/2017/12/ClassLoader/2.png" algin="center"/></div>
## 加载

<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">注意：JVM中的ClassLoader类加载器加载Class发生在此阶段。后面会有描述。</span><br></pre></td></tr></table></figure>

<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：<code>文件格式的验证</code>、<code>元数据的验证</code>、<code>字节码验证</code>和<code>符号引用验证</code>。</p>
<h4 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h4><ol>
<li>主要验证字节流是否符合calss文件格式的规范，如果符合则把字节流加载到方法区中进行存储。</li>
<li>验证文件头、主次版本等等。</li>
</ol>
<h4 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h4><p>主要对字节码描述的信息进行语义分析，保证其描述符合Java语言的要求。</p>
<ol>
<li>类是否有父类。</li>
<li>是否继承了不允许被继承的类（final修饰过的类）。</li>
<li>如果这个类不是抽象类，是否实现其父类或接口中所有要求实现的方法。</li>
<li>类中的字段、方法是否与父类产生矛盾（如：覆盖父类final类型的字段，或者不符合个则的方法）。</li>
</ol>
<h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h4><p>该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。<br>保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。</p>
<h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h4><ol>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>
<li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。</li>
<li>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。</li>
</ol>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。</strong>对于该阶段有以下几点需要注意：</p>
<p>  1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p>
<p>​    2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</p>
<p>假设一个类变量的定义为：public static int value = 3；</p>
<p>那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器<clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p>
<p>下表列出了Java中所有基本数据类型以及reference类型的默认零值：</p>
<div align=center><img src="../../../../images/2017/12/ClassLoader/defaultValue.png"/></div>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意：</span><br><span class="line">只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是在对象实例化的时候初始化分配值的。</span><br></pre></td></tr></table></figure>

<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p><strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</strong></p>
<ol>
<li>类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。</li>
<li>字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。</li>
<li>类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。</li>
<li>接口方法解析：与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行了。</li>
</ol>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是<strong>根据程序员通过程序指定的主观计划去初始化类变量和其他资源</strong>，或者可以从另一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。</p>
<ol>
<li>执行类构造器<clinit>。</li>
<li>初始化静态变量、静态块中的数据等（一个类加载器只会初始化一次）。</li>
<li>子类的<clinit>调用前保证父类的<clinit>被调用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">注意：</span><br><span class="line">&lt;clinit&gt;是线程安全的，执行&lt;clinit&gt;的线程需要先获取锁才能进行初始化操作，保证只有一个线程能执行&lt;clinit&gt;(利用此特性可以实现线程安全的懒汉单例模式)。如果在一个类的&lt;clinit&gt;方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</span><br></pre></td></tr></table></figure>

<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>类被加载进虚拟机是由类加载器（ClassLoader）来完成的。类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类的加载阶段。对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在就Java虚拟机中的唯一性，也就是说，即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。只有在两个类被<strong>同一个类加载器</strong>加载的前提下，比较才有意义。否则，即使两个类来自同一个class文件，被同一个JVM加载，但是加载它们的类加载器不同，则这两个类就不相等。这就相当于两个命名空间中的等价类<code>LoaderA::C</code>和<code>LoaderB::C</code>。</p>
<h2 id="类加载器的种类"><a href="#类加载器的种类" class="headerlink" title="类加载器的种类"></a>类加载器的种类</h2><p>从Java虚拟机的角度来分的话，ClassLoader分为启动类加载器（Bootstrap ClassLoader）和其它的加载器。其中Bootstrap ClassLoader负责加载Java的核心类，该类加载器使用C++语言实现，属于虚拟机自身的一部分。而其它类加载器独立于JVM外部，并且全部继承自抽象类java.lang.ClassLoader。</p>
<p>站在Java开发人员的角度来分的话，ClassLoader分为：</p>
<ul>
<li><p><strong>启动类加载器（Bootstrap ClassLoader）</strong></p>
<p>负责加载<code>JAVA_HOME\lib</code>目录中并且能被虚拟机识别的类库到JVM内存中（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载），如果名称不符合的类库即使放在lib目录中也不会被加载。该类加载器无法被Java程序直接引用。</p>
</li>
<li><p><strong>扩展类加载器（Extension ClassLoader）</strong></p>
<p>该加载器主要是负责加载<code>JDK\jre\lib\ext</code>目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类）。该加载器可以被开发者直接使用。</p>
</li>
<li><p><strong>应用程序类加载器（Application ClassLoader）</strong></p>
<p>该类加载器也称为系统类加载器（System ClassLoader），它负责加载用户类路径（Classpath）上所指定的类库，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，<code>一般情况下这个就是程序中默认的类加载器</code>。</p>
</li>
</ul>
<p>除此之外，还有自定义的类加载器，它们之间的层次关系被称为类加载器的<strong>双亲委派模型</strong>。该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系一般通过<strong>组合（Composition）关系</strong>来实现，而不是通过继承（Inheritance）。</p>
<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><div align=center><img src="../../../../images/2017/12/ClassLoader/3.jpg" algin="center"/>

<div align=center><img src="../../../../images/2020/1-4/java-nio.jpg" algin="center"/></div>

<p>如上图所示的类加载器之间的这种层次关系，就称为<strong>类加载器的双亲委派模型</strong>（Parent Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。</p>
<p>双亲委派模型的工作过程为：<strong>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载</strong>。</p>
<p>   使用这种模型来组织类加载器之间的关系的好处是Java类随着它的类加载器一起<strong>具备了一种带有优先级的层次关系</strong>。例如java.lang.Object类，无论哪个类加载器去加载该类，最终都是由启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。否则的话，如果不使用该模型的话，如果用户自定义一个java.lang.Object类且存放在classpath中，那么系统中将会出现多个Object类，应用程序也会变得很混乱。如果我们自定义一个rt.jar中已有类的同名Java类，会发现JVM可以正常编译，但该类永远无法被加载运行。</p>
<p>   在rt.jar包中的java.lang.ClassLoader类中，我们可以查看类加载实现过程的代码，具体源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)   <span class="keyword">throws</span> ClassNotFoundException&#123;  </span><br><span class="line">    <span class="comment">// First, check if the class has already been loaded  </span></span><br><span class="line">    <span class="comment">//首先检查请求的类是否已经被加载过   </span></span><br><span class="line">    Class c = findLoadedClass(name);  </span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">          	<span class="comment">//委派父类加载器加载  </span></span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//委派启动类加载器加载  </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                c = findBootstrapClassOrNull(name);  </span><br><span class="line">            &#125;  </span><br><span class="line">        <span class="comment">//父类加载器无法完成类加载请求   </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;  </span><br><span class="line">            <span class="comment">// ClassNotFoundException thrown if class not found  </span></span><br><span class="line">            <span class="comment">// from the non-null parent class loader  </span></span><br><span class="line">        &#125;  </span><br><span class="line">       	<span class="comment">//本身类加载器进行类加载</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="comment">// If still not found, then invoke findClass in order  </span></span><br><span class="line">            <span class="comment">// to find the class.  </span></span><br><span class="line">            c = findClass(name);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;  </span><br><span class="line">        resolveClass(c);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> c;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>通过上面代码可以看出，双亲委派模型是通过loadClass()方法来实现的，根据代码以及代码中的注释可以很清楚地了解整个过程其实非常简单：先检查是否已经被加载过，如果没有则调用父加载器的loadClass()方法，如果父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，则先抛出ClassNotFoundException，然后再调用自己的findClass()方法进行加载。</p>
<p>注意，双亲委派模型是Java设计者推荐给开发者的类加载器的实现方式，并不是强制规定的。大多数的类加载器都遵循这个模型，但是JDK中也有较大规模破坏双亲模型的情况，例如线程上下文类加载器（Thread Context ClassLoader）的出现。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与之外，其余所有的动作完全由虚拟机主导和控制。到了初始化才开始执行类中定义的Java程序代码，但这里的执行代码只是个开端，它仅限于<clinit>()方法。类加载过程中主要是将Class文件（准确地讲，应该是类的二进制字节流）加载到虚拟机内存中，真正执行字节码的操作，在加载完成后才真正开始。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM缓存之Caffeine</title>
    <url>/JVM%E7%BC%93%E5%AD%98%E4%B9%8BCaffeine/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><a href="https://www.baeldung.com/java-caching-caffeine">Caffeine</a>是一个高性能、高命中率、低内存占用的的本地缓存。它是Guava的加强版，Caffeine使用<em>Window TinyLfu</em> (最近最少频率使用)算法，提供了<strong>近乎最佳的命中率</strong>。<div align=center><img width="400" height="200" src="../../../../images/2020/5-8/caffeine.png" algin="center"/></div><span id="more"></span></p>
<h1 id="Caffeine-VS-Guava-Cache"><a href="#Caffeine-VS-Guava-Cache" class="headerlink" title="Caffeine VS Guava Cache"></a>Caffeine VS Guava Cache</h1><p>Spring5中将放弃Guava Cache作为默认的缓存机制，而改用Caffeine作为本地缓存组件，Spring作出如此大的改变不是没有原因的。在Caffeine的<a href="https://github.com/ben-manes/caffeine/wiki/Benchmarks">Benchmarks</a>给出了亮眼的数据，对比其他的缓存组件，Caffeine的读写性能都很优异。<div align=center><img src="../../../../images/2020/5-8/caffeine-1.png" algin="center"/></div></p>
<h1 id="Caffeine的使用"><a href="#Caffeine的使用" class="headerlink" title="Caffeine的使用"></a>Caffeine的使用</h1><p>Caffeine和Guava Cache的api有很多相似之处，熟悉Guava Cache的话上手Caffeine就很简单了。</p>
<h2 id="引入Maven坐标"><a href="#引入Maven坐标" class="headerlink" title="引入Maven坐标"></a>引入Maven坐标</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lasted-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="缓存填充策略"><a href="#缓存填充策略" class="headerlink" title="缓存填充策略"></a>缓存填充策略</h2><p>Caffeine提供了三种缓存填充策略：<strong>手动</strong>、<strong>同步</strong>和<strong>异步</strong>加载。</p>
<h3 id="手动加载"><a href="#手动加载" class="headerlink" title="手动加载"></a>手动加载</h3><p>每次通过get key的时候可以指定一个同步的函数，当key不存在时调用函数生成value同时将KV存入Cache中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .expireAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">                .maximumSize(<span class="number">100</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        String key = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="comment">// 使用getIfPresent方法，如果缓存中不存在该值，则此方法将返回null</span></span><br><span class="line">        Object o = cache.getIfPresent(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用put方法手动填充缓存</span></span><br><span class="line">        cache.put(key, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过get方法获取值，如果键在缓存中不存在，则此函数将用于提供备用值，该键将在计算后插入到缓存中</span></span><br><span class="line">        cache.get(key, value -&gt; <span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手动使某些缓存的值无效</span></span><br><span class="line">        cache.invalidate(key);</span><br></pre></td></tr></table></figure>

<p>get方法优于getIfPresent，因为get方法是原子操作，即使多个线程同时要求该值，计算也只进行一次。</p>
<h3 id="同步加载"><a href="#同步加载" class="headerlink" title="同步加载"></a>同步加载</h3><p>构造Cache的时候，build方法中传入CacheLoader的实现类，重写load方法，通过key可以加载value。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 方式一</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">syncLoad</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">       LoadingCache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">               .expireAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">               .maximumSize(<span class="number">100</span>)</span><br><span class="line">               .build(<span class="keyword">new</span> CacheLoader&lt;String, Object&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Nullable</span></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> Object <span class="title">load</span><span class="params">(<span class="meta">@NonNull</span> String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                       <span class="keyword">return</span> key + <span class="string">&quot; world&quot;</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">       <span class="keyword">return</span> cache.get(key);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 方式二</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">syncLoad1</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">       LoadingCache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">               .expireAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">               .maximumSize(<span class="number">100</span>)</span><br><span class="line">               .build(k -&gt; setValue(key).get());</span><br><span class="line">       <span class="keyword">return</span> cache.get(key);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Supplier&lt;Object&gt; <span class="title">setValue</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> () -&gt; key + <span class="string">&quot; world&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3><p>该策略与同步加载策略相同，但是异步执行操作，并返回保存实际值的<strong>CompletableFuture</strong>。可以调用<strong>get</strong>或<strong>getAll</strong>方法调用获取返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方式一</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">asyncLoad</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        AsyncLoadingCache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .expireAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">                .maximumSize(<span class="number">100</span>)</span><br><span class="line">                .buildAsync(<span class="keyword">new</span> AsyncCacheLoader&lt;String, Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">CompletableFuture&lt;Object&gt; <span class="title">asyncLoad</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> Executor executor)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; key + <span class="string">&quot; world&quot;</span>, executor);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方式二</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">asyncLoad1</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        AsyncLoadingCache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .expireAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">                .maximumSize(<span class="number">100</span>)</span><br><span class="line">                .buildAsync(k -&gt; setValue(key).get());</span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;Object&gt; <span class="title">setValue</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; key + <span class="string">&quot; world&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="驱逐策略"><a href="#驱逐策略" class="headerlink" title="驱逐策略"></a>驱逐策略</h2><p>Caffeine提供三种数据驱逐策略：<strong>基于大小驱逐、基于时间驱逐、基于引用驱逐</strong>。</p>
<h3 id="基于大小-Size-Based-的驱逐策略"><a href="#基于大小-Size-Based-的驱逐策略" class="headerlink" title="基于大小(Size-Based)的驱逐策略"></a>基于大小(Size-Based)的驱逐策略</h3><p>基于大小的驱逐策略有两种方式：一种是基于缓存数量，一种是基于权重。<strong>maximumSize</strong>与<strong>maximumWeight</strong>不可同时使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sizeBasedEviction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据缓存的数量进行驱逐</span></span><br><span class="line">        LoadingCache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .maximumSize(<span class="number">10000</span>)</span><br><span class="line">                .build(key -&gt; function(key));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据缓存的权重来进行驱逐（权重只是用于确定缓存大小，不会用于决定该缓存是否被驱逐）</span></span><br><span class="line">        LoadingCache&lt;String, Object&gt; cache1 = Caffeine.newBuilder()</span><br><span class="line">                .maximumWeight(<span class="number">10000</span>)</span><br><span class="line">                .weigher(key -&gt; function1(key))</span><br><span class="line">                .build(key -&gt; function(key));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于时间-Time-Based-的驱逐策略"><a href="#基于时间-Time-Based-的驱逐策略" class="headerlink" title="基于时间(Time-Based)的驱逐策略"></a>基于时间(Time-Based)的驱逐策略</h3><p>基于时间的驱逐策略有三种类型：</p>
<ol>
<li>**expireAfterAccess(long, TimeUnit)**：在最后一次访问或者写入后开始计时，在指定的时间后过期。假如一直有请求访问该key，那么这个缓存将一直不会过期。</li>
<li><strong>expireAfterWrite(long, TimeUnit)</strong>: 在最后一次写入缓存后开始计时，在指定的时间后过期。</li>
<li><strong>expireAfter(Expiry)</strong>: 自定义策略，过期时间由Expiry实现独自计算。</li>
</ol>
<p>缓存的删除策略使用的是惰性删除和定时删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeBasedEviction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基于固定的到期策略进行退出</span></span><br><span class="line">        LoadingCache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .expireAfterAccess(<span class="number">5</span>, TimeUnit.MINUTES)</span><br><span class="line">                .build(key -&gt; function(key));</span><br><span class="line">        LoadingCache&lt;String, Object&gt; cache1 = Caffeine.newBuilder()</span><br><span class="line">                .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">                .build(key -&gt; function(key));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于不同的到期策略进行退出</span></span><br><span class="line">        LoadingCache&lt;String, Object&gt; cache2 = Caffeine.newBuilder()</span><br><span class="line">                .expireAfter(<span class="keyword">new</span> Expiry&lt;String, Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expireAfterCreate</span><span class="params">(String key, Object value, <span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> TimeUnit.SECONDS.toNanos(seconds);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expireAfterUpdate</span><span class="params">(<span class="meta">@Nonnull</span> String s, <span class="meta">@Nonnull</span> Object o, <span class="keyword">long</span> l, <span class="keyword">long</span> l1)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expireAfterRead</span><span class="params">(<span class="meta">@Nonnull</span> String s, <span class="meta">@Nonnull</span> Object o, <span class="keyword">long</span> l, <span class="keyword">long</span> l1)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).build(key -&gt; function(key));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于引用-Reference-Based-的驱逐"><a href="#基于引用-Reference-Based-的驱逐" class="headerlink" title="基于引用(Reference-Based)的驱逐"></a>基于引用(Reference-Based)的驱逐</h3><p>Java中四种引用类型：</p>
<table>
<thead>
<tr>
<th>引用类型</th>
<th>被垃圾回收时间</th>
<th>用途</th>
<th>生存时间</th>
</tr>
</thead>
<tbody><tr>
<td>强引用 Strong Reference</td>
<td>从来不会</td>
<td>对象的一般状态</td>
<td>JVM停止运行时终止</td>
</tr>
<tr>
<td>软引用 Soft Reference</td>
<td>在内存不足时</td>
<td>对象缓存</td>
<td>内存不足时终止</td>
</tr>
<tr>
<td>弱引用 Weak Reference</td>
<td>在垃圾回收时</td>
<td>对象缓存</td>
<td>gc运行后终止</td>
</tr>
<tr>
<td>虚引用 Phantom Reference</td>
<td>从来不会</td>
<td>可以用虚引用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知</td>
<td>JVM停止运行时终止</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">referenceBasedEviction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当key和value都没有弱引用时驱逐缓存</span></span><br><span class="line">        LoadingCache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .weakKeys()</span><br><span class="line">                .weakValues()</span><br><span class="line">                .build(key -&gt; function(key));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当垃圾收集器需要释放内存时驱逐</span></span><br><span class="line">        LoadingCache&lt;String, Object&gt; cache1 = Caffeine.newBuilder()</span><br><span class="line">                .softValues()</span><br><span class="line">                .build(key -&gt; function(key));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li><p><strong>AsyncLoadingCache不支持弱引用和软引用。</strong></p>
</li>
<li><p><strong>Caffeine.weakValues()和Caffeine.softValues()不可以一起使用。</strong></p>
</li>
</ol>
<h2 id="移除事件监听"><a href="#移除事件监听" class="headerlink" title="移除事件监听"></a>移除事件监听</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removalListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Cache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .removalListener((String key, Object value, RemovalCause cause) -&gt;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;Key %s was removed (%s)%n&quot;</span>, key, cause))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h2><p>可以将缓存配置为在自定义的时间段后自动刷新数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Cache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .maximumSize(<span class="number">10000</span>)</span><br><span class="line">                .refreshAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>expireAfter</strong>和<strong>refreshAfter</strong>之间的区别：</p>
<ul>
<li><strong>expireAfter</strong>：当请求过期的数据时，请求将会被阻塞，直到build <em>Function</em>将计算出新值为止。</li>
<li><strong>refreshAfter</strong>：当数据符合刷新条件，则缓存将返回一个旧值，并<strong>异步重新加载该值</strong>。</li>
</ul>
<h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stats</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Cache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .maximumSize(<span class="number">10000</span>)</span><br><span class="line">                .recordStats()</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 缓存命中率</span></span><br><span class="line">        cache.stats().hitRate();</span><br><span class="line">        <span class="comment">// 回收数量</span></span><br><span class="line">        cache.stats().evictionCount();</span><br><span class="line">        <span class="comment">// 加载新值的平均时间</span></span><br><span class="line">        cache.stats().averageLoadPenalty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过使用**Caffeine.recordStats()<strong>可以转化成一个统计的集合. 通过</strong>Cache.stats()**返回一个CacheStats。CacheStats提供以下统计方法：</p>
<ul>
<li><strong>hitRate</strong>: 返回缓存命中率</li>
<li><strong>evictionCount</strong>: 缓存回收数量</li>
<li><strong>averageLoadPenalty</strong>: 加载新值的平均时间</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Java String intern方法</title>
    <url>/Java-String-intern%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>String类我们经常使用，但是它的intern()方法之前还真的不太了解，通过谷歌百度一番之后终于搞明白了。</p>
<p>intern()方法设计的初衷，就是重用String对象，以节省内存消耗。<div align=center><img width="700" height="200" src="../../../../images/2017-12-7/String_intern/creating-java-strings.jpg" algin="center"/></p>
</div><span id="more"></span>

<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;rainbow&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;horse&quot;</span>);</span><br><span class="line">System.out.println(str1.intern() == str1);</span><br><span class="line">System.out.println(str1 == <span class="string">&quot;rainbowhorse&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在<strong>JDK1.7</strong>下输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>再将上面的例子加上一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str2 = <span class="string">&quot;rainbowhorse&quot;</span>;	<span class="comment">//新加的一行代码，其余不变  </span></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;rainbow&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;horse&quot;</span>);</span><br><span class="line">System.out.println(str1.intern() == str1);</span><br><span class="line">System.out.println(str1 == <span class="string">&quot;rainbowhorse&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>再运行，结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p>在JVM运行时数据区中的方法区有一个常量池，但是发现在JDK1.6以后常量池被放置在了堆空间，因此常量池位置的不同影响到了String的intern()方法的表现。</p>
<h1 id="为什么使用intern-方法"><a href="#为什么使用intern-方法" class="headerlink" title="为什么使用intern()方法"></a>为什么使用intern()方法</h1><p>就如引言所说的，<strong>intern()方法设计的初衷，就是重用String对象，以节省内存消耗</strong>。下面通过例子来说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">100000</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> String[] arr = <span class="keyword">new</span> String[MAX];</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 为长度为10的Integer数组随机赋值</span></span><br><span class="line">		Integer[] sample = <span class="keyword">new</span> Integer[<span class="number">10</span>];</span><br><span class="line">		Random random = <span class="keyword">new</span> Random(<span class="number">1000</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sample.length; i++) &#123;</span><br><span class="line">			sample[i] = random.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 记录程序开始时间</span></span><br><span class="line">		<span class="keyword">long</span> t = System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 使用/不使用intern方法为10万个String赋值，值来自于Integer数组的10个数</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; i++) &#123;</span><br><span class="line">			arr[i] = <span class="keyword">new</span> String(String.valueOf(sample[i % sample.length]));</span><br><span class="line">			<span class="comment">// arr[i] = new String(String.valueOf(sample[i % sample.length])).intern();</span></span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println((System.currentTimeMillis() - t) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">		System.gc();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个主要是为了证明<code>使用intern()比不使用intern()消耗的内存更少</code>。</p>
<p>先定义一个长度为10的Integer数组，并随机为其赋值，在通过for循环为长度为10万的String对象依次赋值，这些值都来自于Integer数组。两种情况分别运行，可通过Window —&gt; Preferences –&gt; Java –&gt; Installed JREs设置JVM启动参数为-agentlib:hprof=heap=dump,format=b，将程序运行完后的hprof置于工程目录下。再通过<a href="http://download.eclipse.org/mat/">MAT</a>插件查看该hprof文件。</p>
<p>不使用intern()方法</p>
<div align=center><img width="700" height="200" src="../../../../images/2017-12-7/String_intern/no-intern.png" algin="center"/>

</div>

<p>使用intern()方法</p>
<div align=center><img width="700" height="200" src="../../../../images/2017-12-7/String_intern/use-intern.png" algin="center"/>

</div>

<p>从运行结果来看，不使用intern()的情况下，程序生成了101762个String对象，而使用了intern()方法时，程序仅生成了1772个String对象。证明了intern()节省内存的结论。</p>
<p>但是会发现使用了intern()方法后程序运行时间有所增加。这是因为程序中每次都是用了new String后又进行intern()操作的耗时时间，但是不使用intern()占用内存空间导致GC的时间是要远远大于这点时间的。 </p>
<h1 id="深入理解intern-方法"><a href="#深入理解intern-方法" class="headerlink" title="深入理解intern()方法"></a>深入理解intern()方法</h1><p><strong>JDK1.7后，常量池被放入到堆空间中，这导致intern()函数的功能不同。这点很重要。</strong></p>
<p>看看下面代码，这个例子是网上流传较广的一个例子，我也是照抄过来的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);  </span><br><span class="line">s.intern();  </span><br><span class="line">String s2 = <span class="string">&quot;1&quot;</span>;  </span><br><span class="line">System.out.println(s == s2);  </span><br><span class="line">  </span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);  </span><br><span class="line">s3.intern();  </span><br><span class="line">String s4 = <span class="string">&quot;11&quot;</span>;  </span><br><span class="line">System.out.println(s3 == s4);  </span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JDK1<span class="number">.6</span>以及以下：<span class="keyword">false</span> <span class="keyword">false</span>  </span><br><span class="line">JDK1<span class="number">.7</span>以及以上：<span class="keyword">false</span> <span class="keyword">true</span>  </span><br></pre></td></tr></table></figure>

<p>再分别调整上面代码2、3行，7、8行的顺序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);  </span><br><span class="line">String s2 = <span class="string">&quot;1&quot;</span>;  </span><br><span class="line">s.intern();  </span><br><span class="line">System.out.println(s == s2);  </span><br><span class="line">  </span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);  </span><br><span class="line">String s4 = <span class="string">&quot;11&quot;</span>;  </span><br><span class="line">s3.intern();  </span><br><span class="line">System.out.println(s3 == s4);  </span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JDK1<span class="number">.6</span>以及以下：<span class="keyword">false</span> <span class="keyword">false</span>  </span><br><span class="line">JDK1<span class="number">.7</span>以及以上：<span class="keyword">false</span> <span class="keyword">false</span>  </span><br></pre></td></tr></table></figure>

<h2 id="JDK1-6"><a href="#JDK1-6" class="headerlink" title="JDK1.6"></a><strong>JDK1.6</strong></h2><div align=center><img width="700" height="200" src="../../../../images/2017-12-04/JVM/jdk1.6.png" algin="center"/>

</div>

<p>在JDK1.6中所有的输出结果都是 false，因为JDK1.6以及以前版本中，常量池是放在 Perm 区（属于方法区）中的，Perm区是和堆区完全分开的。</p>
<p>使用<strong>引号声明的字符串都是会直接在字符串常量池中生成</strong>的，而<strong>new 出来的String对象是放在堆空间中</strong>的。所以两者的内存地址肯定是不相同的，即使调用了intern()方法也是不影响的。</p>
<p>intern()方法在JDK1.6中的作用是：比如String s = new String(“rainbowhorse”)，再调用s.intern()，此时返回值还是字符串”rainbowhorse”，表面上看起来好像这个方法没什么用处。但实际上，在JDK1.6中它做了个小动作：检查字符串池里是否存在”rainbowhorse”这么一个字符串，如果存在，就返回池里的字符串；如果不存在，该方法把”rainbowhorse”添加到字符串池中，然后再返回它的引用。</p>
<h2 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h2><h3 id="例一分析"><a href="#例一分析" class="headerlink" title="例一分析"></a>例一分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);  </span><br><span class="line">s.intern();  </span><br><span class="line">String s2 = <span class="string">&quot;1&quot;</span>;  </span><br><span class="line">System.out.println(s == s2);  </span><br><span class="line">  </span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);  </span><br><span class="line">s3.intern();  </span><br><span class="line">String s4 = <span class="string">&quot;11&quot;</span>;  </span><br><span class="line">System.out.println(s3 == s4); </span><br></pre></td></tr></table></figure>

<div align=center><img width="700" height="200" src="../../../../images/2017-12-04/JVM/jdk1.7.png" algin="center"/>

</div>

<p>String s = newString(“1”)，<strong>生成了常量池中的“1” 和堆空间中的字符串对象</strong>。</p>
<p>s.intern()，这一行的作用是s对象去常量池中寻找后发现”1”<strong>已经存在于常量池中了</strong>。</p>
<p>String s2 = “1”，这行代码是生成一个s2的引用<strong>指向常量池中的“1”对象</strong>。</p>
<p>结果就是 s 和 s2 的引用地址明显不同。因此返回了false。</p>
<p>String s3 = new String(“1”) + newString(“1”)，这行代码<strong>在字符串常量池中生成“1” ，并在堆空间中生成s3引用指向的对象（内容为”11”）</strong>。注意<strong>此时常量池中是没有 “11”对象</strong>的。</p>
<p>s3.intern()，这一行代码，是将 s3中的<strong>“11”字符串放入 String 常量池中</strong>，此时常量池中不存在“11”字符串，JDK1.6的做法是直接在常量池中生成一个 “11” 的对象。</p>
<p><strong>但是在JDK1.7中，常量池中不需要再存储一份对象了，可以直接存储堆中的引用</strong>。这份引用直接指向 s3 引用的对象，也就是说s3.intern() ==s3会返回true。</p>
<p>String s4 = “11”， 这一行代码会<strong>直接去常量池中创建</strong>，但是发现已经有这个对象了，此时也就是<strong>指向 s3 引用对象的一个引用</strong>。因此s3 == s4返回了true。</p>
<h3 id="例二分析"><a href="#例二分析" class="headerlink" title="例二分析"></a>例二分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);  </span><br><span class="line">String s2 = <span class="string">&quot;1&quot;</span>;  </span><br><span class="line">s.intern();  </span><br><span class="line">System.out.println(s == s2);  </span><br><span class="line">  </span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);  </span><br><span class="line">String s4 = <span class="string">&quot;11&quot;</span>;  </span><br><span class="line">s3.intern();  </span><br><span class="line">System.out.println(s3 == s4); </span><br></pre></td></tr></table></figure>

<div align=center><img width="700" height="200" src="../../../../images/2017-12-7/String_intern/jdk1.7-2.png" algin="center"/>

</div>

<p>String s = newString(“1”)，生成了<strong>常量池中的“1” 和堆空间中的字符串对象</strong>。</p>
<p>String s2 = “1”，这行代码是生成一个s2的<strong>引用指向常量池中的“1”对象，但是发现已经存在了，那么就直接指向了它</strong>。</p>
<p>s.intern()，这一行在这里就没什么实际作用了。因为”1”已经存在了。</p>
<p>结果就是 s 和 s2 的引用地址明显不同。因此返回了false。</p>
<p>String s3 = new String(“1”) + newString(“1”)，这行代码<strong>在字符串常量池中生成“1” ，并在堆空间中生成s3引用指向的对象（内容为”11”）</strong>。注意此时常量池中是没有 “11”对象的。</p>
<p>String s4 = “11”， 这一行代码会**直接去生成常量池中的”11”**。</p>
<p>s3.intern()，这一行在这里就没什么实际作用了。因为”11”已经存在了。</p>
<p>结果就是 s3 和 s4 的引用地址明显不同。因此返回了false。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从JDK 1.7后，HotSpot 将常量池从永久代移到了元空间，正因为如此，JDK 1.7 后的intern方法在实现上发生了比较大的改变，JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，<strong>如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用</strong>。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java和Docker限制的那些事儿</title>
    <url>/Java%E5%92%8CDocker%E9%99%90%E5%88%B6%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Java和Docker不是天然的朋友。 Docker可以设置内存和CPU限制，而Java不能自动检测到。使用Java的<code>Xmx</code>标识（繁琐/重复）或新的实验性JVM标识，可以解决这个问题。自己也是在开发配置上踩了个坑。<div align=center><img width="420" height="220" src="../../../../images/2019/4-6/java_docker.jpg" algin="center"/></div></p>
<h1 id="采坑记录"><a href="#采坑记录" class="headerlink" title="采坑记录"></a>采坑记录</h1><p>在开发中使用了线程池，根据<a href="http://rainbowhorse.site/%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B-VS-IO%E5%AF%86%E9%9B%86%E5%9E%8B/">计算密集型 VS IO密集型</a>设置线程数量，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadFactory threadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;service_record&quot;</span>).build();</span><br><span class="line">ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">4</span>, <span class="number">2</span> * Runtime.getRuntime().availableProcessors(),</span><br><span class="line">            <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">1024</span>), threadFactory,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>过不久，发现启动时提示这块有异常。我们的服务一部分部署在虚拟机里面，一部分部署在k8s中。Docker中可以设置CPU个数为小数，<strong>当设置CPU个数小于两个时，maximumPoolSize就会小于corePoolSize。会抛出IllegalArgumentException。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">                <span class="keyword">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="虚拟化中的不匹配"><a href="#虚拟化中的不匹配" class="headerlink" title="虚拟化中的不匹配"></a>虚拟化中的不匹配</h1><p>Java和Docker的结合并不是完美匹配的，最初的时候离完美匹配有相当大的距离。Docker可以把你的程序、设置、特定的JDK、Linux设置和应用服务器，还有其他工具打包在一起，当做一个东西。站在DevOps/Cloud的角度来看，这样一个完整的容器有着更高层次的封装。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>现在很多产品级应用都在用Java8或是更早的版本，Java 8（update 131之前的版本）和Docker无法很好地一起工作。问题是在机器上，<strong>JVM的可用内存和CPU数量并不是Docker允许你使用的可用内存和CPU数量</strong>。</p>
<p>比如，如果我们限制Docker容器只能使用100MB内存，但是旧版本的Java并不能识别这个限制。Java看不到这个限制，JVM会要求更多内存，而且远超这个限制。如果使用太多内存，Docker将采取行动并杀死容器内的进程！JAVA进程被干掉了，很明显，这并不是我们想要的。</p>
<p>为了解决这个问题，需要给Java指定一个最大内存限制。在旧版本的Java(8u131之前)，需要在容器中通过设置<code>-Xmx</code>来限制堆大小。这感觉不太对，我们可不想定义这些限制两次，也不太想在容器中来定义。</p>
<p>现在有了更好的方式来解决这个问题。从Java 9之后(8u131+)，JVM增加了如下标志:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap</span><br></pre></td></tr></table></figure>

<p>这些标志强制JVM检查Linux的<code>cgroup</code>配置，Docker是通过<code>cgroup</code>来实现最大内存设置的。如果应用到达了Docker设置的限制（比如500MB），JVM是可以看到这个限制的。JVM将会尝试GC操作。如果仍然超过内存限制，JVM就会做它该做的事情，抛出<code>OutOfMemoryException</code>。也就是说，JVM能够看到Docker的这些设置。</p>
<p>从Java 10之后这些体验标志位是默认开启的，也可以使用<code>-XX:+UseContainerSupport</code>来控制开启或关闭。</p>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>k8s可对CPU资源进行严格控制：</p>
<ul>
<li><code>正实数</code>，代表分配几颗CPU，可以是小数点，比如<code>0.5</code>代表0.5颗CPU，意思是一颗CPU的一半时间。<code>2</code>代表两颗CPU。</li>
<li><code>正整数m</code>，也代表<code>1000m=1</code>，所以<code>500m</code>等价于<code>0.5</code>。</li>
</ul>
<p>JVM将查看硬件并检测CPU的数量。它会优化runtime以使用这些CPUs。但是同样的情况，这里还有另一个不匹配，Docker可能不允许使用所有这些CPUs。这在Java8或Java9中并没有修复，但是在Java10中得到了解决。</p>
<p>从Java 10开始，可用的CPUs的计算将采用以不同的方式（默认情况下）解决此问题（同样是通过<code>UseContainerSupport</code>控制）。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>简言之：注意资源限制的不匹配。测试内存设置和JVM标志，不要假设任何东西。</p>
<p>如果Docker容器中运行Java，确保设置了Docker内存限制和在JVM中也做了限制，或者JVM能够理解这些限制。</p>
<p>如果无法升级Java版本，需要使用<code>-Xmx</code>设置限制。</p>
<p>对于Java 8和Java 9，可以更新到最新版本并使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX：+UnlockExperimentalVMOptions -XX：+UseCGroupMemoryLimitForHeap</span><br></pre></td></tr></table></figure>

<p>对于OpenJ9(强烈建议使用，可以在生产环境中有效减少内存占用量)。</p>
<p>附上自己生产环境k8s中的配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root          1      0  1 May29 ?        00:12:20 /usr/lib/jvm/zulu-8/bin/java -Djava.util.logging.config.file=/opt/tomcat/co</span><br><span class="line">nf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -server -XX:+AggressiveOpts -XX:+UseG</span><br><span class="line">1GC -XX:ParallelGCThreads=2 -XX:MaxGCPauseMillis=200 -Djava.security.egd=file:/dev/urandom -XX:+UnlockExperimentalVMOptions -</span><br><span class="line">XX:+UseCGroupMemoryLimitForHeap -XX:MaxRAMFraction=1 -Dfile.encoding=UTF-8 -Dsun.jnu.encoding=UTF-8 -XX:-CICompilerCountPerCP</span><br><span class="line">U -XX:CICompilerCount=4 -Djava.util.concurrent.ForkJoinPool.common.parallelism=8 -javaagent:/opt/tomcat/lib/jmx_prometheus_ja</span><br><span class="line">vaagent-0.11.0.jar=8090:/opt/tomcat/conf/tomcat_jmx_export.yml -Xmx1228m -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.ha</span><br><span class="line">ndler.pkgs=org.apache.catalina.webresources -classpath /opt/tomcat/bin/bootstrap.jar:/opt/tomcat/bin/tomcat-juli.jar -Dcatalina.base=/op</span><br><span class="line">t/tomcat -Dcatalina.home=/opt/tomcat -Djava.io.tmpdir=/opt/tomcat/temp org.apache.catalina.startup.Bootstrap start</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://dockone.io/article/5932">Java和Docker限制的那些事儿</a></p>
<p><a href="https://blog.docker.com/2018/04/improved-docker-container-integration-with-java-10/">Improved Docker Container Integration with Java 10</a></p>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript Number类型长度溢出</title>
    <url>/Javascript-Number%E7%B1%BB%E5%9E%8B%E9%95%BF%E5%BA%A6%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>项目中遇到一个问题，由于后台数据库表ID使用分布式唯一算法生成的<code>Long</code>类型(19位数字)，导致转成json传至前端js使用时报错，因为js的数字类型最大只能表示15位数字长度【<a href="https://www.w3school.com.cn/js/js_obj_number.asp"><em>JavaScript Number 对象</em></a>】。</p>
<p>解决方案：使用Spring自定义Json序列化方式，将过长的Long类型转成String类型。</p>
<div align=center><img src="../../../../images/2018-8/bug.jpg" algin="center"/></div>

<h1 id="默认序列化配置"><a href="#默认序列化配置" class="headerlink" title="默认序列化配置"></a>默认序列化配置</h1><p>默认序列化方式会将Long类型不做转换，直接传递给前端。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;utf8charset&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;writeAcceptCharset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;objectMapper&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serializationInclusion&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">value</span> <span class="attr">type</span>=<span class="string">&quot;com.fasterxml.jackson.annotation.JsonInclude.Include&quot;</span>&gt;</span>NON_NULL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="自定义序列化方式"><a href="#自定义序列化方式" class="headerlink" title="自定义序列化方式"></a>自定义序列化方式</h1><p>现在需要将Long类型数字达到一定长度才转为String类型传递给前端。实现方式有两种：</p>
<h2 id="局部配置某个字段序列化"><a href="#局部配置某个字段序列化" class="headerlink" title="局部配置某个字段序列化"></a>局部配置某个字段序列化</h2><p>实现抽象接口<code>JsonSerializer</code>自定义序列化类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomLongConverter</span> <span class="keyword">extends</span> <span class="title">JsonSerializer</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超过多少位转换为Long类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD_LENGTH = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Long value, JsonGenerator gen, SerializerProvider serializers)</span> <span class="keyword">throws</span> IOException, JsonProcessingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value.toString().length() &gt; THRESHOLD_LENGTH) &#123;</span><br><span class="line">            gen.writeString(value.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            gen.writeNumber(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用<code>@JsonSerialize(using = CustomLongConverter.class)</code>注解到指定字段上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonSerialize(using = CustomLongConverter.class)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure>

<h2 id="全局配置序注册自定义的序列化类"><a href="#全局配置序注册自定义的序列化类" class="headerlink" title="全局配置序注册自定义的序列化类"></a>全局配置序注册自定义的序列化类</h2><h3 id="自定义Long类型序列化"><a href="#自定义Long类型序列化" class="headerlink" title="自定义Long类型序列化"></a>自定义Long类型序列化</h3><p>继承自<code>StdSerializer</code>类的一个自定义序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomLongConverter</span> <span class="keyword">extends</span> <span class="title">StdSerializer</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超过多少位转换为Long类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD_LENGTH = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4532126689403959662L</span>;</span><br><span class="line"></span><br><span class="line">    CustomLongConverter() &#123;</span><br><span class="line">        <span class="keyword">super</span>(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Long value, JsonGenerator gen, SerializerProvider serializers)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value.toString().length() &gt;= THRESHOLD_LENGTH) &#123;</span><br><span class="line">            gen.writeString(value.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            gen.writeNumber(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注册到<code>ObjectMapper</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectMapperConverter</span> <span class="keyword">extends</span> <span class="title">ObjectMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5383113523976711806L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectMapperConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">// 不包含为空的字段</span></span><br><span class="line">        setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line">        <span class="comment">// 不包含空字符串字段</span></span><br><span class="line">        setSerializationInclusion(JsonInclude.Include.NON_EMPTY);</span><br><span class="line"></span><br><span class="line">        SimpleModule simpleModule = <span class="keyword">new</span> SimpleModule();</span><br><span class="line">        simpleModule.addSerializer(Long.class, <span class="keyword">new</span> CustomLongConverter());</span><br><span class="line">        simpleModule.addSerializer(Long.TYPE, <span class="keyword">new</span> CustomLongConverter());</span><br><span class="line">        registerModule(simpleModule);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="xml中配置注册方式"><a href="#xml中配置注册方式" class="headerlink" title="xml中配置注册方式"></a>xml中配置注册方式</h3><p>SpringMVC配置中需要指定为自定义序列化</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;utf8charset&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;writeAcceptCharset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;objectMapper&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.rainbowhorse.consult.web.util.ObjectMapperConverter&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java备份和还原MySQL数据库</title>
    <url>/Java%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>​    在项目中经常会用到Java程序备份和还原MySQL数据库的内容，都是大同小异，但程序也会出现各种各样的问题（运行时异常，乱码等）。实现上都是用Runtime执行MySQL的命令行工具，然后读写IO流数据；也有可能是由于使用Java的Runtime来实现备份还原功能，而由于大家的运行时环境有差异才导致代码运行不成功。在这里记录一下自己使用的工具和方法。<div align=center><img width="700" height="300" src="../../../../images/2017-9-21/MySQLbackUpAndRestore/mysql-index.png" algin="center"/></p>
</div><span id="more"></span>

<h1 id="使用MySQL自带工具"><a href="#使用MySQL自带工具" class="headerlink" title="使用MySQL自带工具"></a>使用MySQL自带工具</h1><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>备份使用MySQL的<code>mysqldump</code>命令来实现，示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(MySQLDatabaseBackupAndRestore.class);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Java代码实现MySQL数据库导出</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> hostIP       MySQL数据库所在服务器地址IP</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> userName     进入数据库所需要的用户名</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> password     进入数据库所需要的密码</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> savePath     数据库导出文件保存路径</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> fileName     数据库导出文件文件名</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> databaseName 要导出的数据库名</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 返回true表示导出成功，否则返回false。</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> maxu</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">backUpDatabase</span><span class="params">(String hostIP, String userName, String password, String databaseName, String savePath, String fileName)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     File saveFile = <span class="keyword">new</span> File(savePath);</span><br><span class="line">     <span class="keyword">if</span> (!saveFile.exists()) &#123;<span class="comment">// 如果目录不存在</span></span><br><span class="line">         saveFile.mkdirs();<span class="comment">// 创建文件夹</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (!savePath.endsWith(File.separator)) &#123;</span><br><span class="line">         savePath = savePath + File.separator;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     PrintWriter printWriter = <span class="keyword">null</span>;</span><br><span class="line">     BufferedReader bufferedReader = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         printWriter = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(savePath + fileName), <span class="string">&quot;utf8&quot;</span>));</span><br><span class="line">         Process process = Runtime.getRuntime().exec(<span class="string">&quot; D:\\DevTools\\MySQL\\MySQL5.7\\bin\\mysqldump.exe -h&quot;</span> + hostIP + <span class="string">&quot; -u&quot;</span> + userName + <span class="string">&quot; -p&quot;</span> + password + <span class="string">&quot; --set-charset=UTF8 &quot;</span> + databaseName);</span><br><span class="line">         InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(process.getInputStream(), <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">         bufferedReader = <span class="keyword">new</span> BufferedReader(inputStreamReader);</span><br><span class="line">         String line;</span><br><span class="line">         <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">             printWriter.println(line);</span><br><span class="line">         &#125;</span><br><span class="line">         printWriter.flush();</span><br><span class="line">         <span class="keyword">if</span> (process.waitFor() == <span class="number">0</span>) &#123;<span class="comment">//0 表示线程正常终止。</span></span><br><span class="line">             logger.info(<span class="string">&quot;数据库已备份到——&gt;&gt;&quot;</span> + savePath);</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (bufferedReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 bufferedReader.close();</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (printWriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 printWriter.close();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(MySQLDatabaseBackupAndRestore.class);  </span><br><span class="line">	</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java代码实现MySQL数据库还原</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hostIP       MySQL数据库所在服务器地址IP</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userName     进入数据库所需要的用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password     进入数据库所需要的密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path         需要还原数据库文件的路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName     需要还原数据库文件的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> databaseName 需要还原的数据库名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回true表示还原成功，否则返回false。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">restoreDatabase</span><span class="params">(String hostIP, String userName, String password, String databaseName, String path, String fileName)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        PrintStream ps = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用mysql的cmd:cmd命令在后台执行，没有命令窗口出现或者一闪而过的情况</span></span><br><span class="line">            Process process = Runtime.getRuntime().exec(<span class="string">&quot;cmd /c start /b  D:\\DevTools\\MySQL\\MySQL5.7\\bin\\mysql -h&quot;</span> + hostIP + <span class="string">&quot; -u&quot;</span> + userName + <span class="string">&quot; -p&quot;</span> + password + <span class="string">&quot; --default-character-set=utf8 &quot;</span> + databaseName);</span><br><span class="line">            out = process.getOutputStream();<span class="comment">//控制台的输入信息作为输出流</span></span><br><span class="line">            StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(path + fileName), <span class="string">&quot;utf8&quot;</span>));</span><br><span class="line">            String outStr;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(line + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            outStr = sb.toString();</span><br><span class="line"></span><br><span class="line">            ps = <span class="keyword">new</span> PrintStream(out, <span class="keyword">true</span>, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">            ps.write(outStr.getBytes());</span><br><span class="line"><span class="comment">//            OutputStreamWriter writer = new OutputStreamWriter(out, &quot;utf8&quot;);</span></span><br><span class="line"><span class="comment">//            writer.write(outStr);</span></span><br><span class="line">            <span class="comment">// 注：这里如果用缓冲方式写入文件的话，会导致中文乱码，用flush()方法则可以避免</span></span><br><span class="line"><span class="comment">//            writer.flush();</span></span><br><span class="line"><span class="comment">//            writer.close();</span></span><br><span class="line">            <span class="keyword">if</span> (process.waitFor() == <span class="number">0</span>) &#123;   <span class="comment">//0 表示线程正常终止。</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ps.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (out != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据库备份</span></span><br><span class="line">        <span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">            if (backUpDatabase(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;, &quot;taotao&quot;, &quot;D:/&quot;, &quot;taotao.sql&quot;)) &#123;</span></span><br><span class="line"><span class="comment">                logger.info(&quot;数据库成功备份！！&quot;);</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                logger.info(&quot;数据库备份失败！！&quot;);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="comment">//数据库恢复</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (restoreDatabase(<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;taotao&quot;</span>, <span class="string">&quot;D:/&quot;</span>, <span class="string">&quot;taotao.sql&quot;</span>)) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;数据库恢复成功！！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;数据库恢复失败！！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码下载点击：<a href="../../../../images/2017-9-21/MySQLbackUpAndRestore/MySQLDatabaseBackupAndRestore.java"><em>下载</em></a></p>
<h1 id="Windows下bat命令"><a href="#Windows下bat命令" class="headerlink" title="Windows下bat命令"></a>Windows下bat命令</h1><p>工作环境 Windows Server 2003 ，<code>MySQL</code>安装目录 D:\DevTools\MySQL ,</p>
<p><code>WinRAR</code> 安装目录 C:\Program Files\WinRAR\WinRAR.exe </p>
<p>备份数据存储的路径为 D:\数据备份，好了下面开始写<code>DOS批处理命令</code>了。代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">color <span class="number">9</span></span><br><span class="line">rem ---------------------数据库备份开始-----------------------</span><br><span class="line"><span class="meta">@echo off</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> <span class="string">&quot;Ymd=%DATE:~0,4%%DATE:~5,2%%DATE:~8,2%%TIME:~0,2%%TIME:~3,2%%TIME:~6,2%&quot;</span> </span><br><span class="line">REM 日期格式：<span class="number">20170924200727</span> </span><br><span class="line">md <span class="string">&quot;D:\%ymd%&quot;</span> </span><br><span class="line"><span class="string">&quot;D:\DevTools\MySQL\MySQL5.7\bin\mysqldump.exe&quot;</span> --opt -Q taotao -uroot -proot &gt; D:\%Ymd%\taotao.sql</span><br><span class="line">REM ..... 这里可以添加更多的命令，要看你有多少个数据库，其中 -Q 后面是数据库名称 -p紧跟后面是密码</span><br><span class="line">REM echo Winrar loading... </span><br><span class="line">REM  <span class="string">&quot;C:\Program Files\WinRAR\WinRAR.exe&quot;</span> a -ep1 -r -o+ -m5 -df <span class="string">&quot;D:\数据备份\%Ymd%.rar&quot;</span> <span class="string">&quot;D:\数据备份\%Ymd%&quot;</span> </span><br><span class="line"><span class="meta">@echo on</span></span><br><span class="line">rem ---------------------数据库备份完成-----------------------</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<p>把上面的命令保存为 <em>backup.bat</em> ，双击运行，就开始备份数据了。 </p>
<p>第 一句是建立一个变量 %Ymd% ，通过 %date% 这个系统变量得到日期，%date:<del>,4% 表示取日期的前面4个字符就是年份，%%date:</del>5,2% 表示取日期第5个字符开始的2个字符就是月份，%date:~8,2% 这个就是日期号数，如 2017-09-24 这个日期最后得到的结果是 20170924 </p>
<p>第二句就是使用变量 %Ymd% 的值建立一个空的文件夹。 </p>
<p>第三句开始就是使用MySQL的命令对数据库mysql进行备份，并存储在 D:\数据备份%ymd% 这个文件夹下面，这里可以有很多类似的命令，备份多个数据库。 </p>
<p>最后就是使用 WinRAR 对备份的数据进行压缩，并存储为以 %Ymd% 变量值建立的RAR文件名，同时删除备份的 %Ymd% 目录。 </p>
<p>如果你想让系统自动定期备份，就可以通过系统的任务计划定期执行这个命令。</p>
<p>但是用windows下bat命令备份有一个致命缺点：<strong>备份时数据库会暂时断开。(30M断开5s左右)</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>第二种方式的缺点太致命：<strong>备份时数据库会暂时断开</strong>。</p>
<p>所以第一种方式将会是我们在开发中首选的方式，因为第二种方式的缺点对用户体验的影响太大了。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下Tomcat的安装与优化</title>
    <url>/Linux%E4%B8%8BTomcat%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Linux系统已经搁置很久了，之前有在Ubuntu系统上开发过，但是Linux已经很久没有用了。现在公司把项目部署在Linux系统上，又要把Linux相关知识温习一下。这篇博客温习一下Linux下Tomcat的部署与优化，大部分的操作与在windows上相同。<div align=center><img width="700" height="300" src="../../../../images/2018-01/linux_tomcat/tomcat_linux.png" algin="center"/></div><span id="more"></span></p>
<h1 id="Tomcat的安装"><a href="#Tomcat的安装" class="headerlink" title="Tomcat的安装"></a>Tomcat的安装</h1><p>首先下载Tomcat的压缩包（apache-tomcat-7.0.82.tar.gz），下载地址为：<em><a href="https://tomcat.apache.org/download-70.cgi">https://tomcat.apache.org/download-70.cgi</a></em></p>
<p>将压缩包放到Linux预定目录下，执行tar的解压缩命令</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">cd /usr/soft/</span><br><span class="line">tar -zxvf apache-tomcat-7.0.82.tar.gz</span><br></pre></td></tr></table></figure>

<p>进入到apache-tomcat-7.0.82.tar.gz的bin目录下执行**./startup.sh** 命令即可启动Tomcat。</p>
<div align=center><img width="700" height="300" src="../../../../images/2018-01/linux_tomcat/1.png" algin="center"/>

</div>

<h1 id="Tomcat的优化"><a href="#Tomcat的优化" class="headerlink" title="Tomcat的优化"></a>Tomcat的优化</h1><p>默认情况下Tomcat的配置适合开发模式或者比较小的系统应用，当访问量稍微多的时候比如1000人同时在线做一些频繁的业务操作的时候，可能性能方面就会存在问题，所以有必要在生产环境下对Tomcat做一些优化。</p>
<p>之前几篇文章也提到了Tomcat相关参数的设置与优化，Windows操作系统与Linux操作系统大同小异。</p>
<h2 id="APR模式"><a href="#APR模式" class="headerlink" title="APR模式"></a>APR模式</h2><p>Tomcat 常用运行模式有3种，分别为 BIO，NIO，APR。生产环境建议用APR，从操作系统级别来解决异步的IO问题，大幅度的提高性能。Linux下需要另安装配置APR。</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>APR模式需要下载<strong>apr-1.6.3.tar.gz</strong>和<strong>apr-util-1.6.1.tar.gz</strong>两个文件，下载地址为：<em><a href="http://apr.apache.org/download.cgi">http://apr.apache.org/download.cgi</a></em></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>将连个文件放到合适的位置然后进行安装操作。</p>
<h4 id="apr的安装"><a href="#apr的安装" class="headerlink" title="apr的安装"></a>apr的安装</h4><p>依次执行，将安装路径设为<code>/usr/local/apr</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf apr-1.6.3.tar.gz</span><br><span class="line">cd apr-1.6.3.tar.gz</span><br><span class="line">./configure --prefix=/usr/local/apr</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="apr-util的安装"><a href="#apr-util的安装" class="headerlink" title="apr-util的安装"></a>apr-util的安装</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf apr-util-1.6.1.tar.gz</span><br><span class="line">cd apr-util-1.6.1.tar.gz</span><br><span class="line">./configure --with-apr=/usr/local/apr/bin/apr-1-config</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="安装tomcat-native"><a href="#安装tomcat-native" class="headerlink" title="安装tomcat-native"></a>安装tomcat-native</h4><p><code>tomcat-native.tar.gz是Tomcat自带的压缩包</code>，该文件在tomcat的bin目录下。</p>
<p>系统要先安装好JDK，我的JDK的安装目录为：<code>/usr/soft/jdk1.8.0_152</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/soft/apache-tomcat-7.0.82/bin/</span><br><span class="line">tar -zxvf tomcat-native.tar.gz</span><br><span class="line">cd tomcat-native-1.2.14-src/java/org/apache/tomcat/jni/</span><br><span class="line">./configure --with-apr=/usr/local/apr/bin/apr-1-config --with-java-home=/usr/soft/jdk1.8.0_152</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ol>
<li> 编辑tomcat目录下文件bin/catalina.sh<strong>加载apr</strong>，在任意地方加入下面一行</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">CATALINA_OPTS=&quot;$CATALINA_OPTS -Djava.library.path=/usr/local/apr/lib&quot;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 编辑bin/catalina.sh<strong>配置JVM运行参数</strong>，注意引号不要忘记。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA_OPTS=&quot;-server -Xmx4g -Xms4g -Xmn1g -XX:PermSize=512M -XX:MaxPermSize=521M -XX:+DisableExplicitGC -XX:SurvivorRatio=3 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/soft/apache-tomcat-7.0.82 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:CMSInitiatingOccupancyFraction=65 -XX:+UseCMSInitiatingOccupancyOnly -XX:SoftRefLRUPolicyMSPerMB=0 -XX:+UseCMSCompactAtFullCollection -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -Xloggc:/usr/soft/jdk1.8.0_152/log/gc.log -Djava.awt.headless=true&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编辑conf/server.xml<strong>使用apr运行模式</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</span><br><span class="line">               connectionTimeout=&quot;20000&quot; maxThreads=&quot;1000&quot; minSpareThreads=&quot;100&quot;</span><br><span class="line">			   maxSpareThreads=&quot;200&quot; acceptCount=&quot;900&quot; enableLookups=&quot;false&quot;</span><br><span class="line">			   compression=&quot;on&quot; compressionMinSize=&quot;1024&quot; compressableMimeType=&quot;text/html,text/xml,text/css,text/javascript&quot;</span><br><span class="line">               redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot; maxHttpHeaderSize=&quot;8192&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>启动Tomcat</li>
</ol>
<p>启动tomcat，查看tomcat日志文件，若出现如下信息则表明安装配置成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一月 05, 2018 2:03:09 下午 org.apache.coyote.AbstractProtocol init</span><br><span class="line">信息: Initializing ProtocolHandler [&quot;http-apr-8080&quot;]</span><br><span class="line">一月 05, 2018 2:03:09 下午 org.apache.coyote.AbstractProtocol init</span><br><span class="line">信息:: Initializing ProtocolHandler [&quot;ajp-apr-8009&quot;]</span><br><span class="line">一月 05, 2018 2:03:09 下午 org.apache.catalina.startup.Catalina load</span><br><span class="line">信息:: Initialization processed in 1471 ms</span><br></pre></td></tr></table></figure>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>性能的影响因素是多方面的，互相影响，首先是系统本身没问题，数据库的响应没问题，web容器顺畅，硬件顺畅，网络带宽足够，再使用一些小工具进行检测，只有在大量用户在实际的生产环境中使用系统，才能发现问题，找到问题的根源到底是哪一块引发的性能瓶颈，调整一下自然一切都变得顺畅。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>安装</category>
      </categories>
      <tags>
        <tag>tips</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下安装JDK与MySQL</title>
    <url>/Linux%E4%B8%8B%E5%AE%89%E8%A3%85JDK%E4%B8%8EMySQL/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>重温记录下Linux环境下JDK和MySQL的安装。<div align=center><img width="700" height="200" src="../../../../images/2018-01/linux_JDK_MySQL/installing-mysql-on-linux.png" algin="center"/></div><span id="more"></span></p>
<h1 id="JDK的安装"><a href="#JDK的安装" class="headerlink" title="JDK的安装"></a>JDK的安装</h1><h2 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h2><p>下载JDK压缩包，下载目录：<em><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></em></p>
<p>解压</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xvzf jdk-8u152-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>以<code>root</code>用户使用以下命令进入配置环境变量的profile文件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>

<p>在文件末尾加入以下内容并保存（注意修改JDK路径）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># set java environment </span><br><span class="line">export JAVA_HOME=/usr/soft/jdk1.8.0_152</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure>

<p>在命令行使用以下命令使环境变量生效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<h2 id="切换JDK版本"><a href="#切换JDK版本" class="headerlink" title="切换JDK版本"></a>切换JDK版本</h2><p>当Linux中安装多个JDK时切换进行版本切换。</p>
<p>查看选择所有JDK。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alternatives --config java</span><br></pre></td></tr></table></figure>

<div align=center><img width="700" height="300" src="../../../../images/2018-01/linux_JDK_MySQL/config-f.png" algin="center"/>

</div>

<p>给jdk1.8.0_152设置序列号，输入以下命令（注意修改JDK目录）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alternatives --install /usr/bin/java java /usr/soft/jdk1.8.0_152 4</span><br></pre></td></tr></table></figure>

<p>输入以下命令，选择JDK对应的数字，切换JDK版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alternatives --config java</span><br></pre></td></tr></table></figure>

<div align=center><img width="700" height="300" src="../../../../images/2018-01/linux_JDK_MySQL/config-s1.png" algin="center"/>

</div>

<h1 id="MySQL的安装与卸载"><a href="#MySQL的安装与卸载" class="headerlink" title="MySQL的安装与卸载"></a>MySQL的安装与卸载</h1><h2 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h2><p>从Oracle官方网站下载Linux系统对应的MySQL的yum源包。地址：<em><a href="https://dev.mysql.com/downloads/repo/yum/">https://dev.mysql.com/downloads/repo/yum/</a></em></p>
<div align=center><img width="700" height="300" src="../../../../images/2018-01/linux_JDK_MySQL/1.png" algin="center"/>

</div>

<p>把yum源包上传到linux，依次执行以下命令进行安装。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum localinstall mysql-community-release-el6-5.noarch.rpm</span><br><span class="line">yum install mysql-server</span><br></pre></td></tr></table></figure>

<div align=center><img width="700" height="300" src="../../../../images/2018-01/linux_JDK_MySQL/2.png" algin="center"/>

</div>

<p>安装完成后启动MySQL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service mysqld start</span><br></pre></td></tr></table></figure>

<div align=center><img width="700" height="300" src="../../../../images/2018-01/linux_JDK_MySQL/3.png" algin="center"/>

</div>

<p>给root用户设置密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/mysqladmin -u root password &#x27;root&#x27;</span><br></pre></td></tr></table></figure>

<p>进入MySQL后进行远程连接授权</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;root&#x27; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>

<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>查看MySQL的安装路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whereis mysql</span><br></pre></td></tr></table></figure>

<p>查看mysql的安装包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qa|grep mysql</span><br></pre></td></tr></table></figure>

<p>卸载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum remove mysql</span><br></pre></td></tr></table></figure>

<p>若卸载不完全，则要逐个卸载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qa|grep mysql</span><br><span class="line">yum remove mysql-community-release-el6-5.noarch</span><br><span class="line">yum remove mysql-community-common-5.6.38-2.el6.x86_64</span><br><span class="line">yum remove mysql-community-libs-5.6.38-2.el6.x86_64</span><br></pre></td></tr></table></figure>

<p>删除mysql的数据库文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -rf /var/lib/mysql/</span><br></pre></td></tr></table></figure>

<h2 id="安装包离线安装"><a href="#安装包离线安装" class="headerlink" title="安装包离线安装"></a>安装包离线安装</h2><p>下载MySQL离线安装包：<em><a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a></em></p>
<div align=center><img width="700" height="300" src="../../../../images/2018-01/linux_JDK_MySQL/download.png" algin="center"/>

</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mv mysql-<span class="number">5.6</span><span class="number">.38</span>-linux-glibc2<span class="number">.12</span>-x86_64.tar.gz /usr/local/</span><br><span class="line">cd /usr/local/</span><br><span class="line"><span class="comment">// 解压MySQL安装包</span></span><br><span class="line">tar -zxvf  mysql-<span class="number">5.6</span><span class="number">.38</span>-linux-glibc2<span class="number">.12</span>-x86_64.tar.gz</span><br><span class="line"><span class="comment">// 重命名</span></span><br><span class="line">mv mysql-<span class="number">5.6</span><span class="number">.38</span>-linux-glibc2<span class="number">.12</span>-x86_64 mysql</span><br></pre></td></tr></table></figure>

<div align=center><img width="700" height="300" src="../../../../images/2018-01/linux_JDK_MySQL/tar.png" algin="center"/>

</div>

<p>检查MySQL组和用户是否存在，如无创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cat /etc/group | grep mysql</span><br><span class="line">cat /etc/passwd | grep mysql</span><br><span class="line"><span class="comment">// 如果没有则创建。useradd -r参数表示mysql用户是系统用户，不可用于登录系统</span></span><br><span class="line">groupadd mysql</span><br><span class="line">useradd -r -g mysql mysql</span><br></pre></td></tr></table></figure>

<p>分配用户和组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cd mysql</span><br><span class="line"><span class="comment">// 更改mysql目录所属的用户(用户为mysql)</span></span><br><span class="line">chown -R mysql ../mysql/</span><br><span class="line"><span class="comment">// -R是递归的意思，就是把mysql目录下的全部文件和子目录都设置为mysql用户和mysql组。</span></span><br><span class="line">chgrp -R mysql ../mysql/</span><br><span class="line"><span class="comment">// 上面的做法是为了把mysql降权，以限定只能访问属于mysql用户的文件。</span></span><br></pre></td></tr></table></figure>

<p> 安装及初始化数据库（创建系统数据库的表）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">./scripts/mysql_install_db --user=mysql --basedir=/usr/local/mysql/ --datadir=/usr/local/mysql/data/</span><br></pre></td></tr></table></figure>

<div align=center><img width="700" height="300" src="../../../../images/2018-01/linux_JDK_MySQL/scripts.png" algin="center"/>

</div>

<p>配置MySQL数据库</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 复制配置文件</span></span><br><span class="line">cp -a ./support-files/my-<span class="keyword">default</span>.cnf /etc/my.cnf</span><br><span class="line"><span class="comment">// 更改配置文件信息</span></span><br><span class="line">vi /etc/my.cnf</span><br><span class="line"><span class="comment">// 加入以下内容</span></span><br><span class="line"># These are commonly set, remove the # and set as required.</span><br><span class="line">basedir = /usr/local/mysql</span><br><span class="line">datadir = /usr/local/mysql/data</span><br></pre></td></tr></table></figure>

<p>修改MySQL密码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启动MySQL</span></span><br><span class="line">./support-files/mysql.server start</span><br><span class="line"><span class="comment">// 修改密码</span></span><br><span class="line">./bin/mysqladmin -u root -h localhost.localdomain password <span class="string">&#x27;root&#x27;</span></span><br><span class="line"><span class="comment">// 进入MySQL</span></span><br><span class="line">./bin/mysql -h127<span class="number">.0</span><span class="number">.0</span><span class="number">.1</span> -uroot -proot</span><br></pre></td></tr></table></figure>

<div align=center><img width="700" height="300" src="../../../../images/2018-01/linux_JDK_MySQL/start.jpg" algin="center"/>

</div>

<p>增加远程登录权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant all privileges on *.* to root@&#x27;%&#x27; identified by &#x27;root&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>将MySQL加入Service系统服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先退出MySQL</span></span><br><span class="line">cp support-files/mysql.server /etc/init.d/mysqld</span><br><span class="line">chkconfig --add mysqld</span><br><span class="line">chkconfig mysqld on</span><br><span class="line">service mysqld restart</span><br><span class="line">service mysqld status  </span><br></pre></td></tr></table></figure>

<div align=center><img width="700" height="300" src="../../../../images/2018-01/linux_JDK_MySQL/ok.png" algin="center"/>

</div>

<p>到这里MySQL就配置完成了，剩下的就是优化MySQL，配置/etc/my.cnf啦！</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>安装</category>
      </categories>
      <tags>
        <tag>tips</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下安装Nginx</title>
    <url>/Linux%E4%B8%8B%E5%AE%89%E8%A3%85Nginx/</url>
    <content><![CDATA[<p>记录下Linux下安装Nginx。</p>
<div align=center><img width="400" height="200" src="../../../../images/2018-01/linux_nginx/index.jpg" algin="center"/></div><span id="more"></span>

<h1 id="Nginx安装环境"><a href="#Nginx安装环境" class="headerlink" title="Nginx安装环境"></a>Nginx安装环境</h1><p>Nginx是C语言开发，建议在Linxu上运行，下面操作实在Centos6.5上的安装环境。</p>
<ol>
<li><strong>gcc</strong></li>
</ol>
<p>安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc。</p>
<p>安装命令：<strong>yum install gcc-c++</strong> </p>
<ol start="2">
<li><strong>PCRE</strong></li>
</ol>
<p>PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。</p>
<p>安装命令：<strong>yum install -y pcre pcre-devel</strong></p>
<ol start="3">
<li>zlib</li>
</ol>
<p>zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。</p>
<p>安装命令：<strong>yum install -y zlib zlib-devel</strong></p>
<ol start="4">
<li>openssl</li>
</ol>
<p>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。</p>
<p>安装命令：<strong>yum install -y openssl openssl-devel</strong></p>
<h1 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h1><p>将nginx-1.8.0.tar.gz拷贝至Linux服务器后解压。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tar -zxvf nginx-<span class="number">1.8</span><span class="number">.0</span>.tar.gz</span><br><span class="line">cd nginx-<span class="number">1.8</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>

<ol>
<li>configure</li>
</ol>
<p>./configure –help查询详细参数。参数设置如下：</p>
<p><strong>注意：下边将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--prefix=/usr/local/nginx \</span><br><span class="line">--pid-path=/<span class="keyword">var</span>/run/nginx/nginx.pid \</span><br><span class="line">--lock-path=/<span class="keyword">var</span>/lock/nginx.lock \</span><br><span class="line">--error-log-path=/<span class="keyword">var</span>/log/nginx/error.log \</span><br><span class="line">--http-log-path=/<span class="keyword">var</span>/log/nginx/access.log \</span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line">--http-client-body-temp-path=/<span class="keyword">var</span>/temp/nginx/client \</span><br><span class="line">--http-proxy-temp-path=/<span class="keyword">var</span>/temp/nginx/proxy \</span><br><span class="line">--http-fastcgi-temp-path=/<span class="keyword">var</span>/temp/nginx/fastcgi \</span><br><span class="line">--http-uwsgi-temp-path=/<span class="keyword">var</span>/temp/nginx/uwsgi \</span><br><span class="line">--http-scgi-temp-path=/<span class="keyword">var</span>/temp/nginx/scgi</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编译安装</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make  install</span><br></pre></td></tr></table></figure>

<div align=center><img width="700" height="200" src="../../../../images/2018-01/linux_nginx/install.png" algin="center"/>

</div>

<h1 id="启动Nginx"><a href="#启动Nginx" class="headerlink" title="启动Nginx"></a>启动Nginx</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin/</span><br><span class="line">./nginx</span><br><span class="line"><span class="comment">// 查询nginx进程命令</span></span><br><span class="line">ps aux|grep nginx</span><br></pre></td></tr></table></figure>

<p><strong>注意：执行./nginx启动nginx，这里可以-c指定加载的nginx配置文件，如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./nginx -c /usr/soft/nginx-1.8.0/conf/nginx.conf</span><br></pre></td></tr></table></figure>

<p><strong>如果不指定-c，nginx在启动时默认加载/usr/local/nginx/conf/nginx.conf文件，此文件的地址也可以在编译安装nginx时指定./configure的参数（–conf-path= 指向配置文件（nginx.conf））</strong></p>
<div align=center><img width="700" height="200" src="../../../../images/2018-01/linux_nginx/start.png" algin="center"/>

</div>

<h1 id="重启Nginx"><a href="#重启Nginx" class="headerlink" title="重启Nginx"></a>重启Nginx</h1><ol>
<li><p>先停止再启动（建议使用）</p>
<p>对nginx进行重启相当于先停止nginx再启动nginx，即先执行停止命令再执行启动命令。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./nginx -s quit</span><br><span class="line">./nginx</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>重新加载配置文件</p>
<p>当nginx的配置文件nginx.conf修改后，要想让配置生效需要重启nginx，使用-s reload不用先停止nginx再启动nginx即可将配置信息在nginx中生效。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure>

<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>nginx安装成功，启动nginx，即可访问虚拟机上的nginx</p>
<div align=center><img width="700" height="200" src="../../../../images/2018-01/linux_nginx/ok.png" algin="center"/>

</div>

<p>到这说明nginx上安装成功。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>安装</category>
      </categories>
      <tags>
        <tag>tips</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中的零拷贝技术</title>
    <url>/Linux%E4%B8%AD%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><code>零拷贝(Zero-Copy</code>)技术指在计算机执行操作时，CPU不需要先将数据从一个内存区域复制到另一个内存区域，从而可以减少上下文切换以及CPU的拷贝时间。作用是在数据从网络设备到用户程序空间传递的过程中，减少数据拷贝次数，减少系统调用，实现CPU的零参与，消除CPU在这方面的负载。<div align=center><img src="../../../../images/2020/1-4/Zero-Copy.png" algin="center"/></div><span id="more"></span></p>
<h1 id="零拷贝思想"><a href="#零拷贝思想" class="headerlink" title="零拷贝思想"></a>零拷贝思想</h1><p>零拷贝是一个通过尽量避免拷贝操作来缓解CPU压力的解决方案。Linux下常见的零拷贝技术可以分为两大类：一是针对特定场景，去掉不必要的拷贝；二是去优化整个拷贝的过程。零拷贝并没有真正做到“0”拷贝，它更多是一种思想，很多的零拷贝技术都是基于这个思想去做的优化。</p>
<h1 id="原始数据拷贝"><a href="#原始数据拷贝" class="headerlink" title="原始数据拷贝"></a>原始数据拷贝</h1><div align=center><img src="../../../../images/2020/1-4/Traditional-copy.jpg" algin="center"/></div>

<p>传统数据拷贝产生了四次数据拷贝，即使使用了<code>DMA(Direct Memory Access)</code>处理了硬件的通讯，CPU仍然需要处理两次数据拷贝。同时，CPU在用户态和内核态也发生了多次上下文切换，增加了CPU的负担。在此过程中，如果没有对数据做任何修改，那么在内核态和用户态间来回拷贝数据就是一种浪费。</p>
<h1 id="零拷贝的几种方法"><a href="#零拷贝的几种方法" class="headerlink" title="零拷贝的几种方法"></a>零拷贝的几种方法</h1><h2 id="用户态直接IO"><a href="#用户态直接IO" class="headerlink" title="用户态直接IO"></a>用户态直接IO</h2><div align=center><img src="../../../../images/2020/1-4/Direct-IO.jpg" algin="center"/></div>

<p>对于这种数据传输方式来说，应用程序可以直接访问硬件存储，操作系统内核只是辅助数据传输。这种方式依旧存在用户空间和内核空间的上下文切换，但是硬件上的数据不会拷贝一份到内核空间，而是直接拷贝至了用户空间，因此直接I/O不存在内核空间缓冲区和用户空间缓冲区之间的数据拷贝。</p>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul>
<li>只能适用于那些不需要内核缓冲区处理的应用程序，这些应用程序通常在进程地址空间有自己的数据缓存机制，称为自缓存应用程序，如数据库管理系统。</li>
<li>这种方法直接操作磁盘I/O，由于CPU和磁盘I/O之间的执行时间差距，会造成资源的浪费，解决这个问题需要和异步I/O结合使用。</li>
</ul>
<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p>这种方法，使用mmap来代替 read，可以减少一次拷贝操作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">buf = mmap(diskfd, len);</span><br><span class="line">write(sockfd, buf, len);</span><br></pre></td></tr></table></figure>

<div align=center><img src="../../../../images/2020/1-4/mmap.jpg" algin="center"/></div>

<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h3><ol>
<li>应用进程调用了mmap()之后，数据会先通过DMA拷贝到操作系统内核缓冲区中。接着应用进程跟操作系统<strong>共享这个缓冲区</strong>。这样，操作系统内核和应用进程空间就不需要再进行任何的数据拷贝操作。</li>
<li>应用进程调用write()，操作系统直接将内核缓冲区的数据拷贝到Socket缓冲区中，这一切都发生在内核态。</li>
<li>Socket缓冲区把数据发到网卡。</li>
</ol>
<h3 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h3><p>mmap隐藏着一个陷阱，当mmap一个文件时，如果这个文件被另一个进程所截获，那么write系统调用会因为访问非法地址被SIGBUS信号终止，SIGBUS 默认会杀死进程并产生一个coredump，如果服务器被这样终止了，那损失就可能不小了。</p>
<blockquote>
<p>解决这个问题通常使用文件的租借锁：首先为文件申请一个租借锁，当其他进程想要截断这个文件时，内核会发送一个实时的RT_SIGNAL_LEASE信号，告诉当前进程有进程在试图破坏文件，这样write在被SIGBUS 杀死之前，会被中断，返回已经写入的字节数，并设置errno为success。</p>
<p>通常的做法是在 mmap 之前加锁，操作完之后解锁。</p>
</blockquote>
<p><code>kafka</code>中<code>Producer</code>到<code>Broker</code>的网络数据接收，应用进程不需要中间处理、直接进行持久化时。使用了<code>mmap</code>内存文件映射。</p>
<h2 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h2><p>为了简化用户接口，同时减少CPU的拷贝次数，Linux 在版本 2.1 中引入了sendfile()系统调用。</p>
<div align=center><img src="../../../../images/2020/1-4/sendfile-1.jpg" algin="center"/></div>

<h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><ol>
<li>sendfile()系统调用利用DMA引擎将文件中的数据拷贝到操作系统内核缓冲区中。</li>
<li>然后数据被拷贝到与Socket相关的内核缓冲区中去。</li>
<li>接下来，DMA引擎将数据从内核Socket缓冲区中拷贝到协议引擎中去。</li>
</ol>
<p>sendfile() 系统调用不需要将数据拷贝或者映射到应用程序地址空间中去，所以sendfile()只是适用于应用程序地址空间不需要对所访问数据进行处理的情况。相对于mmap()方法来说，因为sendfile传输的数据没有越过用户应用程序/操作系统内核的边界线，所以sendfile()也极大地减少了存储管理的开销。</p>
<h3 id="缺陷-2"><a href="#缺陷-2" class="headerlink" title="缺陷"></a>缺陷</h3><ul>
<li>只能适用于那些不需要用户态处理的应用程序。</li>
</ul>
<h2 id="DMA辅助的sendfile"><a href="#DMA辅助的sendfile" class="headerlink" title="DMA辅助的sendfile"></a>DMA辅助的sendfile</h2><p>常规sendfile还有一次内核态的拷贝操作，使用DMA辅助的sendfile可以把这次拷贝操作消除。</p>
<div align=center><img src="../../../../images/2020/1-4/sendfile-2.jpg" algin="center"/></div>

<h3 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h3><ol>
<li>用户进程通过sendfile()函数向内核(kernel)发起系统调用，上下文从用户态(user space)切换为内核态(kernel space)；</li>
<li>CPU利用DMA控制器将数据从主存或硬盘拷贝到内核空间(kernel space)的读缓冲区(read buffer)；</li>
<li>CPU把读缓冲区(read buffer)的文件描述符(file descriptor)和数据长度拷贝到网络缓冲区(socket buffer)；</li>
<li>基于已拷贝的文件描述符(file descriptor)和数据长度，CPU利用DMA控制器的gather/scatter操作直接批量地将数据从内核的读缓冲区(read buffer)拷贝到网卡进行数据传输；</li>
<li>上下文从内核态(kernel space)切换回用户态(user space)，Sendfile系统调用执行返回；</li>
</ol>
<p>这种方法借助硬件的帮助，在数据从内核缓冲区到Socket缓冲区这一步操作上，并不是拷贝数据，而是拷贝缓冲区文件描述符(fd)和数据长度。完成后，DMA引擎直接将数据从内核缓冲区拷贝到协议引擎中去，避免了最后一次拷贝。</p>
<p>例如<code>kafka</code>中<code>Broker</code>到<code>Consumer</code>的网络数据发送。</p>
<h3 id="缺陷-3"><a href="#缺陷-3" class="headerlink" title="缺陷"></a>缺陷</h3><ul>
<li>同样适用于那些不需要用户态处理的应用程序。还需要硬件以及驱动程序支持。</li>
<li>只适用于将数据从文件拷贝到套接字上。</li>
</ul>
<h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><p>splice去掉sendfile的使用范围限制，可以用于任意两个文件描述符中传输数据。</p>
<div align=center><img src="../../../../images/2020/1-4/splice.jpg" algin="center"/></div>

<h3 id="过程-3"><a href="#过程-3" class="headerlink" title="过程"></a>过程</h3><ol>
<li>用户进程通过splice()函数向内核(kernel)发起系统调用，上下文从用户态(user space)切换为内核态(kernel space)；</li>
<li>CPU利用DMA控制器将数据从主存或硬盘拷贝到内核空间(kernel space)的读缓冲区(read buffer)；</li>
<li>CPU在内核空间的读缓冲区(read buffer)和网络缓冲区(socket buffer)之间建立管道(pipeline)；</li>
<li>CPU利用DMA控制器将数据从网络缓冲区(socket buffer)拷贝到网卡进行数据传输；</li>
<li>上下文从内核态(kernel space)切换回用户态(user space)，splice系统调用执行返回；</li>
</ol>
<p>但是splice也有局限，它使用了Linux的管道缓冲机制，所以，它的两个文件描述符参数中至少有一个必须是管道设备。</p>
<h3 id="缺陷-4"><a href="#缺陷-4" class="headerlink" title="缺陷"></a>缺陷</h3><ul>
<li>同样只适用于不需要用户态处理的程序。</li>
<li>传输描述符至少有一个是管道设备。</li>
</ul>
<h1 id="Java应用"><a href="#Java应用" class="headerlink" title="Java应用"></a>Java应用</h1><p>Java NIO的<strong>FileChannel.transferFrom()、FileChannel.transferTo()<strong>底层基于</strong>sendfile/splice</strong>，不仅可以进行网络文件传输，还可以对本地文件实现零拷贝操作。</p>
<div align=center><img src="../../../../images/2020/1-4/java-nio.jpg" algin="center"/></div>]]></content>
      <categories>
        <category>Linux</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基本命令</title>
    <url>/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>之前的公司有用过Linux，自己也学习了一段时间，但是很久没有用了，最近又在腾讯云租了个空间把系统装成Centos系统了，所以又把Linux系统重新捡起来，重温下Linux的基本知识。<div align=center><img width="700" height="300" src="../../../../images/2017-4-6/Linux.jpg" algin="center"/></div><span id="more"></span></p>
<h1 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Linux</strong>，免费开源，多用户多任务系统。基于Linux有多个版本的衍生。RedHat、Ubuntu、Debian</p>
<p>安装VMware或VirtualBox虚拟机。Linux的定义和历史右转<a href="http://baike.baidu.com/link?url=ImcCu-CQii_EX-Tiet8ChTjtjNUpDHYUFagNy65U41CX-jqb7oGTOkfew0hJyLhOBPrhC6yZmwUC8Sy-6COiWK"><em>百度百科</em></a>。具体安装步骤，找百度。</p>
<h2 id="常用版本"><a href="#常用版本" class="headerlink" title="常用版本"></a>常用版本</h2><p>我常用的Linux版本有两个<code>Centos</code>和<code>Ubuntu</code>，全都是开源免费的,其中Ubuntu属于桌面版。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Centos是免费的企业版Linux操作系统。是RedHat企业版的优化操作系统。具体可以参照百科：http://baike.baidu.com/view/26404.htm。里面有详解。</span><br><span class="line">另附其官网:http://www.centos.org/。</span><br><span class="line">另外，它适合作为服务器用。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ubuntu之前有在环境中开发过项目，虽然时间不久，但还是有所体会。免费、无毒、免折腾、比较接近底层。</span><br></pre></td></tr></table></figure>

<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><blockquote>
<p>Linux 操作系统位数识别: <code>uname -a（uname -p）</code></p>
<p>Linux 32位操作系统：Linux x86  <a href="http://download.oracle.com/otn-pub/java/jdk/7u45-b18/jdk-7u45-linux-i586.rpm">i586  i386  i686 i…</a></p>
<p>Linux 64位操作系统：Linux x64x86_64  X64 …</p>
</blockquote>
<ol>
<li><code>man</code>          命令不会用了，找男人  如：man ls</li>
<li><code>ifconfig</code>     显示系统信息</li>
<li><code>ls 或ll</code>      查看目录文件</li>
<li><code>pwd</code>      查看目前路径</li>
<li><code>cat 文件名</code>     从第一个字节开始正向查看文件的内容</li>
<li><code>head -2 file1</code>    查看一个文件的前两行 </li>
<li><code>tail -2 file1</code> 查看一个文件的最后两行</li>
<li><code>mv 老名 新名</code>      重命名/剪切</li>
<li><code>cp 老文件路径+文件名 新文件路径（+文件名）</code>    复制 </li>
<li><code>cd</code>       进入个人的主目录 </li>
<li><code>cd 路径名</code>    进入新路径</li>
<li><code>cd ..</code>     后退一步</li>
<li><code>date</code>    显示系统日期</li>
<li><code>shutdown -h now</code>    关闭系统(1) </li>
<li><code>shutdown -r now</code>    重启(1) </li>
<li><code>reboot</code>    重启(2) </li>
<li><code>halt</code>          关机(推荐)</li>
<li><code>logout</code>     注销 </li>
<li><code>mkdir dir1</code>    创建一个叫做 ‘dir1’ 的目录’ </li>
<li><code>rm -f file1</code>    删除一个叫做 ‘file1’ 的文件’</li>
<li><code>rmdir dir1</code>    删除一个叫做 ‘dir1’ 的目录’</li>
<li><code>rm -rf dir1</code>    删除一个叫做 ‘dir1’ 的目录并同时删除其内</li>
<li><code>find / -name file1</code>     从 ‘/‘ 开始进入根文件系统搜索文件和目录 </li>
<li><code>tar -zxvf archive.tar</code>     解压一个包</li>
<li><code>rpm -ivh package.rpm</code>   安装一个rpm包 </li>
</ol>
<p>高级一点的命令，也是比较难懂、需要实践和琢磨的命令：</p>
<ol>
<li><p><code>chmod +权限(ugo)</code>    (u、g、o表示user、group、other)</p>
<blockquote>
<p>三种基本权限</p>
<p>R           读         数值表示为4</p>
<p>W          写         数值表示为2</p>
<p>X           可执行  数值表示为1</p>
</blockquote>
<p>​    例如：chmod 777   表示user、group、other都具有RWX权限。    </p>
</li>
<li><p><code>grep  [options] </code>    grep命令是一种强大的文本搜索工具</p>
<blockquote>
<p>grep ‘test’ d*<br>显示所有以d开头的文件中包含 test的行。</p>
</blockquote>
</li>
<li><p><code>egrep  [options] </code>   或 </p>
<blockquote>
<p>egrep “a|b” filename</p>
<p>搜索包含a或b的行</p>
</blockquote>
</li>
<li><p><code>ps [options] </code>      对进程进行监测和控制</p>
<blockquote>
<p>ps -aux|grep 8080      查看8080端口占用情况</p>
</blockquote>
</li>
<li><p><code>yum [options][command] [package ...]</code>       工具</p>
<blockquote>
<p>yum list     列出当前系统中安装的所有包</p>
</blockquote>
</li>
<li><p><code>wget [OPTION]… [URL]…</code>      wget是一个从网络上自动下载文件的自由工具</p>
<blockquote>
<p>wget <a href="http://example.com/file.iso">http://example.com/file.iso</a>    从网上下载单个文件</p>
</blockquote>
</li>
</ol>
<h2 id="crontab定时任务"><a href="#crontab定时任务" class="headerlink" title="crontab定时任务"></a>crontab定时任务</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>通过crontab 命令，可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。</p>
<ol>
<li><p>crontab文件格式</p>
<p>分 时 日 月 星期 要运行的命令</p>
</li>
</ol>
<ul>
<li>第1列分钟0～59</li>
<li>第2列小时0～23（0表示子夜）</li>
<li>第3列日1～31</li>
<li>第4列月1～12</li>
<li>第5列星期0～7（0和7表示星期天）</li>
<li>第6列要运行的命令</li>
</ul>
<ol start="2">
<li>命令</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">列出crontab文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> crontab -l</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">编辑crontab文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> crontab -e</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">删除crontab文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> crontab -r</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用实例</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每1分钟执行一次myCommand</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> * * * * * myCommand</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 每小时的第3和第15分钟执行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> 3,15 * * * * myCommand</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 每晚的21:30重启smb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> 30 21 * * * /etc/init.d/smb restart</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 每周六、周日的1 : 10重启smb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> 10 1 * * 6,0 /etc/init.d/smb restart</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 每一小时重启smb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> * */1 * * * /etc/init.d/smb restart</span></span><br></pre></td></tr></table></figure>

<h3 id="使用实例-定时备份MySQL"><a href="#使用实例-定时备份MySQL" class="headerlink" title="使用实例(定时备份MySQL)"></a>使用实例(定时备份MySQL)</h3><ol>
<li>在/usr/soft下新建脚本<strong>mysqlbak.sh</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">备份路径</span></span><br><span class="line">BACKUP=/usr/soft/sql</span><br><span class="line"><span class="meta">#</span><span class="bash">当前时间</span></span><br><span class="line">DATETIME=$(date +%Y-%m-%d_%H%M%S)</span><br><span class="line">echo &quot;==备份开始==&quot;</span><br><span class="line">echo &quot;备份文件存放于$&#123;BACKUP&#125;/$DATETIME.tar.gz&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">数据库地址</span></span><br><span class="line">HOST=localhost</span><br><span class="line"><span class="meta">#</span><span class="bash">数据库用户名</span></span><br><span class="line">DB_USER=root</span><br><span class="line"><span class="meta">#</span><span class="bash">数据库密码</span></span><br><span class="line">DB_PW=root</span><br><span class="line"><span class="meta">#</span><span class="bash">创建备份目录</span></span><br><span class="line">[ ! -d &quot;$&#123;BACKUP&#125;/$DATETIME&quot; ] &amp;&amp; mkdir -p &quot;$&#123;BACKUP&#125;/$DATETIME&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">后台系统数据库</span></span><br><span class="line">DATABASE=test</span><br><span class="line">/usr/bin/mysqldump -u$&#123;DB_USER&#125; -p$&#123;DB_PW&#125; --host=$HOST -q -R --databases $DATABASE | gzip &gt; $&#123;BACKUP&#125;/$DATETIME/$DATABASE.sql.gz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">压缩成tar.gz包</span></span><br><span class="line">cd $BACKUP</span><br><span class="line">tar -zcvf $DATETIME.tar.gz $DATETIME</span><br><span class="line"><span class="meta">#</span><span class="bash">删除备份目录</span></span><br><span class="line">rm -rf $&#123;BACKUP&#125;/$DATETIME</span><br><span class="line"><span class="meta">#</span><span class="bash">删除10天前备份的数据</span></span><br><span class="line">find $BACKUP -mtime +10 -name &quot;*.tar.gz&quot; -exec rm -rf &#123;&#125; \;</span><br><span class="line">echo &quot;===备份成功===&quot;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>赋予权限</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod 777 mysqlbak.sh</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>添加至定时任务</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 编辑定时任务列表</span><br><span class="line"><span class="meta">$</span><span class="bash"> crontab -e</span></span><br><span class="line"></span><br><span class="line">// 加入以下内容</span><br><span class="line"><span class="meta">#</span><span class="bash">每隔一个小时执行一次</span></span><br><span class="line">00 */1 * * * /usr/soft/mysqlbak.sh</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。</li>
<li>当crontab失效时，可以尝试<strong>service crond restart</strong>解决问题。或者查看日志看某个job有没有执行/报错<strong>tail -f /var/log/cron</strong>。</li>
<li>千万别乱运行<strong>crontab -r</strong>。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。</li>
<li>在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义%，如经常用的date ‘+%Y%m%d’在crontab里是不会执行的，应该换成date ‘+%Y%m%d’。</li>
</ul>
<p>……………</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Linux博大精深，有很多的命令自己使用的比较少也没有用到，用到的时候再去查资料。</p>
<p>更多的命令可以查看<a href="http://www.cnblogs.com/skillup/articles/1877812.html"><em><strong>http://www.cnblogs.com/skillup/articles/1877812.html</strong></em></a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法指南</title>
    <url>/Markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>花了一段时间把自己的个人博客搭建好了，但是博客必须是要用Markdown书写，所以查了一下Markdown编辑器的语法，在这里做个记录。<div align=center><img width="700" height="300" src="../../../../images/2017-3-23/markdown.png" algin="center"/></div><span id="more"></span></p>
<blockquote>
<p><strong>Markdown</strong>是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台<a href="http://baike.baidu.com/item/WordPress">WordPress</a>和大型CMS如<a href="http://baike.baidu.com/item/Joomla">Joomla</a>、<a href="http://baike.baidu.com/item/Drupal">Drupal</a>都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有<a href="http://baike.baidu.com/item/Ghost/17013737">Ghost</a>和<a href="http://baike.baidu.com/item/Typecho">Typecho</a>。</p>
</blockquote>
<h2 id="基本技巧"><a href="#基本技巧" class="headerlink" title="基本技巧"></a>基本技巧</h2><h3 id="1-代码"><a href="#1-代码" class="headerlink" title="1  代码"></a>1  代码</h3><p>如果你只想高亮语句中的某个函数名或关键字，可以使用 `<code>function_name()</code>` 实现</p>
<p>通常编辑器根据代码片段适配合适的高亮方法，但你也可以用 ``` 包裹一段代码，并指定一种语言</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">​<span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">$(document).ready(function () &#123;</span></span><br><span class="line"><span class="string">    alert(&#x27;hello world&#x27;);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">​`</span><span class="string">``</span> </span><br></pre></td></tr></table></figure>
<p>支持的语言：actionscript, apache, bash, clojure, cmake, coffeescript, cpp, cs, css, d, delphi, django, erlang, go, haskell, html, http, ini, java, javascript, json, lisp, lua, markdown, matlab, nginx, objectivec, perl, php, python, r, ruby, scala, smalltalk, sql, tex, vbscript, xml</p>
<p>也可以使用 4 空格缩进，再贴上代码，实现相同的的效果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    　　def g(x):</span><br><span class="line">        　　<span class="keyword">yield</span> <span class="keyword">from</span> range(x, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line">    　　<span class="keyword">yield</span> <span class="keyword">from</span> range(x)</span><br></pre></td></tr></table></figure>

<h3 id="2-标题"><a href="#2-标题" class="headerlink" title="2  标题"></a>2  标题</h3><p>文章内容较多时，可以用标题分段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标题1</span><br><span class="line">======</span><br><span class="line"></span><br><span class="line">标题2</span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">## 大标题 ##</span><br><span class="line">### 小标题 ###</span><br></pre></td></tr></table></figure>

<h3 id="3-粗斜体"><a href="#3-粗斜体" class="headerlink" title="3  粗斜体"></a>3  粗斜体</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*斜体文本*    _斜体文本_</span><br><span class="line">**粗体文本**    __粗体文本__</span><br><span class="line">***粗斜体文本***    ___粗斜体文本___</span><br></pre></td></tr></table></figure>

<h3 id="4-链接"><a href="#4-链接" class="headerlink" title="4  链接"></a>4  链接</h3><p>4.1 常用链接方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文字链接 ![链接名称](http://链接网址)</span><br><span class="line">网址链接 &lt;http://链接网址&gt;</span><br></pre></td></tr></table></figure>

<p>4.2 高级链接技巧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个链接用 1 作为网址变量 [Google][1].</span><br><span class="line">这个链接用 yahoo 作为网址变量 [Yahoo!][yahoo].</span><br><span class="line">然后在文档的结尾为变量赋值（网址）</span><br><span class="line"></span><br><span class="line">  [1]: http://www.google.com/</span><br><span class="line">  [yahoo]: http://www.yahoo.com/</span><br></pre></td></tr></table></figure>

<h3 id="5-列表"><a href="#5-列表" class="headerlink" title="5  列表"></a>5  列表</h3><p>5.1 普通无序列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 列表文本前使用 [减号+空格]</span><br><span class="line">+ 列表文本前使用 [加号+空格]</span><br><span class="line">* 列表文本前使用 [星号+空格]</span><br></pre></td></tr></table></figure>

<p>5.2 普通有序列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 列表前使用 [数字+空格]</span><br><span class="line">2. 我们会自动帮你添加数字</span><br><span class="line">7. 不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3</span><br></pre></td></tr></table></figure>

<p>5.3 列表嵌套</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 列出所有元素：</span><br><span class="line">    - 无序列表元素 A</span><br><span class="line">        1. 元素 A 的有序子列表</span><br><span class="line">    - 前面加四个空格</span><br><span class="line">2. 列表里的多段换行：</span><br><span class="line">    前面必须加四个空格，</span><br><span class="line">    这样换行，整体的格式不会乱</span><br><span class="line">3. 列表里引用：</span><br><span class="line"></span><br><span class="line">    &gt; 前面空一行</span><br><span class="line">    &gt; 仍然需要在 &gt;  前面加四个空格</span><br><span class="line"></span><br><span class="line">4. 列表里代码段：</span><br><span class="line">前面四个空格，之后按代码语法 ``` 书写</span><br><span class="line">​``` </span><br><span class="line"></span><br><span class="line">    或者直接空八个，引入代码块</span><br></pre></td></tr></table></figure>
<h3 id="6-引用"><a href="#6-引用" class="headerlink" title="6  引用"></a>6  引用</h3><p>6.1 普通引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 引用文本前使用 [大于号+空格]</span><br><span class="line">&gt; 折行可以不加，新起一行都要加上哦</span><br></pre></td></tr></table></figure>

<p>6.2 引用里嵌套引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 最外层引用</span><br><span class="line">&gt; &gt; 多一个 &gt; 嵌套一层引用</span><br><span class="line">&gt; &gt; &gt; 可以嵌套很多层</span><br></pre></td></tr></table></figure>

<p>6.3 引用里嵌套列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; - 这是引用里嵌套的一个列表</span><br><span class="line">&gt; - 还可以有子列表</span><br><span class="line">&gt;     * 子列表需要从 - 之后延后四个空格开始</span><br></pre></td></tr></table></figure>

<p>6.4 引用里嵌套代码块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;     同样的，在前面加四个空格形成代码块</span><br><span class="line">&gt;  </span><br><span class="line">&gt; </span><br><span class="line">&gt; 或者使用 ``` 形成代码块</span><br><span class="line">&gt; ``</span><br></pre></td></tr></table></figure>

<h3 id="7-图片"><a href="#7-图片" class="headerlink" title="7 图片"></a>7 图片</h3><p>7.1 跟链接的方法区别在于前面加了个感叹号 <code>!</code>，这样是不是觉得好记多了呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![图片名称](http://图片网址)</span><br></pre></td></tr></table></figure>

<p>7.2 当然，你也可以像网址那样对图片网址使用变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">这个链接用 <span class="number">1</span> 作为网址变量 [Google][<span class="number">1</span>].</span><br><span class="line">然后在文档的结尾位变量赋值（网址）</span><br><span class="line"></span><br><span class="line"> [<span class="number">1</span>]: http:<span class="comment">//www.google.com/logo.png</span></span><br></pre></td></tr></table></figure>

<p>也可以使用 HTML 的图片语法来自定义图片的宽高大小</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;htt://example.com/sample.png&quot;</span> width=<span class="string">&quot;400&quot;</span> height=<span class="string">&quot;100&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="8-换行"><a href="#8-换行" class="headerlink" title="8  换行"></a>8  换行</h3><p>如果另起一行，只需在当前行结尾加 2 个空格</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在当前行的结尾加 <span class="number">2</span> 个空格  </span><br><span class="line">这行就会新起一行</span><br></pre></td></tr></table></figure>

<p>如果是要起一个新段落，只需要空出一行即可。</p>
<h3 id="9-分隔符"><a href="#9-分隔符" class="headerlink" title="9  分隔符"></a>9  分隔符</h3><p>如果你有写分割线的习惯，可以新起一行输入三个减号<code>-</code>。当前后都有段落时，请空出一行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">前面的段落</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">后面的段落</span><br></pre></td></tr></table></figure>

<h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><h3 id="1-行内-HTML-元素"><a href="#1-行内-HTML-元素" class="headerlink" title="1 行内 HTML 元素"></a>1 行内 HTML 元素</h3><p>目前只支持部分段内 HTML 元素效果，包括 <code>      </code> ，如</p>
<p>键位显示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">使用 &lt;kbd&gt;Ctrl&lt;<span class="regexp">/kbd&gt;+&lt;kbd&gt;Alt&lt;/</span>kbd&gt;+<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Del<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> 重启电脑</span><br></pre></td></tr></table></figure>

<p>代码块</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">使用 &lt;pre&gt;&lt;/pre&gt; 元素同样可以形成代码块</span><br></pre></td></tr></table></figure>

<p>粗斜体</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;b&gt; Markdown 在此处同样适用，如 *加粗* &lt;/b&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-符号转义"><a href="#2-符号转义" class="headerlink" title="2  符号转义"></a>2  符号转义</h3><p>如果你的描述中需要用到 markdown 的符号，比如 <code>_</code> <code>#</code> <code>*</code> 等，但又不想它被转义，这时候可以在这些符号前加反斜杠，如 <code>\_</code> <code>\#``\*</code> 进行避免。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">\_不想这里的文本变斜体\_</span><br><span class="line">\*\*不想这里的文本被加粗\*\*</span><br></pre></td></tr></table></figure>

<h3 id="3-扩展"><a href="#3-扩展" class="headerlink" title="3  扩展"></a>3  扩展</h3><p>支持** jsfiddle、gist、runjs、优酷视频**，直接填写 url，在其之后会自动添加预览点击会展开相关内容。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//&#123;url_of_the_fiddle&#125;/embedded/[&#123;tabs&#125;/[&#123;style&#125;]]/</span></span><br><span class="line">https:<span class="comment">//gist.github.com/&#123;gist_id&#125;</span></span><br><span class="line">http:<span class="comment">//runjs.cn/detail/&#123;id&#125;</span></span><br><span class="line">http:<span class="comment">//v.youku.com/v_show/id_&#123;video_id&#125;.html</span></span><br></pre></td></tr></table></figure>

<h3 id="4-公式"><a href="#4-公式" class="headerlink" title="4  公式"></a>4  公式</h3><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$$ x = &#123;-b \pm \sqrt&#123;b^<span class="number">2</span>-4ac&#125; \over 2a&#125;. $$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">x \href&#123;why-equal.html&#125;&#123;=&#125; y^<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<p>同时也支持 HTML 属性，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$$ (x+<span class="number">1</span>)^<span class="number">2</span> = \<span class="class"><span class="keyword">class</span></span>&#123;hidden&#125;&#123;(x+<span class="number">1</span>)(x+<span class="number">1</span>)&#125; $$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">(x+<span class="number">1</span>)^<span class="number">2</span> = \cssId&#123;step1&#125;&#123;\style&#123;visibility:hidden&#125;&#123;(x+<span class="number">1</span>)(x+<span class="number">1</span>)&#125;&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>markdown语法写多了自然就会了，网上有很多markdown语法编辑器，比如有道云、马克飞象、Typora等。我目前使用的是<code>Typora</code>编辑器，使用起来比其他的更简单、舒适，方便。</p>
]]></content>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven依赖冲突</title>
    <url>/Maven%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81/</url>
    <content><![CDATA[<p>在开发中，比较常用的项目构建工具有<code>Maven</code>、<code>Gradle</code>，自动构建工具可以帮助我们管理项目的外部依赖包、项目编译、打包等。而依赖包冲突又是一个不得不面对的问题，所以了解依赖包的关系传递和构建工具对冲突包的版本选择就很重要了，本文主要介绍下<code>Maven</code>依赖冲突的解决方法。</p>
<mark class="hl-label blue">在Maven中，同一个groupId和artifactId只能使用一个版本。</mark> 

<h1 id="直接依赖"><a href="#直接依赖" class="headerlink" title="直接依赖"></a>直接依赖</h1><p>若相同类型但版本不同的依赖存在于同一个<code>pom</code>文件，靠后引用的<code>Jar</code>的版本会覆盖前面的版本，最终会引入最后一个声明的依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上引入依赖的顺序，项目会使用 <strong>2.8.8</strong> 版本的<code>caffeine</code></p>
<h1 id="间接依赖"><a href="#间接依赖" class="headerlink" title="间接依赖"></a>间接依赖</h1><h2 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h2><p>直接依赖的逻辑比较简单，出现冲突也比较好发现。而项目中比较常见的错误 ClassNotFoundException、NoSuchMethodError往往是因为间接依赖导致的。</p>
<p>依赖传递有两种方式：</p>
<ul>
<li>模块之间的继承关系。在继承父模块后继承了父模块中的依赖，可通过<code>&lt;/dependencyManagement&gt;</code>机制让子模块可选。</li>
<li>引入包时附带引入其他的依赖包。这种是依赖冲突的常见方式。</li>
</ul>
<div align=center><img src="../../../../images/2020/5-8/maven-order.png" algin="center"/></div>

<ul>
<li>A → B → D 1.0</li>
<li>A → D → D 2.0</li>
</ul>
<p>例如上述依赖关系图，项目A引入了B和C依赖，但是B和C又依赖了不同版本的D。此时<code>Maven</code>只能选择D其中一个版本进行解析，但是会选择哪个版本进行解析就需要分析一下了。</p>
<h2 id="依赖选择"><a href="#依赖选择" class="headerlink" title="依赖选择"></a>依赖选择</h2><mark class="hl-label red">Maven依赖调解遵循两大原则：最短路径优先、声明顺序优先。</mark> 

<h3 id="最短路径优先"><a href="#最短路径优先" class="headerlink" title="最短路径优先"></a>最短路径优先</h3><div align=center><img style="width: 400px;" src="../../../../images/2020/5-8/maven-dist.jpg" algin="center"/></div>

<p>如图所示，把当前当成顶层模块，直接依赖的包作为次层模块，依次类推。最后形成一颗依赖树，其中需要比较的就是冲突依赖到顶层模块的路径，<code>Maven</code>会选择路径短的作为依赖。图中会选择 D 1.0 作为依赖。</p>
<h3 id="第一声明顺序优先"><a href="#第一声明顺序优先" class="headerlink" title="第一声明顺序优先"></a>第一声明顺序优先</h3><p>如果冲突依赖的层次相同，那么第一原则就不起作用了，如下图所示：</p>
<div align=center><img src="../../../../images/2020/5-8/maven-order.png" algin="center"/></div>

<p>当路径相同时，则需要根据A直接依赖包在<code>pom.xml</code>文件中的先后顺序来判定使用哪条依赖路径，如果次级模块相同则向下级模块推，直至可以判断先后位置为止。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- A pom.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        B</span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        C</span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>假设在A的<code>pom.xml</code>中，B的依赖位置靠前，C在B之后，则<code>Maven</code>最终引入依赖的版本为 D 1.0</p>
<h1 id="解决依赖冲突"><a href="#解决依赖冲突" class="headerlink" title="解决依赖冲突"></a>解决依赖冲突</h1><p>在IDEA中可以使用<code>Maven Helper</code>插件查看冲突依赖并进行解决。解决依赖冲突的方法，就是使用<code>Maven</code>提供的<code>&lt;exclusion&gt;</code>标签，<code>&lt;exclusion&gt;</code>标签需要放在<code>&lt;exclusions&gt;</code>标签内部。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.minidev<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>accessors-smart<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>组件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB中的索引(一)</title>
    <url>/MongoDB%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在 MongoDB 典型的数据库查询场景中，索引 index 扮演着非常重要的作用，如果没有索引，MongoDB 需要为了找到一个匹配的文档而扫描整个 collection，代价非常高昂。<div align=center><img width="220" height="220" src="../../../../images/2019/1-3/MongoDB-1.jpg" algin="center"/></div><span id="more"></span></p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>MongoDB 的索引使用的 B-tree 这一特殊的数据结构，借助索引 MongoDB 可以高效的匹配到需要查询的数据，以下图来为例(来自官方)：</p>
<div align=center><img src="../../../../images/2019/1-3/MongoDB-2.jpg" algin="center"/></div>

<p>score 索引不但可以高效的支持 range 查询，此外也可以让 MongoDB 高效地返回排序之后的数据，MongoDB 的索引同其它数据库系统很相似，MongoDB 的索引是定义在 collection 级别的，支持对任何单个 field 以及任何 sub-field 建立索引。</p>
<h1 id="默认的-id-index"><a href="#默认的-id-index" class="headerlink" title="默认的 _id index"></a>默认的 <code>_id</code> index</h1><p>MongoDB 在 collection 创建时会默认建立一个基于<code>_id</code>的唯一性索引作为 document 的 primary key，这个 index 无法被删除。</p>
<p>Mongodb 支持多种方式创建索引，具体创建方式见官方文档 <a href="https://docs.mongodb.com/manual/indexes/#create-an-index">https://docs.mongodb.com/manual/indexes/#create-an-index</a></p>
<h1 id="Single-field-index-单索引"><a href="#Single-field-index-单索引" class="headerlink" title="Single field index - 单索引"></a>Single field index - 单索引</h1><p>Single field index 是 MongoDB 最简单的索引类型，不同于 MySQL，MongoDB 的索引是有序的 ascending 或 descending。</p>
<div align=center><img src="../../../../images/2019/1-3/MongoDB-3.jpg" algin="center"/></div>

<p>但是对于 single field index 来说，索引的顺序无关紧要，因为 MongoDB 支持任意顺序遍历 single field index。</p>
<p>在此创建一个 records collection：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span>: ObjectId(<span class="string">&quot;570c04a4ad233577f97dc459&quot;</span>),</span><br><span class="line">  <span class="attr">&quot;score&quot;</span>: <span class="number">1034</span>,</span><br><span class="line">  <span class="attr">&quot;location&quot;</span>: &#123; state: <span class="string">&quot;NY&quot;</span>, city: <span class="string">&quot;New York&quot;</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建一个 single field index：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">db.records.createIndex( &#123; score: <span class="number">1</span> &#125; )</span><br></pre></td></tr></table></figure>

<p>上面的语句在 collection 的 score field 上创建了一个 ascending 索引，这个索引支持以下查询：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">db.records.find( &#123; score: <span class="number">2</span> &#125; )</span><br><span class="line">db.records.find( &#123; score: &#123; $gt: <span class="number">10</span> &#125; &#125; )</span><br></pre></td></tr></table></figure>

<p>可以使用 MongoDB 的 <em>explain</em> 来对以上两个查询进行分析：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">db.records.find(&#123;score:<span class="number">2</span>&#125;).explain(&#x27;executionStats&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="single-index-on-embedded-field-内嵌字段上的单索引"><a href="#single-index-on-embedded-field-内嵌字段上的单索引" class="headerlink" title="single index on embedded field - 内嵌字段上的单索引"></a>single index on embedded field - 内嵌字段上的单索引</h2><p>此外 MongoDB 还支持对 embedded field 进行索引创建：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">db.records.createIndex( &#123; <span class="attr">&quot;location.state&quot;</span>: <span class="number">1</span> &#125; )</span><br></pre></td></tr></table></figure>

<p>上面的 embedded index 支持以下查询：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">db.records.find( &#123; <span class="attr">&quot;location.state&quot;</span>: <span class="string">&quot;CA&quot;</span> &#125; )</span><br><span class="line">db.records.find( &#123; <span class="attr">&quot;location.city&quot;</span>: <span class="string">&quot;Albany&quot;</span>, <span class="attr">&quot;location.state&quot;</span>: <span class="string">&quot;NY&quot;</span> &#125; )</span><br></pre></td></tr></table></figure>

<h2 id="sort-on-single-index-单索引的排序"><a href="#sort-on-single-index-单索引的排序" class="headerlink" title="sort on single index - 单索引的排序"></a>sort on single index - 单索引的排序</h2><p>对于 single index 来说，由于 MongoDB index 本身支持顺序查找，所以对于single index 来说:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">db.records.find().sort( &#123; score: <span class="number">1</span> &#125; )</span><br><span class="line">db.records.find().sort( &#123; score: <span class="number">-1</span> &#125; )</span><br><span class="line">db.records.find(&#123;score:&#123;$lte:<span class="number">100</span>&#125;&#125;).sort( &#123; score: <span class="number">-1</span> &#125; )</span><br></pre></td></tr></table></figure>

<p>这些查询语句都是满足使用 index 的。</p>
<h1 id="Compound-index-组合索引"><a href="#Compound-index-组合索引" class="headerlink" title="Compound index - 组合索引"></a>Compound index - 组合索引</h1><p>Mongodb 支持对多个 field 建立索引，称之为 <em>compound index</em>。<em>Compound index</em> 中 field 的顺序对索引的性能有至关重要的影响，比如索引 <em><strong>{userid:1, score:-1}</strong></em> 首先根据 userid 排序，然后再在每个 userid 中根据 score 排序。</p>
<div align=center><img src="../../../../images/2019/1-3/MongoDB-4.jpg" algin="center"/></div>

<h2 id="创建-Compound-index"><a href="#创建-Compound-index" class="headerlink" title="创建 Compound index"></a>创建 Compound index</h2><p>在此创建一个 products collection：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">&quot;_id&quot;</span>: ObjectId(...),</span><br><span class="line"> <span class="attr">&quot;item&quot;</span>: <span class="string">&quot;Banana&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;category&quot;</span>: [<span class="string">&quot;food&quot;</span>, <span class="string">&quot;produce&quot;</span>, <span class="string">&quot;grocery&quot;</span>],</span><br><span class="line"> <span class="attr">&quot;location&quot;</span>: <span class="string">&quot;4th Street Store&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;stock&quot;</span>: <span class="number">4</span>,</span><br><span class="line"> <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cases&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建一个 compound index：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">db.products.createIndex( &#123; <span class="attr">&quot;item&quot;</span>: <span class="number">1</span>, <span class="attr">&quot;stock&quot;</span>: <span class="number">1</span> &#125; )</span><br></pre></td></tr></table></figure>

<p>这个 index 引用的 document 首先会根据 item 排序，然后在 每个 item 中，又会根据 stock 排序，以下语句都满足该索引：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">db.products.find( &#123; item: <span class="string">&quot;Banana&quot;</span> &#125; )</span><br><span class="line">db.products.find( &#123; item: <span class="string">&quot;Banana&quot;</span>, stock: &#123; $gt: <span class="number">5</span> &#125; &#125; )</span><br></pre></td></tr></table></figure>

<p>条件 {item: “Banana”} 满足是因为这个 query 满足 prefix 原则。</p>
<h2 id="使用-compound-index-需要满足-prefix-原则"><a href="#使用-compound-index-需要满足-prefix-原则" class="headerlink" title="使用 compound index 需要满足 prefix 原则"></a>使用 compound index 需要满足 prefix 原则</h2><p>Index prefix 是指 index fields 的左前缀子集，考虑以下索引：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">&quot;item&quot;</span>: <span class="number">1</span>, <span class="attr">&quot;location&quot;</span>: <span class="number">1</span>, <span class="attr">&quot;stock&quot;</span>: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这个索引包含以下 index prefix：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; item: <span class="number">1</span> &#125;</span><br><span class="line">&#123; item: <span class="number">1</span>, location: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<p>所以只要语句满足 index prefix 原则都是可以支持使用 compound index ：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">db.products.find( &#123; item: <span class="string">&quot;Banana&quot;</span> &#125; )</span><br><span class="line">db.products.find( &#123; item: <span class="string">&quot;Banana&quot;</span>,location:<span class="string">&quot;4th Street Store&quot;</span>&#125; )</span><br><span class="line">db.products.find( &#123; item: <span class="string">&quot;Banana&quot;</span>,location:<span class="string">&quot;4th Street Store&quot;</span>,stock:<span class="number">4</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>相反如果不满足 index prefix 则无法使用索引，比如以下 field 的查询：</p>
<ul>
<li>the <strong>location</strong> field</li>
<li>the <strong>stock</strong> field</li>
<li>the <strong>location</strong> and <strong>stock</strong> fields</li>
</ul>
<p>由于 index prefix 的存在，如果一个 collection 既有 <strong>{a:1, b:1}</strong> 索引 ，也有 <strong>{a:1}</strong> 索引，如果二者没有稀疏或者唯一性的要求，single index 可以移除。</p>
<h2 id="Sort-on-Compound-index-复合索引的排序"><a href="#Sort-on-Compound-index-复合索引的排序" class="headerlink" title="Sort on Compound index - 复合索引的排序"></a>Sort on Compound index - 复合索引的排序</h2><p>前文说过 single index 的 sort 顺序无关紧要，但是 compound index 则完全不同，考虑有如下场景：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">db.events.find().sort( &#123; username: <span class="number">1</span>, date: <span class="number">-1</span> &#125; )</span><br></pre></td></tr></table></figure>

<p>上面的查询首先根据 username 进行 ascending 排序，然后再对结果进行 date descending 。</p>
<p>下面的查询：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">db.events.find().sort( &#123; username: <span class="number">-1</span>, date: <span class="number">1</span> &#125; )</span><br></pre></td></tr></table></figure>

<p>则是首先根据 username 进行 descending 排序，然后再对 date 进行 ascending 排序。</p>
<p>如果想要索引满足以上两种查询和排序，索引类型需要满足如下条件：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">db.events.createIndex( &#123; <span class="attr">&quot;username&quot;</span> : <span class="number">1</span>, <span class="attr">&quot;date&quot;</span> : <span class="number">-1</span> &#125; ）</span><br></pre></td></tr></table></figure>

<p>也就是 <strong>username 和 date 的顺序不同</strong>，如果顺序相同则没有办法满足以上查询，比如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">db.events.find().sort( &#123; username: <span class="number">1</span>, date: <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>也就是说 sort 的顺序必须要和创建索引的顺序是一致的，一致的意思是不一定非要一样，总结起来大致如下：</p>
<table>
<thead>
<tr>
<th>{ “username” : 1, “date” : -1 }</th>
<th>{ “username” : 1, “date” : 1 }</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>sort( { username: 1, date: -1 } )</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>sort( { username: -1, date: 1 } )</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>sort( { username: 1, date: 1 } )</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>sort( { username: -1, date: -1 } )</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p><strong>即排序的顺序必须要和索引一致，逆序之后一致也可以</strong>，下表清晰的列出了 compound index 满足的 query 语句：</p>
<table>
<thead>
<tr>
<th>query</th>
<th>index</th>
</tr>
</thead>
<tbody><tr>
<td>db.data.find().sort( { a: 1 } )</td>
<td>{ a: 1 }</td>
</tr>
<tr>
<td>db.data.find().sort( { a: -1 } )</td>
<td>{ a: 1 }</td>
</tr>
<tr>
<td>db.data.find().sort( { a: 1, b: 1 } )</td>
<td>{ a: 1, b: 1 }</td>
</tr>
<tr>
<td>db.data.find().sort( { a: -1, b: -1 } )</td>
<td>{ a: 1, b: 1 }</td>
</tr>
<tr>
<td>db.data.find().sort( { a: 1, b: 1, c: 1 } )</td>
<td>{ a: 1, b: 1, c: 1 }</td>
</tr>
<tr>
<td>db.data.find( { a: { $gt: 4 } } ).sort( { a: 1, b: 1 } )</td>
<td>{ a: 1, b: 1 }</td>
</tr>
</tbody></table>
<p><strong>即排序的 filed 也要满足 index prefix 原则</strong>。</p>
<h2 id="非-index-prefix-的排序"><a href="#非-index-prefix-的排序" class="headerlink" title="非 index prefix 的排序"></a>非 index prefix 的排序</h2><p>考虑索引 <strong>{ a: 1, b: 1, c: 1, d: 1 }<strong>，即使排序的 field 不满足 index prefix 也是可以的，但前提条件是</strong>排序 field 之前的 index field 必须是等值条件</strong>，</p>
<table>
<thead>
<tr>
<th>Example</th>
<th>Index Prefix</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>r1</td>
<td>db.data.find( { a: 5 } ).sort( { b: 1, c: 1 } )</td>
<td>{ a: 1 , b: 1, c: 1 }</td>
</tr>
<tr>
<td>r2</td>
<td>db.data.find( { b: 3, a: 4 } ).sort( { c: 1 } )</td>
<td>{ a: 1, b: 1, c: 1 }</td>
</tr>
<tr>
<td>r3</td>
<td>db.data.find( { a: 5, b: { $lt: 3} } ).sort( { b: 1 } )</td>
<td>{ a: 1, b: 1 }</td>
</tr>
</tbody></table>
<p>上面表格 r1 的排序 field 是 b 和 c，a 是 index field 而且在 b 和 c 之前，可以使用索引；r3 的排序中 b 是范围查询，但是 b 之前的 a 用的也是等值条件，也就是只要排序 field 之前的 field 满足等值条件即可，其它的 field 可以任意条件。</p>
<h1 id="如何建立正确索引"><a href="#如何建立正确索引" class="headerlink" title="如何建立正确索引"></a>如何建立正确索引</h1><p>前文基本覆盖了日常使用 MongoDB 所需要的主要索引知识，但是如何才建立正确的索引？</p>
<h2 id="使用-explain-分析查询语句"><a href="#使用-explain-分析查询语句" class="headerlink" title="使用 explain 分析查询语句"></a>使用 explain 分析查询语句</h2><p>MongoDB 默认提供了类似 MySQL explain 的语句来分析查询语句的来对我们正确建立索引提供帮助，在建立索引时我们需要对照 explain 对各种查询条件进行分析。</p>
<h2 id="理解-field-顺序对索引的影响"><a href="#理解-field-顺序对索引的影响" class="headerlink" title="理解 field 顺序对索引的影响"></a>理解 field 顺序对索引的影响</h2><p>索引的真正作用是帮助我们限制数据的选择范围，比如 Compound index 多个 feild 的顺序如何决定，应该首选可以最大化的缩小数据查找范围的 field，这样如果第一个 field 可以迅速缩小数据的查找范围，那么后续的 feild 匹配的行就会变少很多。考虑语句：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;start_time&#x27;: &#123;&#x27;$lte&#x27;: present&#125;, &#x27;end_time&#x27;: &#123;&#x27;$gt&#x27;: present&#125;, &#x27;origin&#x27;: <span class="number">1</span>, &#x27;orientation&#x27;: &#x27;quality&#x27;, &#x27;id&#x27;: &#123;&#x27;$gt&#x27;: max_id&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>考虑如下索引</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>nscanded</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>r1</td>
<td>{start_time:1, end_time: 1, origin: 1, id: 1, orientation: 1}</td>
<td>12959</td>
</tr>
<tr>
<td>r2</td>
<td>{start_time:1, end_time: 1, origin: 1, orientation: 1, id: 1}</td>
<td>2700</td>
</tr>
</tbody></table>
<p>由于 field <code>id</code> 和 <code>orientation</code> 的顺序不同会导致需要扫描的 documents 数量差异巨大，说明二者对对数据的限制范围差别很大，优先考虑能够最大化限制数据范围的索引顺序。</p>
<h2 id="监控慢查询"><a href="#监控慢查询" class="headerlink" title="监控慢查询"></a>监控慢查询</h2><p>始终对生成环境产生的慢查询进行第一时间分析，提早发现问题并解决。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://docs.mongodb.com/manual/core/index-compound/">https://docs.mongodb.com/manual/core/index-compound/</a></li>
<li><a href="http://www.infoq.com/cn/articles/improve-find-performance-in-mongo">http://www.infoq.com/cn/articles/improve-find-performance-in-mongo</a></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB索引管理(二)</title>
    <url>/MongoDB%E7%B4%A2%E5%BC%95%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在数据量超大的情形下，任何数据库系统在创建索引时都是一个耗时的大工程。MongoDB也不例外。MongoDB索引的创建有两个选择：一个是前台方式，一个是后台方式。<div align=center><img width="220" height="220" src="../../../../images/2019/1-3/MongoDB索引.jpg" algin="center"/></div><span id="more"></span></p>
<h1 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h1><h2 id="索引创建方式"><a href="#索引创建方式" class="headerlink" title="索引创建方式"></a>索引创建方式</h2><p><strong>前台方式(<em>缺省</em>)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">缺省情况下，当为一个集合创建索引时，这个操作将阻塞其他的所有操作。</span><br><span class="line">即该集合上的无法正常读写，直到索引创建完毕任意基于所有数据库申请读或写锁都将等待直到前台完成索引创建操作。</span><br></pre></td></tr></table></figure>

<p><strong>后台方式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将索引创建置于到后台，适用于那些需要长时间创建索引的情形</span><br><span class="line">这样在创建索引期间，MongoDB依旧可以正常的提供读写操作服务</span><br><span class="line">等同于关系型数据库在创建索引的时候指定online,而MongoDB则是指定background,其目的都是相同的</span><br><span class="line">即在索引创建期间，尽可能的以一种占用较少的资源方式来实现，同时又可以提供读写服务。</span><br><span class="line">后台创建方式的代价：索引创建时间变长。</span><br></pre></td></tr></table></figure>

<h2 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h2><p>MongoDB创建索引使用<code>ensureIndex()</code>方法。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.ensureIndex(keys[,options])</span><br></pre></td></tr></table></figure>

<p><strong>Keys</strong> ： 要创建的索引字段</p>
<ul>
<li><strong>1</strong> 按升序创建索引</li>
<li><strong>-1</strong> 按降序来创建索引</li>
</ul>
<h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>background</td>
<td>Boolean</td>
<td>建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 “background”  可选参数。 “background” 默认值为<strong>false</strong></td>
</tr>
<tr>
<td>unique</td>
<td>Boolean</td>
<td>建立的索引是否唯一。指定为true创建唯一索引。默认值为 <strong>false</strong></td>
</tr>
<tr>
<td>name</td>
<td>string</td>
<td>索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称</td>
</tr>
<tr>
<td>dropDups</td>
<td>Boolean</td>
<td><strong>3.0+版本已废弃。</strong>在建立唯一索引时是否删除重复记录，指定 true 创建唯一索引。默认值为<strong>false</strong></td>
</tr>
<tr>
<td>sparse</td>
<td>Boolean</td>
<td>对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档。默认值为 <strong>false</strong></td>
</tr>
<tr>
<td>expireAfterSeconds</td>
<td>integer</td>
<td>指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。</td>
</tr>
<tr>
<td>v</td>
<td>index version</td>
<td>索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。</td>
</tr>
<tr>
<td>weights</td>
<td>document</td>
<td>索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重</td>
</tr>
<tr>
<td>default_language</td>
<td>string</td>
<td>对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语</td>
</tr>
<tr>
<td>language_override</td>
<td>string</td>
<td>对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的 language，默认值为 language</td>
</tr>
</tbody></table>
<h2 id="后台创建范例"><a href="#后台创建范例" class="headerlink" title="后台创建范例"></a>后台创建范例</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.ensureIndex(&#123;name: <span class="number">1</span>, age: <span class="number">1</span>&#125;, &#123;background: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>通过在创建索引时加 <strong>background:true</strong> 选项，让创建工作在后台执行。</p>
<p>使用索引和不使用差距很大，合理使用索引，一个集合适合做 4-5 个索引。</p>
<h2 id="查看索引创建进度"><a href="#查看索引创建进度" class="headerlink" title="查看索引创建进度"></a>查看索引创建进度</h2><p>可使用 <code>db.currentOp()</code> 命令观察索引创建的完成进度。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.currentOp(&#123;</span><br><span class="line">          $<span class="keyword">or</span>: [</span><br><span class="line">            &#123; op: &quot;command&quot;, &quot;query.createIndexes&quot;: &#123; $<span class="keyword">exists</span>: <span class="literal">true</span> &#125; &#125;,</span><br><span class="line">            &#123; op: &quot;insert&quot;, ns: <span class="operator">/</span>\.<span class="keyword">system</span>\.indexes\b<span class="operator">/</span> &#125;</span><br><span class="line">          ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="终止索引的创建"><a href="#终止索引的创建" class="headerlink" title="终止索引的创建"></a>终止索引的创建</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.killOp();</span><br></pre></td></tr></table></figure>

<h1 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h1><p>MongoDB提供了查看索引信息的方法：</p>
<ul>
<li><p><code>getIndexes()</code>：查看集合的所有索引;</p>
</li>
<li><p><code>totalIndexSize()</code>：查看集合索引的总大小;</p>
</li>
<li><p><code>db.system.indexes.find()</code>：查看数据库中所有索引信息。</p>
</li>
</ul>
<h2 id="查看集合中的索引getIndexes"><a href="#查看集合中的索引getIndexes" class="headerlink" title="查看集合中的索引getIndexes()"></a>查看集合中的索引getIndexes()</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.getIndexes();</span><br></pre></td></tr></table></figure>

<h2 id="查看集合中的索引大小totalIndexSize"><a href="#查看集合中的索引大小totalIndexSize" class="headerlink" title="查看集合中的索引大小totalIndexSize()"></a>查看集合中的索引大小totalIndexSize()</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.totalIndexSize();</span><br></pre></td></tr></table></figure>

<h2 id="查看数据库中所有索引db-system-indexes-find"><a href="#查看数据库中所有索引db-system-indexes-find" class="headerlink" title="查看数据库中所有索引db.system.indexes.find()"></a>查看数据库中所有索引db.system.indexes.find()</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.system.indexes.find();</span><br></pre></td></tr></table></figure>

<h1 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h1><p>不再需要的索引，可以将其删除。删除索引时，可以删除集合中的某一索引，也可以删除全部索引。</p>
<h2 id="删除指定的索引dropIndex"><a href="#删除指定的索引dropIndex" class="headerlink" title="删除指定的索引dropIndex()"></a>删除指定的索引dropIndex()</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.dropIndex(&quot;INDEX-NAME&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="删除所有索引dropIndexes"><a href="#删除所有索引dropIndexes" class="headerlink" title="删除所有索引dropIndexes()"></a>删除所有索引dropIndexes()</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.dropIndexes();</span><br></pre></td></tr></table></figure>

<h1 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h1><p>数据表经多次修改后导致文件产生空洞，索引文件也是如此。因此可通过重建索引来提高索引的查询效率，类似MySQL的optimize表。根据MongoDB文档，通常不需要定期重建索引，且<strong>始终在前台构建索引</strong>。</p>
<p>官网文档可查看：<a href="https://docs.mongodb.com/manual/reference/command/reIndex/">https://docs.mongodb.com/manual/reference/command/reIndex/</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 该方法的调用不接受任何的参数</span><br><span class="line">db.COLLECTION_NAME.reIndex();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB辅助之mongo-spring-support</title>
    <url>/MongoDB%E8%BE%85%E5%8A%A9%E4%B9%8Bmongo-spring-support/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在开发中经常使用到<strong>MongoDB</strong>，每个项目使用各不相同，既繁琐又好不管理。这里封装了一套MongoDB类似于Mybatis的ORM增强版工具，和Spring无缝结合，只需要简单的配置就可以实现强大的功能。同时扩展了MongoDB的Datastore功能，加了一些自定义方法。其原理离不开之前所说的FactoryBean。<div align=center><img width="220" height="220" src="../../../../images/2019/4-6/mongo-spring-support.jpg" algin="center"/></div><span id="more"></span></p>
<p>源码放在了我的GitHub上：<a href="https://github.com/mx-go/mongo-spring-support">https://github.com/mx-go/mongo-spring-support</a></p>
<p>源码中有详细使用注释，其原理就是实现FactoryBean生成代理对象并对原本的Datastore进行增强。</p>
<p>在这里记录下使用方法。</p>
<h1 id="MongoDB数据库及集合"><a href="#MongoDB数据库及集合" class="headerlink" title="MongoDB数据库及集合"></a>MongoDB数据库及集合</h1><p>以下测试在MongoDB的TEST库中，其中有两个集合student、student_1。student_1可以用来测试同库中，根据后缀来切换集合，相当与分表。</p>
<div align=center><img width="700" height="220" src="../../../../images/2019/4-6/Mongo-ext1.jpg" algin="center"/></div>

<div align=center><img width="700" height="220" src="../../../../images/2019/4-6/Mongo-ext2.jpg" algin="center"/></div>

<h1 id="引入Maven坐标"><a href="#引入Maven坐标" class="headerlink" title="引入Maven坐标"></a>引入Maven坐标</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.mx-go<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mongo-spring-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h1><p>在Spring中配置MongoDB的<em>server</em>地址、<em>dbName</em>等信息，可以配置更多参数，见<a href="https://github.com/mx-go/mongo-spring-support/blob/master/src/main/java/com/github/mongo/support/mongo/MongoConfiguration.java">MongoConfiguration</a>类中属性。jar包中已包含<em>mongo-java-driver</em>和<em>morphia</em>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.rainbowhorse.demo&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--生成代理对象，增强原方法，自定义方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;datastoreExt&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.github.mongo.support.mongo.MongoDataStoreFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configuration&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;configuration&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置属性。可以配置更多属性，详细看MongoConfiguration类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;configuration&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.github.mongo.support.mongo.MongoConfiguration&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库连接--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;servers&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mongodb://root:root@localhost:27017/TEST&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库名称--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dbName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;TEST&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--对应实体所在路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.rainbowhorse.demo.mongo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="简单使用范例"><a href="#简单使用范例" class="headerlink" title="简单使用范例"></a>简单使用范例</h1><h2 id="简单模式"><a href="#简单模式" class="headerlink" title="简单模式"></a>简单模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  DatastoreExt datastoreExt;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    datastore.save(user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单实例多库"><a href="#单实例多库" class="headerlink" title="单实例多库"></a>单实例多库</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  DatastoreExt datastoreExt;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    datastore.use(<span class="string">&quot;user_db&quot;</span>).save(user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  DatastoreExt datastoreExt;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Blog blog)</span> </span>&#123;</span><br><span class="line">    datastore.use(<span class="string">&quot;blog_db&quot;</span>).save(blog);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="表名添加前缀或者后缀"><a href="#表名添加前缀或者后缀" class="headerlink" title="表名添加前缀或者后缀"></a>表名添加前缀或者后缀</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  DatastoreExt datastoreExt;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// user对象会保存到db01.2017_user的表中</span></span><br><span class="line">    datastore.getDatastoreByPrefix(<span class="string">&quot;db01&quot;</span>, <span class="string">&quot;2017&quot;</span>).save(user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  DatastoreExt datastoreExt;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Blog blog)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// blog对象会保存到db02.blog_2017的表中</span></span><br><span class="line">    datastore.getDatastoreBySuffix(<span class="string">&quot;db02&quot;</span>, <span class="string">&quot;2017&quot;</span>).save(blog);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="集合实体类StudentDO"><a href="#集合实体类StudentDO" class="headerlink" title="集合实体类StudentDO"></a>集合实体类StudentDO</h1><p>MongoDB是文档型数据库，借助<em>morphia</em>可以把集合映射到到Java中的Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.mongodb.morphia.annotations.Entity;</span><br><span class="line"><span class="keyword">import</span> org.mongodb.morphia.annotations.Id;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * value中存储集合名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity(value = &quot;student&quot;, noClassnameStored = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDO</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2997596487756179430L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对应mongo中的_id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="接口及实现类"><a href="#接口及实现类" class="headerlink" title="接口及实现类"></a>接口及实现类</h1><h2 id="接口StudentDAO"><a href="#接口StudentDAO" class="headerlink" title="接口StudentDAO"></a>接口StudentDAO</h2><p>接口继承<em>mongo-support</em>中的**<a href="https://github.com/mx-go/mongo-spring-support/blob/master/src/main/java/com/github/mongo/support/dao/BaseDao.java">BaseDao</a>**，可以实现更多方法的调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDAO</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">StudentDO</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;StudentDO&gt; <span class="title">getByScore</span><span class="params">(Integer score)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新age</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateAge</span><span class="params">(String id, Integer age)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过name增加score</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 更新结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">incrScoreByName</span><span class="params">(StudentDO tenantQuotaDO)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;StudentDO&gt; <span class="title">getScoreAndPage</span><span class="params">(StudentDO studentDO, Pager&lt;StudentDO&gt; pager)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getStudentCounts</span><span class="params">(StudentDO tenantQuotaDO)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口实现类StudentDAOImpl"><a href="#接口实现类StudentDAOImpl" class="headerlink" title="接口实现类StudentDAOImpl"></a>接口实现类StudentDAOImpl</h2><p>继承**<a href="https://github.com/mx-go/mongo-spring-support/blob/master/src/main/java/com/github/mongo/support/dao/BaseDaoImpl.java">BaseDaoImpl</a>**，其中实现基础方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDAOImpl</span> <span class="keyword">extends</span> <span class="title">BaseDaoImpl</span>&lt;<span class="title">StudentDO</span>&gt; <span class="keyword">implements</span> <span class="title">StudentDAO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentDAOImpl</span><span class="params">(DatastoreExt datastoreExt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(datastoreExt, StudentDO.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;StudentDO&gt; <span class="title">getByScore</span><span class="params">(Integer score)</span> </span>&#123;</span><br><span class="line">        Query&lt;StudentDO&gt; query = createQuery();</span><br><span class="line">        query.criteria(<span class="string">&quot;score&quot;</span>).equal(score);</span><br><span class="line">        <span class="keyword">return</span> query.asList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateAge</span><span class="params">(String id, Integer age)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Query&lt;StudentDO&gt; query = createQuery();</span><br><span class="line">        query.field(<span class="string">&quot;_id&quot;</span>).equal(<span class="keyword">new</span> ObjectId(id));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> UpdateOperations&lt;StudentDO&gt; update = createUpdateOperations();</span><br><span class="line">        update.set(<span class="string">&quot;age&quot;</span>, age);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getDatastore().update(query, update).getUpdatedCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;StudentDO&gt; <span class="title">getScoreAndPage</span><span class="params">(StudentDO studentDO, Pager&lt;StudentDO&gt; pager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queryList(studentDO, pager.offset(), pager.getPageSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStudentCounts</span><span class="params">(StudentDO studentDO)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) queryCount(studentDO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">incrScoreByName</span><span class="params">(StudentDO studentDO)</span> </span>&#123;</span><br><span class="line">        Query&lt;StudentDO&gt; query = createQuery(studentDO);</span><br><span class="line">        UpdateOperations&lt;StudentDO&gt; updateOperation = createUpdateOperations().inc(<span class="string">&quot;score&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> getDatastore().update(query, updateOperation).getUpdatedCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> StudentDAO studentDAO;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      List&lt;StudentDO&gt; name1 = studentDAO.getByScore(<span class="number">88</span>);</span><br><span class="line">      System.out.println(name1.size());</span><br><span class="line"></span><br><span class="line">      StudentDO studentDO = <span class="keyword">new</span> StudentDO();</span><br><span class="line">      studentDO.setName(<span class="string">&quot;max10&quot;</span>);</span><br><span class="line">      System.out.println(studentDAO.incrScoreByName(studentDO));</span><br><span class="line"></span><br><span class="line">      StudentDO studentDO1 = <span class="keyword">new</span> StudentDO();</span><br><span class="line">      studentDO1.setScore(<span class="number">88</span>);</span><br><span class="line">      Pager&lt;StudentDO&gt; pager = <span class="keyword">new</span> Pager&lt;&gt;();</span><br><span class="line">      pager.setPageSize(<span class="number">2</span>);</span><br><span class="line">      pager.setCurrentPage(<span class="number">2</span>);</span><br><span class="line">      List&lt;StudentDO&gt; scoreAndPage = studentDAO.getScoreAndPage(studentDO1, pager);</span><br><span class="line">      System.out.println(scoreAndPage);</span><br><span class="line"></span><br><span class="line">      System.out.println(studentDAO.getStudentCounts(<span class="keyword">new</span> StudentDO()));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> age = studentDAO.updateAge(<span class="string">&quot;5ca6b118a03b9e0e7f5bb33c&quot;</span>, <span class="number">20</span>);</span><br><span class="line">      System.out.println(age);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 测试扩展动态切换集合</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestDatastore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      DatastoreExt datastore = datastoreExt.getDatastoreBySuffix(<span class="string">&quot;TEST&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">      studentDAO = <span class="keyword">new</span> StudentDAOImpl(datastore);</span><br><span class="line"></span><br><span class="line">      List&lt;StudentDO&gt; name1 = studentDAO.getByScore(<span class="number">66</span>);</span><br><span class="line">      System.out.println(name1);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tips</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL主从/主主复制</title>
    <url>/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>MySQL作为世界上最广泛的数据库之一，免费是原因之一，其本身功能的强大也是获得众多用的青睐的重要原因。在实际的生产环境中，单机版MySQL数据库就不能满足实际的需求了，此时数据库集群就很好的解决了这个问题了。采用MySQL分布式集群，能够搭建一个高并发、负载均衡的集群服务器。在此之前必须要保证每台MySQL服务器里的数据同步。数据同步可以通过MySQL内部配置就可以轻松完成，主要有<strong>主从复制</strong>和<strong>主主复制</strong>。<div align=center><img width="700" height="300" src="../../../../images/2018-4/MySQL_master_slave/index.jpg" algin="center"/></div></p>
<p>在本案例下使用同一台机器安装两个数据库，只是端口不一致，一个为3306，一个为3308。</p>
<h1 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h1><ol>
<li>Master将数据改变记录到二进制日志(binary log)中，也就是配置文件log-bin指定的文件，这些记录叫做二进制日志事件(binary log events) 。</li>
<li>Slave通过I/O线程读取Master中的binary log events并写入到它的中继日志(relay log) 。</li>
<li>Slave重做中继日志中的事件，把中继日志中的事件信息一条一条的在本地执行一次，完成数据在本地的存储，从而实现将改变反映到它自己的数据(数据重放)。</li>
</ol>
<h1 id="复制类型"><a href="#复制类型" class="headerlink" title="复制类型"></a>复制类型</h1><p> 1、<strong>基于语句的复制(statement)</strong></p>
<blockquote>
<p>在Master上执行的SQL语句，在Slave上执行同样的语句。MySQL默认采用基于语句的复制，效率比较高。</p>
</blockquote>
<div align=center><img src="../../../../images/2018-4/MySQL_explain/eg.png" algin="center"/></div>根据上图可得到执行计划的列信息，下面分析一下每列所表示的信息。

<blockquote>
<p>把改变的内容复制到Slave，而不是把命令在Slave上执行一遍。从MySQL5.0开始支持。</p>
</blockquote>
<p> 3、<strong>混合类型的复制(mixed)</strong></p>
<blockquote>
<p>默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</p>
</blockquote>
<h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><ul>
<li>文件${mysql}/data/auto.cnf里server-uuid不能重复。</li>
<li>主从服务器操作系统版本和位数一致。</li>
<li>Master和Slave数据库的版本要一致。</li>
<li>Master和Slave数据库中的数据要一致。</li>
<li>Master开启二进制日志，Master和Slave的server_id在局域网内必须唯一。</li>
</ul>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>主从复制能保证主SQL（Master）和从SQL（Slave）的数据是一致性的，向Master插入数据后，Slave会自动从Master把修改的数据同步过来（有一定的延迟），通过这种方式来保证数据的一致性，主从复制**基于日志(binlog)**。</p>
<p>主从复制可解决：</p>
<ul>
<li><strong>高可用</strong></li>
</ul>
<p>因为数据都是相同的，所以当Master挂掉后，可以指定一台Slave充当Master继续保证服务运行，因为数据是一致性的（如果当插入Master就挂掉，可能不一致，因为同步也需要时间）。</p>
<ul>
<li><strong>负载均衡</strong></li>
</ul>
<p>因为读写分离也算是负载均衡的一种，一般都是有多台Slave的，所以可以将读操作指定到Slave服务器上（需要代码控制），然后再用负载均衡来选择那台Slave来提供服务，同时也可以吧一些大量计算的查询指定到某台Slave，这样就不会影响Master的写入以及其他查询。</p>
<ul>
<li><strong>数据备份</strong></li>
</ul>
<p>一般我们都会做数据备份，可能是写定时任务，一些特殊行业可能还需要手动备份，有些行业要求备份和原数据不能在同一个地方，所以主从就能很好的解决这个问题，不仅备份及时，而且还可以多地备份，保证数据的安全。</p>
<ul>
<li><strong>业务模块化</strong></li>
</ul>
<p>可以一个业务模块读取一个Slave，再针对不同的业务场景进行数据库的索引创建和根据业务选择MySQL存储引擎。</p>
<h2 id="配置Master"><a href="#配置Master" class="headerlink" title="配置Master"></a>配置Master</h2><h3 id="配置my-cnf"><a href="#配置my-cnf" class="headerlink" title="配置my.cnf"></a>配置my.cnf</h3><p>Linux下MySQL配置文件为my.cnf，windows下为my.ini。在Master添加以下配置：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment">## 设置server_id，一般设置为IP,注意要唯一</span></span><br><span class="line">server_id=1</span><br><span class="line"><span class="comment">## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line"><span class="comment">## 开启二进制日志功能，可以随便取，最好有含义（关键就是这里了）</span></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line"><span class="comment">## 为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存</span></span><br><span class="line">binlog_cache_size=1M</span><br><span class="line"><span class="comment">## 主从复制的格式（mixed,statement,row，默认格式是statement）</span></span><br><span class="line">binlog_format=mixed</span><br><span class="line"><span class="comment">## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。</span></span><br><span class="line">expire_logs_days=7</span><br><span class="line"><span class="comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span><br><span class="line"><span class="comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span><br><span class="line">slave_skip_errors=1062</span><br></pre></td></tr></table></figure>

<p>配置完成后重启MySQL。</p>
<h3 id="创建数据同步用户"><a href="#创建数据同步用户" class="headerlink" title="创建数据同步用户"></a>创建数据同步用户</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- -- 用户名：slave，密码：slave</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;slave&#x27;</span>;</span><br><span class="line"><span class="comment">-- 授予用户REPLICATION SLAVE权限和REPLICATION CLIENT权限</span></span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE, REPLICATION CLIENT <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;  </span><br></pre></td></tr></table></figure>

<h2 id="配置Slave"><a href="#配置Slave" class="headerlink" title="配置Slave"></a>配置Slave</h2><p>Linux下MySQL配置文件为my.cnf，windows下为my.ini。在Slave添加以下配置：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment">## 设置server_id，一般设置为IP,注意要唯一</span></span><br><span class="line">server_id </span><br><span class="line"><span class="comment">## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line"><span class="comment">## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用</span></span><br><span class="line">log-bin=mysql-slave1-bin</span><br><span class="line"><span class="comment">## 为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存</span></span><br><span class="line">binlog_cache_size=1M</span><br><span class="line"><span class="comment">## 主从复制的格式（mixed,statement,row，默认格式是statement）</span></span><br><span class="line">binlog_format=mixed</span><br><span class="line"><span class="comment">## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。</span></span><br><span class="line">expire_logs_days=7</span><br><span class="line"><span class="comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span><br><span class="line"><span class="comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span><br><span class="line">slave_skip_errors=1062</span><br><span class="line"><span class="comment">## relay_log配置中继日志</span></span><br><span class="line">relay_log=mysql-relay-bin  </span><br><span class="line"><span class="comment">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span></span><br><span class="line">log_slave_updates=1</span><br><span class="line"><span class="comment">## 防止改变数据(除了特殊的线程)</span></span><br><span class="line">read_only=1</span><br></pre></td></tr></table></figure>

<p><strong>如果Slave为其它Slave的Master时，必须设置bin_log</strong>。配置完成后重启MySQL。</p>
<h2 id="连接Master和Slave"><a href="#连接Master和Slave" class="headerlink" title="连接Master和Slave"></a>连接Master和Slave</h2><h3 id="查询Master状态"><a href="#查询Master状态" class="headerlink" title="查询Master状态"></a>查询Master状态</h3><p>在master中执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> MASTER STATUS;</span><br></pre></td></tr></table></figure>

<p>记录下返回结果的<strong>File列和Position列</strong>的值。</p>
<div align=center><img src="../../../../images/2018-4/MySQL_master_slave/master_status.png" algin="center"/></div>

<h3 id="在Slave中设置Master信息"><a href="#在Slave中设置Master信息" class="headerlink" title="在Slave中设置Master信息"></a>在Slave中设置Master信息</h3><p>在slave中执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span> MASTER_HOST<span class="operator">=</span><span class="string">&#x27;127.0.0.1&#x27;</span>, MASTER_USER<span class="operator">=</span><span class="string">&#x27;slave&#x27;</span>, MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;slave&#x27;</span>, MASTER_PORT<span class="operator">=</span><span class="number">3306</span>, MASTER_LOG_FILE<span class="operator">=</span><span class="string">&#x27;mysql-bin.000014&#x27;</span>, MASTER_LOG_POS<span class="operator">=</span><span class="number">1122</span>, MASTER_CONNECT_RETRY<span class="operator">=</span><span class="number">30</span>;</span><br><span class="line"><span class="comment">-- master_host=&#x27;127.0.0.1&#x27; ## Master的IP地址</span></span><br><span class="line"><span class="comment">-- master_user=&#x27;slave&#x27; ## 用于同步数据的用户（在Master中授权的用户）</span></span><br><span class="line"><span class="comment">-- master_password=&#x27;slave&#x27; ## 同步数据用户的密码</span></span><br><span class="line"><span class="comment">-- master_port=3306 ## Master数据库服务的端口</span></span><br><span class="line"><span class="comment">-- master_log_file=&#x27;mysql-bin.000014&#x27; ##指定Slave从哪个日志文件开始读复制数据（Master上执行命令的结果的File字段）</span></span><br><span class="line"><span class="comment">-- master_log_pos=1122 ## 从哪个POSITION号开始读（Master上执行命令的结果的Position字段）</span></span><br><span class="line"><span class="comment">-- masterconnectretry=30 ##当重新建立主从连接时，如果连接建立失败，间隔多久后重试。单位为秒，默认设置为60秒，同步延迟调优参数。</span></span><br></pre></td></tr></table></figure>

<h3 id="查看主从同步状态"><a href="#查看主从同步状态" class="headerlink" title="查看主从同步状态"></a>查看主从同步状态</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> SLAVE STATUS;</span><br></pre></td></tr></table></figure>

<div align=center><img src="../../../../images/2018-4/MySQL_master_slave/master_slave_notok.png" algin="center"/></div>

<p>可看到Slave_IO_State为空， Slave_IO_Running和Slave_SQL_Running是No，表明Slave还没有开始复制过程。相反Slave_IO_Running和Slave_SQL_Running是Yes表明已经开始工作了。</p>
<h3 id="开启-关闭主从"><a href="#开启-关闭主从" class="headerlink" title="开启/关闭主从"></a>开启/关闭主从</h3><p>在slave中执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 停止主从</span></span><br><span class="line">STOP SLAVE;</span><br><span class="line"><span class="comment">-- 开启主从</span></span><br><span class="line"><span class="keyword">START</span> SLAVE;</span><br></pre></td></tr></table></figure>

<div align=center><img src="../../../../images/2018-4/MySQL_master_slave/master_slave_ok.png" algin="center"/></div>

<p>查询查看主从同步状态，会发现<strong>Slave_IO_Running和Slave_SQL_Running是Yes</strong>了，表明开启成功。</p>
<h1 id="主主复制"><a href="#主主复制" class="headerlink" title="主主复制"></a>主主复制</h1><p>主主复制即在两台MySQL主机内都可以变更数据，而且另外一台主机也会做出相应的变更。其实现就是将两个主从复制有机合并起来就好了。只不过在配置的时候我们需要注意一些问题，例如，主键重复，server-id不能重复等等。</p>
<h2 id="配置Master-1"><a href="#配置Master-1" class="headerlink" title="配置Master"></a>配置Master</h2><p>接上一案例，在上一案例中的Slave中执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 用户名：slave1，密码：slave1</span></span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;slave1&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;slave1&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"><span class="keyword">SHOW</span> MASTER STATUS;</span><br></pre></td></tr></table></figure>

<p>同样记录下返回结果的<strong>File列和Position列</strong>的值。</p>
<div align=center><img src="../../../../images/2018-4/MySQL_master_slave/2-1.png" algin="center"/></div>

<h2 id="配置Slave-1"><a href="#配置Slave-1" class="headerlink" title="配置Slave"></a>配置Slave</h2><p>在上一案例中的Master中执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span> MASTER_HOST<span class="operator">=</span><span class="string">&#x27;127.0.0.1&#x27;</span>, MASTER_USER<span class="operator">=</span><span class="string">&#x27;slave1&#x27;</span>, MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;slave1&#x27;</span>, MASTER_PORT<span class="operator">=</span><span class="number">3308</span>, MASTER_LOG_FILE<span class="operator">=</span><span class="string">&#x27;mysql-bin.000017&#x27;</span>, MASTER_LOG_POS<span class="operator">=</span><span class="number">1860</span>, MASTER_CONNECT_RETRY<span class="operator">=</span><span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<p>分别开启 <strong>START SLAVE;</strong></p>
<div align=center><img src="../../../../images/2018-4/MySQL_master_slave/db_1.jpg" algin="center"/></div>

<div align=center><img src="../../../../images/2018-4/MySQL_master_slave/db_2.png" algin="center"/></div>

<p><strong>当且仅当两个数据库Slave_IO_Running和Slave_SQL_Running都为 YES才表明状态正常。</strong></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>主主复制只能保证主键不重复，却不能保证主键有序。</li>
<li>当配置完成<strong>Slave_IO_Running、Slave_SQL_Running不全为YES</strong>时，show slave status\G信息中有错误提示，可根据错误提示进行更正。</li>
<li>Slave_IO_Running、Slave_SQL_Running不全为YES时，大多数问题都是数据不统一导致。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL优化</title>
    <url>/MySQL%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>数据库在每个项目中都会用到，现在又分为两个门派，一种<a href="http://baike.baidu.com/link?url=F1B2ducJyF3-AS6F8RbkCx-1y10TqUb0tcFlxpySya025ev87isg4GprakGLkp0RvhYLO6qbgzGBTskhi-iLVM9R6yI9MtAqhHq6qy7VPj6HTfW01Y2bIhIR5O7g1xOYdZ6Zsm_qzvnKGVw5oFSzkK">关系型数据库</a><em>，常见的有MySQL、SQL Server、Oracle、DB2等。另一种是</em>非关系型数据库，也就是NoSQL( Not Only SQL)，常见的NOSQL数据库有Redis 、MongoDB、Cassandra等。数据库的优化直接影响到网站的性能，在这里记录一下MySQL的优化。<div align=center><img src="../../../../images/2017-4-17/MYSQL.jpg" algin="center"/></div></p>
<h1 id="关于MySQL"><a href="#关于MySQL" class="headerlink" title="关于MySQL"></a>关于MySQL</h1><p>MySQL 是一个跨平台的<code>开源</code><strong>关系型数据库</strong>管理系统，目前 MySQL 被广泛地应用在 Internet 上的中小型网站中。由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，许多中小型网站为了降低网站总体拥有成本而选择了 MySQL 作为网站数据库。比如淘宝、京东等知名公司也都在使用。</p>
<p>MySQL的<strong>存储引擎</strong>有分为很多种。MyISAM、InnoDB等。每个引擎的特性都不一样，可以在不同的情况下选择不同的存储引擎。</p>
<h1 id="MySQL的优化"><a href="#MySQL的优化" class="headerlink" title="MySQL的优化"></a>MySQL的优化</h1><p>对于一个小项目来说，MySQL优化与否可能没有那么重要，带来的优化效果也没有那么明显。但是如果面对的是一个千万级的大表、千万级甚至上亿的数据量时，优化是必不可少的。那么要从如下几方面来做优化：</p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>一般情况可以选择MyISAM存储引擎，如果需要事务支持必须使用InnoDB存储引擎。</p>
<blockquote>
<p>MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持以及外部键等高级数据库功能。</p>
</blockquote>
<h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>本着<strong>约定优先于配置</strong>（Convention Over Configuration）的原则，表的命名规则一样很重要。</p>
<blockquote>
<ul>
<li>MySQL数据库、表、字段等名称统一使用小写，单词间用_下划线分隔。</li>
<li>表名和字段名不宜过长（不超过64个字符）。</li>
<li>建议数据库统一设置编码为utf8，不仅仅是为了应付数据库间导入导出过程中、因编码格式不统一而导致的恼人的乱码问题，也是因为utf8是一种万国码（Unicode）。</li>
</ul>
</blockquote>
<h2 id="语句-索引"><a href="#语句-索引" class="headerlink" title="语句+索引"></a>语句+索引</h2><p>索引的合理建立和查询语句的优化可以迅速提升数据库性能。</p>
<p>设计阶段就需要预计QPS（Query Per Second）及数据规模，参考业务场景对数据的要求，合理设计表结构（参考mysql在线DDL问题），甚至违反设计范式做到适当冗余。生产环境分析慢日志，优化语句。索引的设计需要知道索引是怎么用的，比如innodb的加锁机制。</p>
<p>垃圾查询拖慢性能。不合理的schema设计也会导致数据存取慢。索引的作用不必多说，但如innodb下，错的索引带来的可能不只是查询变慢。</p>
<blockquote>
<p>MySQL语句优化是我们最常见也是开发过程中最需要注意的。各种关键字的使用场合、多表之间的关联(据说阿里的要求是关联表不超多三个)、索引的合理使用、批量插入、批量更新、批量删除、临时表的使用等等。</p>
</blockquote>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>当数据库的压力太大时可以将一部分压力转嫁到缓存（我常用的是Redis），其流程如下：</p>
<div align=center><img src="../../../../images/2017-4-17/redis.png" algin="center"/></div>

<h2 id="复制及读写分离"><a href="#复制及读写分离" class="headerlink" title="复制及读写分离"></a>复制及读写分离</h2><p>这个是大多数场景下都是必须的。因为复制可以实现备份、高可用、负载均衡。</p>
<p>其中读写分离可以在应用层做，效率高，也可以用三方工具，如360的atlas。</p>
<h2 id="切分"><a href="#切分" class="headerlink" title="切分"></a>切分</h2><p>切分包括<code>垂直切分</code>和<code>水平切分</code>，实现方式上又包括分库、分表。</p>
<ul>
<li>垂直切分保证业务的独立性，防止不同业务争抢资源，毕竟业务是有优先级的。</li>
<li>水平切分主要用于突破单机瓶颈。除了主主外，只有切分能真正做到将负载分配下去。</li>
<li>切分后也可对不同片数据进行不同优化。如按时间切分，超过一定时间数据不允许修改，就可以引入压缩了，数据传输及读取减少很多。</li>
</ul>
<ul>
<li>根据业务垂直切分。业务内部分库、分表。一般都需要修改应用。除分表外，其余实现不是很复杂。有第三方组件可用，但通用高效又灵活的方式，还是自己写client。</li>
</ul>
<ul>
<li>垂直切分一般都要做，只不过业务粒度大小而已。</li>
<li>分库有是经常用的，就算当前压力小，也尽量分出几个逻辑库出来。等规模上去了，很方便就迁移扩展。</li>
<li>水平拆分有一定难度，但如果将来一定会到这个规模，又可能用到，建议越早做越好。因为对应用的改动较大，而且迁移成本高。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>MySQL总结可以说是： <strong>优化SQL</strong>，<strong>优化结构</strong>，<strong>优化存储</strong>。</p>
<p>对于MySQL的优化我还需要进一步提高，从表的设计建立到后期的维护考虑的问题有很多，每一步都需要注意。没有DBA，只有自己来实现。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL执行计划</title>
    <url>/MySQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>MySQL执行计划，简单的来说，是SQL在数据库中执行时的表现情况，通常用于SQL性能分析，优化等场景。在MySQL使用 <strong>explain</strong> 关键字来查看SQL的执行计划。<div align=center><img src="../../../../images/2018-4/MySQL_explain/mysql-explain.png" algin="center"/></div></p>
<h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>适用于 <em><strong>select</strong></em>、<em><strong>update</strong></em>、<em><strong>insert</strong></em>、<em><strong>replace</strong></em>、<em><strong>delete</strong></em>语句，在需要分析的语句前加<em>EXPLAIN</em>，即可。</p>
<h1 id="EXPLAIN可得到的信息"><a href="#EXPLAIN可得到的信息" class="headerlink" title="EXPLAIN可得到的信息"></a>EXPLAIN可得到的信息</h1><ul>
<li>SQL如何使用索引</li>
<li>关联查询的执行顺序</li>
<li>查询扫描的数据行数</li>
</ul>
<h1 id="读懂执行计划"><a href="#读懂执行计划" class="headerlink" title="读懂执行计划"></a>读懂执行计划</h1><p>例如以下关联查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_item <span class="keyword">JOIN</span> tb_item_desc <span class="keyword">ON</span> tb_item.id<span class="operator">=</span>tb_item_desc.item_id <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="string">&#x27;679533&#x27;</span>;</span><br></pre></td></tr></table></figure>

<div align=center><img src="../../../../images/2018-4/MySQL_explain/eg.png" algin="center"/></div>根据上图可得到执行计划的列信息，下面分析一下每列所表示的信息。
## ID

<ul>
<li>ID列中的数据为一组数字，表示执行Select语句的顺序。</li>
<li>ID值相同时，执行顺序由上至下。</li>
<li>ID值越大优先级越高，越先被执行。</li>
</ul>
<h2 id="SELECT-TYPE"><a href="#SELECT-TYPE" class="headerlink" title="SELECT_TYPE"></a>SELECT_TYPE</h2><p>表示查询中每个Select子句的类型（简单 OR 复杂）。</p>
<ul>
<li><strong>SIMPLE</strong>：不包含子查询或是<em>UNION</em>操作的查询。</li>
<li><strong>PRIMARY</strong>：查询中如果包含任何子查询，那么最外层的查询则被标记为<em>PRIMARY</em>。</li>
<li><strong>SUBQUERY</strong>：<em>SELECT</em> 列表中的子查询。</li>
<li><strong>DEPENDENT SUBQUERY</strong>：被别的查询所依赖的子查询。</li>
<li><strong>UNION</strong>：<em>union</em>操作的第二个或是之后的查询的值为<em>union</em>。</li>
<li><strong>DEPENDENT UNION</strong>：当<em>union</em>作为子查询时，第二或者是第二个后的查询的值。</li>
<li><strong>UNION RESULT</strong>：<em>union</em>产生的结果集。</li>
<li><strong>DERIVED</strong>：出现在<em>from</em>子句中的子查询。</li>
</ul>
<h2 id="TABLE"><a href="#TABLE" class="headerlink" title="TABLE"></a>TABLE</h2><p>输出数据行所在的表的名称或别名。</p>
<ul>
<li>**<code>&lt;unionM,N&gt;</code>*<em>：由ID为M,N查询</em>union*产生的结果集。</li>
<li>**<code>&lt;derivedN&gt;/&lt;subqueryN&gt;</code>**：由ID为N的查询产生的结果。</li>
</ul>
<h2 id="PARTITIONS"><a href="#PARTITIONS" class="headerlink" title="PARTITIONS"></a>PARTITIONS</h2><ul>
<li>对于分区表，显示查询的分区ID。</li>
<li>对于非分区表，显示为NULL。</li>
</ul>
<h2 id="TYPE（类型性能是依次降低）"><a href="#TYPE（类型性能是依次降低）" class="headerlink" title="TYPE（类型性能是依次降低）"></a>TYPE（类型性能是依次降低）</h2><p>该属性表示访问类型,有很多种访问类型。</p>
<ul>
<li><strong>system</strong>：这是const连接类型的一个特例，当查询的表只有一行时使用。</li>
<li><strong>const</strong>：表中有且只有一个匹配的行时使用，如对主键或是唯一索引的查询，这是效率最高的联接方式。</li>
<li><strong>eq_ref</strong>：唯一索引或者是主键索引查找，对于每个索引键，表中只有一条记录与之匹配</li>
<li><strong>ref</strong>：非唯一索引查找，返回匹配某个单独值的所有行。</li>
<li><strong>ref_or_null</strong>：类似于ref类型的查询，但是附加了对NULL值列的查询。</li>
<li><strong>index_merge</strong>：该联接类型表示使用了索引合并优化方法。</li>
<li><strong>range</strong>：索引范围扫描，常见于<em>between</em>、&gt;、&lt;、这样的查询条件。</li>
<li><strong>index</strong>：<em>full index scan</em> 全索引扫描，同ALL的区别是，遍历的是索引树。</li>
<li><strong>all</strong>：<em>full table scan</em> 全表扫描，这是效率最差的联接方式。</li>
</ul>
<h2 id="POSSIBLE-KEYS"><a href="#POSSIBLE-KEYS" class="headerlink" title="POSSIBLE_KEYS"></a>POSSIBLE_KEYS</h2><p>指出MySQL能使用那些索引来优化查询，<strong>查询列所涉及到的列上的索引都会被列出，但不一定会被使用</strong>。</p>
<h2 id="KEY"><a href="#KEY" class="headerlink" title="KEY"></a>KEY</h2><p>显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。</p>
<blockquote>
<p>TIPS：查询中若使用了覆盖索引，则该索引仅出现在key列表中。</p>
</blockquote>
<h2 id="KEY-LEN"><a href="#KEY-LEN" class="headerlink" title="KEY_LEN"></a>KEY_LEN</h2><ul>
<li>表示索引字段的最大可能长度。</li>
</ul>
<ul>
<li>此值的长度有字段定义计算而来，并非数据的实际长度。</li>
</ul>
<h2 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h2><p>表示表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。</p>
<h2 id="ROWS"><a href="#ROWS" class="headerlink" title="ROWS"></a>ROWS</h2><p>表示MySQL通过索引统计的信息，估算出的所需读取的行数。是一个不十分准确的值。</p>
<h2 id="FILTERED"><a href="#FILTERED" class="headerlink" title="FILTERED"></a>FILTERED</h2><p>表示返回结果的行数占需读取行数的百分比，越大越好，也并不十分准确。</p>
<h2 id="EXTRA"><a href="#EXTRA" class="headerlink" title="EXTRA"></a>EXTRA</h2><p>1、<strong>Using index</strong></p>
<p>该值表示相应的<em>Select</em>操作中使用了***覆盖索引(Covering Index)***。</p>
<blockquote>
<p>TIPS：覆盖索引（Covering Index）</p>
<p>MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件包含所有满足查询需要的数据的索引称为 <strong>覆盖索引</strong>（Covering Index）</p>
</blockquote>
<p>注意：如果要使用覆盖索引，一定要注意<em>Select</em>列表中只取出需要的列，不可Select *，因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降。</p>
<p>2、<strong>Using where</strong></p>
<p>表示MySQL服务器在存储引擎受到记录后进行“后过滤”（Post-filter），如果查询未能使用索引，<em>Using where</em>的作用只是提醒我们MySQL将用<em>where</em>子句来过滤结果集。</p>
<p>3、<strong>Using temporary</strong></p>
<p>表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询。</p>
<p>4、<strong>Using filesort</strong></p>
<p>MySQL中无法利用索引完成的排序操作称为“文件排序”。</p>
<p>5、<strong>distinct</strong></p>
<p>优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作。</p>
<p>6、<strong>not exists</strong></p>
<p>使用<em>not exists</em>来优化查询。</p>
<p>7、<strong>select tables optimized away</strong></p>
<p>直接通过索引来获得数据，不用访问表。</p>
<h1 id="执行计划的局限性"><a href="#执行计划的局限性" class="headerlink" title="执行计划的局限性"></a>执行计划的局限性</h1><ul>
<li>EXPLAIN无法展示关于触发器、存储过程的信息或用户自定义函数对查询的影响情况。</li>
<li>EXPLAIN不考虑各种Cache。</li>
<li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作。</li>
<li>部分统计信息是估算的，并非精确值。</li>
<li>早期版本的MySQL只支持对<em>Select</em>语句进行分析。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL清除表空间碎片</title>
    <url>/MySQL%E6%B8%85%E9%99%A4%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%A2%8E%E7%89%87/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>MySQL在数据表使用很长时间后，表上的B-Tree索引可能会碎片化，会降低查询的效率。碎片化的索引可能会以很差或者无序的方式存储在磁盘上，这时就需要对表进行碎片化整理。<span id="more"></span></p>
<h1 id="碎片产生原因"><a href="#碎片产生原因" class="headerlink" title="碎片产生原因"></a>碎片产生原因</h1><p>1、表的存储会出现碎片化，每当删除了一行内容，该段空间就会变为空白、被留空，而在一段时间内的大量删除操作，会使这种留空的空间变得比存储列表内容所使用的空间更大；</p>
<p>2、当执行插入操作时，MySQL会尝试使用空白空间，但如果某个空白空间一直没有被大小合适的数据占用，仍然无法将其彻底占用，就形成了碎片；</p>
<p>3、当MySQL对数据进行扫描时，它扫描的对象实际是列表的容量需求上限，也就是数据被写入的区域中处于峰值位置的部分；</p>
<blockquote>
<p>例：<em>一个表有1万行，每行10字节，会占用10万字节存储空间，执行删除操作，只留一行，实际内容只剩下10字节，但MySQL在读取时，仍看做是10万字节的表进行处理，所以，碎片越多，就会越来越影响查询性能。</em></p>
</blockquote>
<h1 id="查看表碎片大小"><a href="#查看表碎片大小" class="headerlink" title="查看表碎片大小"></a>查看表碎片大小</h1><p>1、查看某个表的碎片大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLE STATUS LIKE &#x27;表名&#x27;;</span><br></pre></td></tr></table></figure>

<p>结果中’<strong>Data_free</strong>’列的值就是碎片大小</p>
<div align=center><img src="../../../../images/2018-5/mysql%E7%A2%8E%E7%89%87%E4%BC%98%E5%8C%96/show-status.png" algin="center"/>

</div>

<p>2、列出所有已经产生碎片的表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select table_schema db, table_name, data_free, engine     </span><br><span class="line">from information_schema.tables </span><br><span class="line">where table_schema not in (&#x27;information_schema&#x27;, &#x27;mysql&#x27;)  and data_free &gt; 0;</span><br></pre></td></tr></table></figure>

<h1 id="清除表碎片"><a href="#清除表碎片" class="headerlink" title="清除表碎片"></a>清除表碎片</h1><p>1、MyISAM表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPTIMIZE TABLE 表名;</span><br></pre></td></tr></table></figure>

<p>2、InnoDB表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ENGINE INNODB;</span><br></pre></td></tr></table></figure>

<p>这其实是一个<em>NULL</em>操作，表面上看什么也不做，实际上重新整理碎片了。当执行优化操作时，实际执行的是一个空的 <em>ALTER</em> 命令，但是这个命令也会起到优化的作用，它会重建整个表，删掉未使用的空白空间。</p>
<p>Engine不同，<em>OPTIMIZE</em> 的操作也不一样。MyISAM 因为索引和数据是分开的，所以 <em>OPTIMIZE</em> 可以整理数据文件，并重排索引。如果针对 <em>INNODB</em> 的表做 <em>OPTIMIZE TABLE</em> 的操作，系统将返回：<em>Table does not support optimize, doing recreate + analyze instead</em>。</p>
<p><strong>OPTIMIZE 操作会暂时锁住表，而且数据量越大，耗费的时间也越长。</strong>它毕竟不是简单查询操作，所以把 OPTIMIZE 命令放在程序中是不妥当的。不管设置的命中率多低，当访问量增大的时候，整体命中率也会上升，这样肯定会对程序的运行效率造成很大影响，比较好的方式就是做个shell，定期检查MySQL中 <code>information_schema</code>.<code>TABLES</code>字段，查看 <em>DATA_FREE</em> 字段，大于0话就表示有碎片。</p>
<h1 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h1><p>清除碎片操作会暂时锁表，数据量越大，耗费的时间越长，可以做个脚本，定期在访问低谷时间执行，例如每月1号凌晨，检查 <em>DATA_FREE</em> 字段，大于自己认为的警戒值的话，就清理一次。</p>
<p><a href="https://blog.csdn.net/xlgen157387/article/details/50728737"><em><strong>MySQL 清除表空间碎片</strong></em></a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis之缓存</title>
    <url>/Mybatis%E4%B9%8B%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Mybatis中有一级缓存和二级缓存，默认情况下一级缓存是开启的，而且是不能关闭的。一级缓存是指SqlSession级别的缓存，当在同一个SqlSession中进行相同的SQL语句查询时，第二次以后的查询不会从数据库查询，而是直接从缓存中获取，一级缓存最多缓存1024条SQL。二级缓存是指可以跨SqlSession的缓存。<div align=center><img src="../../../../images/2018-3/Mybatis/cache.png" algin="center"/></div></p>
<h1 id="Mybatis缓存"><a href="#Mybatis缓存" class="headerlink" title="Mybatis缓存"></a>Mybatis缓存</h1><p>缓存的意义：将用户经常<strong>查询的数据放在缓存（内存）中</strong>，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。</p>
<p><strong>Mybatis提供一级缓存和二级缓存</strong></p>
<ul>
<li>mybatis一级缓存是一个SqlSession级别，sqlsession只能访问自己的一级缓存的数据。</li>
<li>二级缓存是跨sqlSession，是mapper级别的缓存，对于mapper级别的缓存不同的sqlsession是可以共享的。</li>
</ul>
<div align=center><img src="../../../../images/2018-3/Mybatis/cache-index.png" algin="center"/></div>

<h2 id="Mybatis一级缓存"><a href="#Mybatis一级缓存" class="headerlink" title="Mybatis一级缓存"></a>Mybatis一级缓存</h2><p>Mybatis的一级缓存原理：</p>
<div align=center><img src="../../../../images/2018-3/Mybatis/cache-first.png" algin="center"/></div>

<p>第一次发出一个查询sql，sql查询结果写入sqlsession的一级缓存中，缓存使用的数据结构是一个map<code>&lt;key,value&gt;</code></p>
<blockquote>
<p>key：hashcode + sql + sql输入参数 + 输出参数（sql的唯一标识）</p>
<p>value：用户信息</p>
</blockquote>
<p>同一个sqlsession再次发出相同的sql，就从缓存中取，不走数据库。如果两次中间出现commit操作（修改、添加、删除），本sqlsession中的一级缓存区域全部清空，下次再去缓存中查询不到所以要从数据库查询，从数据库查询到再写入缓存。</p>
<p>Mybatis一级缓存值得注意的地方：</p>
<ol>
<li><em>Mybatis默认就是支持一级缓存的，并不需要我们配置。</em></li>
<li><strong>mybatis和spring整合后进行mapper代理开发，不支持一级缓存，mybatis和Spring整合，Spring按照mapper的模板去生成mapper代理对象，模板中在最后统一关闭sqlsession</strong>。</li>
</ol>
<blockquote>
<ul>
<li>在未开启事物的情况之下，每次查询，spring都会关闭旧的sqlSession而创建新的sqlSession，因此此时的一级缓存是没有启作用的。</li>
<li>在开启事物的情况之下，Spring使用ThreadLocal获取当前资源绑定同一个sqlSession，因此此时一级缓存是有效的。</li>
</ul>
</blockquote>
<h2 id="Mybatis二级缓存"><a href="#Mybatis二级缓存" class="headerlink" title="Mybatis二级缓存"></a>Mybatis二级缓存</h2><p>二级缓存原理：</p>
<div align=center><img src="../../../../images/2018-3/Mybatis/cache-2.png" algin="center"/></div>

<p><strong>二级缓存的范围是mapper级别（mapper同一个命名空间）</strong>，mapper以命名空间为单位创建缓存数据结构，结构是map<code>&lt;key、value&gt;</code>。</p>
<h3 id="二级缓存配置"><a href="#二级缓存配置" class="headerlink" title="二级缓存配置"></a>二级缓存配置</h3><p>Mybatis二级缓存需要手动开启，需要在Mybatis的配置文件中配置二级缓存</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 全局配置参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 开启二级缓存 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面已经说了，二级缓存的范围是mapper级别的，因此Mapper如果要使用二级缓存，还需要在对应的映射文件中配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.rainbowhorse.test.dao.TestDataDao&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在mapper中开启二级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>查询结果映射的pojo序列化</p>
<p>mybatis二级缓存需要将查询结果映射的pojo实现 java.io.serializable接口，如果不实现则抛出异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.apache.ibatis.cache.CacheException: Error serializing object.  Cause: java.io.NotSerializableException: com.rainbowhorse.test.po.User</span><br></pre></td></tr></table></figure>

<p>二级缓存可以将内存的数据写到磁盘，存在对象的序列化和反序列化，所以要实现java.io.serializable接口。 如果结果映射的pojo中还包括了pojo，都要实现java.io.serializable接口。</p>
<h3 id="禁用二级缓存"><a href="#禁用二级缓存" class="headerlink" title="禁用二级缓存"></a>禁用二级缓存</h3><p>对于变化频率较高的sql，需要禁用二级缓存：</p>
<p>在statement中设置useCache=false可以禁用当前select语句的二级缓存，即每次查询都会发出sql去查询，默认情况是true，即该sql使用二级缓存。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findOrderListResultMap&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;ordersUserMap&quot;</span> <span class="attr">useCache</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="刷新缓存"><a href="#刷新缓存" class="headerlink" title="刷新缓存"></a>刷新缓存</h3><p>我们的缓存都是在查询语句中配置，而使用增删改的时候，缓存默认就会被清空【刷新了】。缓存其实就是为我们的查询服务的，对于增删改而言，如果我们的缓存保存了增删改后的数据，那么再次读取时就会读到脏数据了！</p>
<p>我们在特定的情况下，还可以单独配置刷新缓存【但不建议使用】flushCache，默认是的true。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;cn.itcast.mybatis.po.User&quot;</span> <span class="attr">flushCache</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">		update user set username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="缓存参数"><a href="#缓存参数" class="headerlink" title="缓存参数"></a>缓存参数</h3><p><strong>mybatis的cache参数只适用于mybatis维护缓存。</strong></p>
<blockquote>
<p>flushInterval（刷新间隔）可以被设置为任意的正整数，而且它们代表一个合理的毫秒形式的时间段。默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新。<br>size（引用数目）可以被设置为任意正整数，要记住你缓存的对象数目和你运行环境的可用内存资源数目。默认值是1024。<br>readOnly（只读）属性可以被设置为true或false。只读的缓存会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false。</p>
</blockquote>
<p>如下例子：<br><code>&lt;cache  eviction=&quot;FIFO&quot;  flushInterval=&quot;60000&quot;  size=&quot;512&quot;  readOnly=&quot;true&quot;/&gt;</code><br>这个更高级的配置创建了一个 FIFO 缓存,并每隔 60 秒刷新,存数结果对象或列表的 512 个引用,而且返回的对象被认为是只读的,因此在不同线程中的调用者之间修改它们会导致冲突。可用的收回策略有, 默认的是 LRU:</p>
<ol>
<li>LRU – 最近最少使用的:移除最长时间不被使用的对象。</li>
<li>FIFO – 先进先出:按对象进入缓存的顺序来移除它们。</li>
<li>SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。</li>
<li>WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。</li>
</ol>
<h1 id="Mybatis和Ehcache整合"><a href="#Mybatis和Ehcache整合" class="headerlink" title="Mybatis和Ehcache整合"></a>Mybatis和Ehcache整合</h1><p><strong>Ehcache是专门用于管理缓存的，Mybatis的缓存交由ehcache管理会更加得当。在mybatis中提供一个cache接口，只要实现cache接口就可以把缓存数据灵活的管理起来</strong>。</p>
<div align=center><img src="../../../../images/2018-3/Mybatis/ehcache.png" algin="center"/></div>

<h2 id="整合jar包"><a href="#整合jar包" class="headerlink" title="整合jar包"></a>整合jar包</h2><ul>
<li>mybatis-ehcache-1.0.2.jar</li>
<li>ehcache-core-2.6.5.jar</li>
</ul>
<p>Ehcache对cache接口的实现类：</p>
<div align=center><img src="../../../../images/2018-3/Mybatis/ehcachecache.png" algin="center"/></div>

<h2 id="ehcache-xml配置信息"><a href="#ehcache-xml配置信息" class="headerlink" title="ehcache.xml配置信息"></a>ehcache.xml配置信息</h2><p>这个xml配置文件是配置<strong>全局的缓存管理方案</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;../config/ehcache.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--diskStore：缓存数据持久化的目录 地址  --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;F:\develop\ehcache&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">defaultCache</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">maxElementsOnDisk</span>=<span class="string">&quot;10000000&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">diskPersistent</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;120&quot;</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果我们Mapper想单独拥有一些特性，需要在mapper.xml中单独配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单位：毫秒 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeToIdleSeconds&quot;</span> <span class="attr">value</span>=<span class="string">&quot;12000&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeToLiveSeconds&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3600&quot;</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 同ehcache参数maxElementsInMemory --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxEntriesLocalHeap&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1000&quot;</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 同ehcache参数maxElementsOnDisk --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxEntriesLocalDisk&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000000&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;memoryStoreEvictionPolicy&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LRU&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="应用场景与局限性"><a href="#应用场景与局限性" class="headerlink" title="应用场景与局限性"></a>应用场景与局限性</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><strong>对查询频率高，变化频率低的数据建议使用二级缓存。</strong></li>
</ul>
<ul>
<li>对于<strong>访问多的查询请求且用户对查询结果实时性要求不高</strong>，此时可采用mybatis二级缓存技术降低数据库访问量，提高访问速度。</li>
</ul>
<p>业务场景比如：</p>
<ul>
<li>耗时较高的统计分析sql</li>
<li>电话账单查询sql等。</li>
</ul>
<p>实现方法如下：<strong>通过设置刷新间隔时间，由mybatis每隔一段时间自动清空缓存，根据数据变化频率设置缓存刷新间隔flushInterval</strong>，比如设置为30分钟、60分钟、24小时等，根据需求而定。</p>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>mybatis二级缓存对细粒度的数据级别的缓存实现不好，比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用mybatis的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，<strong>因为mybaits的二级缓存区域以mapper为单位划分，当一个商品信息变化会将所有商品信息的缓存数据全部清空</strong>。解决此类问题需要在业务层根据需求对数据有针对性缓存。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>Mybatis的一级缓存是SqlSession级别的。只能访问自己的sqlSession内的缓存。如果Mybatis与Spring整合了，Spring会自动关闭sqlSession的。所以一级缓存会失效。</li>
<li>一级缓存的原理是map集合，Mybatis默认就支持一级缓存。</li>
<li><strong>二级缓存是Mapper级别的。只要在Mapper namespace下都可以使用二级缓存。需要自己手动去配置二级缓存。</strong></li>
<li>Mybatis的缓存我们可以使用Ehcache框架来进行管理，Ehcache实现Cache接口就代表使用Ehcache来环境Mybatis缓存。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5aa655d6518825556020924e#comment"><em><strong>Mybatis【逆向工程，缓存，代理】知识要点</strong></em></a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx日志无法轮转</title>
    <url>/Nginx%E6%97%A5%E5%BF%97%E6%97%A0%E6%B3%95%E8%BD%AE%E8%BD%AC/</url>
    <content><![CDATA[<h1 id="症状"><a href="#症状" class="headerlink" title="症状"></a>症状</h1><p>Nginx刚启动后日志记录正常，一段时间后，Nginx会把已产生的日志压缩为<code>.gz</code>文件。但是一旦压缩后，就不再记录新日志到新生成的<code>access.log</code>文件，但日志文件存在，里面却没有任何日志。旧的日志压缩后没有问题，自从压缩后，新的文件再也不记录新日志了(发现Nginx会很消耗内存，估计日志都存在内存里，不写文件了)。</p>
<div align=center><img src="../../../../images/2021/4-6/nginx_bug_1.png" algin="center"/></div>

<p>我们的Nginx部署在k8s中，查看Nginx的配置没有发现任何问题</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line">worker_processes  4;</span><br><span class="line"></span><br><span class="line">error_log  /app/openresty/nginx/logs/error.log  error;</span><br><span class="line">pid        /app/openresty/nginx/logs/nginx.pid;</span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 65536 ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    include       custom_upstream.conf;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    log_format  main  <span class="string">&#x27;$remote_addr|$remote_user|[$time_local]|&quot;$request&quot;&#x27;</span></span><br><span class="line">                      <span class="string">&#x27;|$status|$request_time|$body_bytes_sent|&quot;$http_referer&quot;&#x27;</span></span><br><span class="line">                <span class="string">&#x27;|&quot;$http_user_agent&quot;|&quot;$http_x_forwarded_for&quot;|$upstream_response_time|$upstream_status&#x27;</span>;    </span><br><span class="line">    access_log  /app/openresty/nginx/logs/access.log  main;</span><br><span class="line">    </span><br><span class="line">    server_tokens   off;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    tcp_nopush      on;</span><br><span class="line">    tcp_nodelay     on;</span><br><span class="line">    client_max_body_size 100m;</span><br><span class="line">    client_header_buffer_size 100m;</span><br><span class="line">    keepalive_timeout  60;</span><br><span class="line">    proxy_buffering off;</span><br><span class="line">    gzip on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        listen 443 ssl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        include       custom_location.conf;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location = /nstats &#123;</span><br><span class="line">            check_status;</span><br><span class="line">            access_log      off;</span><br><span class="line">            allow           10.116.0.0/16;</span><br><span class="line">            allow           10.110.0.0/16;</span><br><span class="line">            allow           10.117.0.0/16;</span><br><span class="line">            allow           10.150.0.0/16;</span><br><span class="line">            allow           100.0.0.0/8;</span><br><span class="line">            allow           10.0.0.0/8;</span><br><span class="line">            deny            all;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>经查询资料在<code>stackoverflow</code>发现了类似的问题，见链接：<a href="https://stackoverflow.com/questions/9552930/nginx-cannot-write-into-access-log">https://stackoverflow.com/questions/9552930/nginx-cannot-write-into-access-log</a></p>
<p>原因是当Nginx压缩文件后，需要给master进程发送USR1信号后重新打开文件。</p>
<p>于是查看了Nginx的进程ID为33</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mwopr@k8s-opc-openapi-nginx-77787494c5-c77s8 logs]$ cat nginx.pid </span><br><span class="line">33</span><br></pre></td></tr></table></figure>

<p>当执行重新打开log文件命令时提示没有权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mwopr@k8s-opc-openapi-nginx-77787494c5-c77s8 logs]$ kill -USR1 33</span><br><span class="line">bash: kill: (33) - Operation not permitted</span><br></pre></td></tr></table></figure>

<p>这个时候恍然大悟，登陆shell的默认用户是<code>mwopr</code>，没有权限执行<code>kill</code>命令，需要用<code>root</code>用户执行，当切换为<code>root</code>用户后，执行<code>kill</code>命令成功且日志可以正常写入。</p>
<div align=center><img src="../../../../images/2021/4-6/nginx_bug_2.png" algin="center"/></div>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>原文：<a href="http://nginx.org/en/docs/control.html">http://nginx.org/en/docs/control.html</a></p>
<p>Nginx可以通过信号进行控制。对应Linux系统就是用<code>kill</code>命令。</p>
<p>master进程id默认写入到<code>/nginx/logs/nginx.pid</code>文件中。文件也可以在<code>nginx.conf</code>文件中指定。master进程支持以下信号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill -TERM pid # 快速停止master进程。 </span><br><span class="line">kill -QUIT pid # 优雅的停止。 </span><br><span class="line">kill -HUB pid # 改变配置文件。开启一个新的worker进程处理，优雅的停止老的worker进程。相当于nginx -s reload </span><br><span class="line">kill -USR1 pid # 重新打开log文件。-s reopen命令 </span><br><span class="line">kill -USR2 pid # 升级可执行文件。热部署 </span><br><span class="line">kill -WINCH pid # 优雅的关闭worker进程。</span><br></pre></td></tr></table></figure>

<p>每个worker进程也可以接收信号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill -TERM pid # 快速关闭worker进程 </span><br><span class="line">kill -QUIT pid # 优雅退出 </span><br><span class="line">kill -USR1 pid # 重新打开日志文件,先mv一个，再去执行这个命令。-s reopen命令</span><br></pre></td></tr></table></figure>

<p>日志轮转</p>
<ol>
<li>重命名log文件。</li>
<li>给master进程发送USR1信号。</li>
<li>重新打开文件。</li>
</ol>
<blockquote>
<p>Rotating Log-files</p>
<p>In order to rotate log files, they need to be renamed first. After that USR1 signal should be sent to the master process. The master process will then re-open all currently open log files and assign them an unprivileged user under which the worker processes are running, as an owner. After successful re-opening, the master process closes all open files and sends the message to worker process to ask them to re-open files. Worker processes also open new files and close old files right away. As a result, old files are almost immediately available for post processing, such as compression.</p>
</blockquote>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx条件中的或、与</title>
    <url>/Nginx%E6%9D%A1%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%88%96%E3%80%81%E4%B8%8E/</url>
    <content><![CDATA[<p>在公司的编程马拉松中前端项目部署在<code>NG</code>的镜像中，其中有个需求是通过浏览器访问时，若请求是前端资源则返回前端页面，如果请求的是后端接口则返回后端响应。如：浏览器访问  <a href="http://abc.com/apis/name">http://abc.com/apis/name</a> 时，有可能是前端页面路径，也有可能为后端接口路径。通过<del>NG</del>的条件判断可以实现此需求。<div align=center><img width="500" height="300" src="../../../../images/2021/4-6/nginx-and-or.jpg" algin="center"/></div><span id="more"></span></p>
<h2 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h2><table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">=</td>
<td align="center">字符串比较<strong>相等</strong></td>
</tr>
<tr>
<td align="center">!=</td>
<td align="center">字符串比较<strong>不相等</strong></td>
</tr>
<tr>
<td align="center">~</td>
<td align="center">符合指定正则表达式时返回<code>true</code>（匹配时<strong>区分大小写</strong>）</td>
</tr>
<tr>
<td align="center">~*</td>
<td align="center">符合指定正则表达式时返回<code>true</code>（匹配时<strong>不区分大小写</strong>）</td>
</tr>
<tr>
<td align="center">!~</td>
<td align="center">不符合指定正则表达式时返回<code>true</code>（匹配时<strong>区分大小写</strong>）</td>
</tr>
<tr>
<td align="center">!~*</td>
<td align="center">不符合指定正则表达式时返回<code>true</code>（匹配时<strong>不区分大小写</strong>）</td>
</tr>
</tbody></table>
<p><code>NG</code>中的表达式和大多数语言一样</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">if</span> (&lt;condition1&gt;) &#123;</span><br><span class="line">    <span class="comment"># do something1</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="attribute">if</span> (&lt;condition2&gt;) &#123;</span><br><span class="line">    <span class="comment"># do something2</span></span><br><span class="line">    <span class="comment"># return;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ol>
<li>不支持多条件表达式</li>
<li>不支持嵌套</li>
<li>不支持else</li>
</ol>
<p>在NG的条件表达式中没有表达式没有直接”或“、“与”的语法，需要<code>存储变量的状态</code>来实现“或”、“与”的效果。</p>
<h2 id="或"><a href="#或" class="headerlink" title="或"></a>或</h2><h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置flag的初始值</span></span><br><span class="line"><span class="attribute">set</span> $flag <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="attribute">if</span> (&lt;condition1&gt;) &#123;</span><br><span class="line">    <span class="attribute">set</span> $flag <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">if</span> (&lt;condition2&gt;) &#123;</span><br><span class="line">    <span class="attribute">set</span> $flag <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 满足 condition1或condition2其中一个条件则会执行</span></span><br><span class="line"><span class="attribute">if</span> ($flag = <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述条件表达式类似<code>Java</code>中的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (&lt;condition1&gt; || &lt;condition2&gt;) &#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><p>在判断变量值时，可以直接用<code>|</code>判断</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 请求方式为GET、POST、PUT、DELETE其中一种</span></span><br><span class="line"><span class="attribute">if</span> ($request_method <span class="regexp">~ (GET|POST|PUT|DELETE))</span> &#123;</span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="与"><a href="#与" class="headerlink" title="与"></a>与</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置flag的初始值</span></span><br><span class="line"><span class="attribute">set</span> $flag <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="attribute">if</span> (&lt;condition1&gt;) &#123;</span><br><span class="line">    <span class="attribute">set</span> $flag <span class="string">&quot;<span class="variable">$&#123;flag&#125;</span>1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">if</span> (&lt;condition2&gt;) &#123;</span><br><span class="line">    <span class="attribute">set</span> $flag <span class="string">&quot;<span class="variable">$&#123;flag&#125;</span>2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时满足condition1与condition2时执行</span></span><br><span class="line"><span class="attribute">if</span> ($flag = <span class="string">&quot;12&quot;</span>) &#123;</span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条件组合"><a href="#条件组合" class="headerlink" title="条件组合"></a>条件组合</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置flag的初始值</span></span><br><span class="line"><span class="attribute">set</span> $flag <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或 的关系</span></span><br><span class="line"><span class="attribute">if</span> (&lt;condition0&gt;) &#123;</span><br><span class="line">    <span class="attribute">set</span> $flag <span class="string">&quot;1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">if</span> (&lt;condition1&gt;) &#123;</span><br><span class="line">    <span class="attribute">set</span> $flag <span class="string">&quot;1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 与 的关系</span></span><br><span class="line"><span class="attribute">if</span> (&lt;condition2&gt;) &#123;</span><br><span class="line">    <span class="attribute">set</span> $flag <span class="string">&quot;<span class="variable">$&#123;flag&#125;</span>2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">if</span> (&lt;condition3&gt;) &#123;</span><br><span class="line">    <span class="attribute">set</span> $flag <span class="string">&quot;<span class="variable">$&#123;flag&#125;</span>3&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或(condition0、condition1) 与(condition2、condition3)</span></span><br><span class="line"><span class="attribute">if</span> ($flag = <span class="string">&quot;123&quot;</span>) &#123;</span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>flag初始值为空值，若想执行<em>do something</em>逻辑。</p>
<ol>
<li>或：condition0、condition1只需满足一项；</li>
<li>与：condition2、condition3需要同时满足；</li>
</ol>
</blockquote>
<h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p>回到文章描述的需求，可以做如下配置即可实现：当请求前端域名时，满足一定条件直接负载到后端接口获取响应。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">set</span> $flag <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment"># 限定请求方式</span></span><br><span class="line">    <span class="attribute">if</span> ($request_method <span class="regexp">~ ^(GET|POST|PUT|DELETE)$)</span> &#123;</span><br><span class="line">       <span class="attribute">set</span> $flag <span class="string">&quot;<span class="variable">$&#123;flag&#125;</span>1&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment"># 响应码不为400</span></span><br><span class="line">    <span class="attribute">if</span> ($status != <span class="number">400</span>) &#123;</span><br><span class="line">       <span class="attribute">set</span> $flag <span class="string">&quot;<span class="variable">$&#123;flag&#125;</span>2&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment"># 请求uri不为/（为/表示请求域名，直接跳转主页）</span></span><br><span class="line">    <span class="attribute">if</span> ($uri != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">       <span class="attribute">set</span> $flag <span class="string">&quot;<span class="variable">$&#123;flag&#125;</span>3&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 满足以上条件时将请求代理后后端</span></span><br><span class="line">    <span class="attribute">if</span> ($flag = <span class="string">&quot;123&quot;</span>) &#123;</span><br><span class="line">       <span class="attribute">proxy_pass</span> http://bcmls-api.sit.rainbowhorse.com;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span>   html;</span><br><span class="line">    <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>PG与MySQL选型分析</title>
    <url>/PG%E4%B8%8EMySQL%E9%80%89%E5%9E%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>PostgreSQL(简称pg)是近几年增长率较快的开源数据库，很多企业由原来的MySQL转向pg，在这里对比这两大开源关系型数据库的优劣，以便使用时快速选型。</p>
<div align=center><img width="450" height="200" src="../../../../images/2018-8/pg-vs-mysql/pg_vs_mysql.jpg" algin="center"/>
</div>    
<span id="more"></span>
# PG与MySQL的一些特性对比

<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">PG</th>
<th align="center">MySQL</th>
</tr>
</thead>
<tbody><tr>
<td align="center">口号性特点</td>
<td align="center">最先进的开源数据库</td>
<td align="center">最流行的开源数据库</td>
</tr>
<tr>
<td align="center">SQL编程能力</td>
<td align="center">强大的SQL能力，包括丰富的统计函数和统计分析，对BI有很好的支持</td>
<td align="center">没有强大的统计功能支持</td>
</tr>
<tr>
<td align="center">数据类型</td>
<td align="center">丰富的数据类型支持，包括地理信息、几何图形、json、数组等，json也可以建立索引</td>
<td align="center">在地理信息支持度上不如PG，不支持几何图形等数据类型</td>
</tr>
<tr>
<td align="center">事务能力</td>
<td align="center">完整的ACID事务支持</td>
<td align="center">不是完整的支持ACID事务特性</td>
</tr>
<tr>
<td align="center">join</td>
<td align="center">支持nested-loop, sort-merge, hash三种类型</td>
<td align="center">只支持nested-loop</td>
</tr>
<tr>
<td align="center">Text类型</td>
<td align="center">没有长度限制，可以直接访问，可以索引，可以全文索引</td>
<td align="center">有长度限制</td>
</tr>
<tr>
<td align="center">复杂查询</td>
<td align="center">支持窗口函数，支持递归，支持with语句</td>
<td align="center">不支持窗口函数、递归等</td>
</tr>
<tr>
<td align="center">索引</td>
<td align="center">多种索引类型，包括b-tree，hash，gin，gist等，可以对模糊查询、正则表达式、地理信息系统等建立索引</td>
<td align="center">主要是b-tree索引</td>
</tr>
<tr>
<td align="center">数据复制</td>
<td align="center">支持同步复制，支持流复制</td>
<td align="center">支持异步复制</td>
</tr>
<tr>
<td align="center">查询优化器</td>
<td align="center">功能更强大，对子查询的支持更高效</td>
<td align="center">子查询效率不高</td>
</tr>
<tr>
<td align="center">7*24</td>
<td align="center">隔一段时间需要进行VACUUM</td>
<td align="center">适用7*24</td>
</tr>
<tr>
<td align="center">性能和适用场景</td>
<td align="center">复杂查询</td>
<td align="center">简单业务场景，更高的TPS</td>
</tr>
<tr>
<td align="center">运维资源</td>
<td align="center">专业DBA相对较少</td>
<td align="center">众多DBA有丰富的运维经验</td>
</tr>
<tr>
<td align="center">大小写</td>
<td align="center">大小写敏感</td>
<td align="center">大小写不敏感</td>
</tr>
<tr>
<td align="center">行大小限制</td>
<td align="center">无限制</td>
<td align="center">65535</td>
</tr>
</tbody></table>
<h1 id="PG存在的问题和解决方案"><a href="#PG存在的问题和解决方案" class="headerlink" title="PG存在的问题和解决方案"></a>PG存在的问题和解决方案</h1><table>
<thead>
<tr>
<th>序号</th>
<th>问题描述</th>
<th>问题分析</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>主从同步WAL方式，主库挂掉，从库有时会启动失败，或者很慢</td>
<td>应该是主库没有保留足够远的xlog数据，导致主从时间线不一致</td>
<td>主库的wal_keep_segments要设置的足够大，个人推荐要保证允许从库挂48小时：wal_keep_segments=（48小时*log增量大小)/16M</td>
</tr>
<tr>
<td>2</td>
<td>在大数据量情况下，PG对地理位置信息（附近客户）的查询效率较慢</td>
<td>关系数据库在处理大数据方面天然有劣势</td>
<td>可以进行分库处理，尽量保证单库的数据量在PG的处理能力之内；如果效率还满足不了，采用ES来处理</td>
</tr>
<tr>
<td>3</td>
<td>WAL从库只能是只读的，报表比较难处理</td>
<td>如果是双主或者是多主，数据同步是大问题</td>
<td>根据业务进行调整，业务架构不需要双主，BI对从库只有读的需求</td>
</tr>
<tr>
<td>4</td>
<td>基于XID的MVCC实现机制，导致需要定时触发VACUUM，导致性能的抖动</td>
<td>基于MVCC的方式导致会产生垃圾，这些垃圾需要在合适的时间被回收</td>
<td>这个需要根据实际情况调整回收的策略，需要DBA配合调优；就像JVM的GC一样</td>
</tr>
<tr>
<td>5</td>
<td>大小写敏感，这对于习惯于原来大小写不敏感的编程方式，可能会很不习惯</td>
<td>PG对对象和数据都是大小写敏感的</td>
<td>对象的大小写敏感问题：PG在分析SQL脚本时，对不加双引号的所有对象名转化为小写字母；数据的大小写敏感问题：可以在存储的时候进行转换，或者查询的时候进行转换，可能需要配合建立表达式索引</td>
</tr>
<tr>
<td>6</td>
<td>MVCC机制带来的SSD写放大和索引写放大</td>
<td>支持并发读写的数据库都会有写放大问题，不是PG独有</td>
<td>PG的HOT技术，以及基于Heap的存储技术，对写入和索引可以调优写放大的问题；实测也部分验证了这一点</td>
</tr>
<tr>
<td>7</td>
<td>PG的复制低效，有写放大</td>
<td></td>
<td>PG的流式复制复制非常高效，支持流的加密和压缩；并且从9.4开始支持逻辑复制</td>
</tr>
<tr>
<td>8</td>
<td>备库的MVCC支持较差，查询会与恢复堵塞</td>
<td></td>
<td>基于物理复制或逻辑复制，只要备库拿来使用，都有可能出现查询与恢复冲突的情况。PG对于冲突的处理非常的人性化，你可以选择恢复优先 or 查询优先，设置时间窗口即可。同时PG还支持备库的QUERY反馈机制，主库可以根据备库的QUERY，控制垃圾回收的延迟窗口，避免QUERY和垃圾回收的冲突。</td>
</tr>
<tr>
<td>9</td>
<td>跨版本升级较难，跨版本不支持复制</td>
<td></td>
<td>现在的PG对大版本升级已经有很好的支持</td>
</tr>
<tr>
<td>10</td>
<td>调优比较复杂</td>
<td>PG的调优参数较多，各个参数还有联动</td>
<td>补充专业DBA，专业指导，积累经验</td>
</tr>
</tbody></table>
<p>部分问题可在<em><a href="https://yq.aliyun.com/articles/58421">https://yq.aliyun.com/articles/58421</a></em>查看。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>pg</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据过期策略</title>
    <url>/Redis%E6%95%B0%E6%8D%AE%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Redis作为一个高性能的内存NoSQL数据库，其容量受到最大内存限制的限制。为了防止一次性清理大量过期Key导致Redis服务受影响，Redis只在空闲时清理过期Key。<div align=center><img src="../../../../images/2018-4/redisKeyExpire/redis.jpg"/></div></p>
<h1 id="Redis过期时间"><a href="#Redis过期时间" class="headerlink" title="Redis过期时间"></a>Redis过期时间</h1><h2 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h2><p>redis有四种命令可以用于设置键的生存时间和过期时间：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">EXPIRE <span class="tag">&lt;<span class="name">KEY</span>&gt;</span> <span class="tag">&lt;<span class="name">TTL</span>&gt;</span> : 		将键的生存时间设为 ttl 秒</span><br><span class="line">PEXPIRE <span class="tag">&lt;<span class="name">KEY</span>&gt;</span> <span class="tag">&lt;<span class="name">TTL</span>&gt;</span> :		将键的生存时间设为 ttl 毫秒</span><br><span class="line">EXPIREAT <span class="tag">&lt;<span class="name">KEY</span>&gt;</span> <span class="tag">&lt;<span class="name">timestamp</span>&gt;</span> :	将键的过期时间设为 timestamp 所指定的秒数时间戳</span><br><span class="line">PEXPIREAT <span class="tag">&lt;<span class="name">KEY</span>&gt;</span> <span class="tag">&lt;<span class="name">timestamp</span>&gt;</span>: 	将键的过期时间设为 timestamp 所指定的毫秒数时间戳.</span><br></pre></td></tr></table></figure>

<p><strong>返回值</strong></p>
<p>一个整数值<strong>1或0</strong>，如下：</p>
<ul>
<li>如果<strong>成功</strong>地为该键设置了超时时间，<strong>返回 1</strong></li>
<li>如果键<strong>不存在或无法设置</strong>超时时间，<strong>返回 0</strong></li>
</ul>
<h2 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h2><p><strong>redis中key的过期时间和生存时间保存方式</strong>：在数据库结构redisDb中的expires字典中保存了数据库中所有键的过期时间，称expire这个字典为过期字典。<br>（1）过期字典是一个指针，指向键空间的某个键对象。<br>（2）过期字典的值是一个longlong类型的整数，这个整数保存了键所指向的数据库键的过期时间–一个毫秒级的 UNIX 时间戳。</p>
<p>下图是一个带过期字典的数据库例子：<div align=center><img src="../../../../images/2018-4/redisKeyExpire/e1.png"/></div></p>
<p>从以上结构中可以看到expire字典(过期字典)和dict字典（数据库键空间，保存着数据库中所有键值对）是并列的，由此可见expire字典的重要性。</p>
<h2 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h2><p><strong>PERSIST</strong>命令可以移除一个键的过期时间：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> message <span class="string">&quot;hello&quot;</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expire message <span class="number">60</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl message</span><br><span class="line">(integer) <span class="number">54</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; persist message</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl message</span><br><span class="line">(integer) <span class="literal">-1</span></span><br></pre></td></tr></table></figure>

<p>persist命令就是expire命令的反命令，这个函数在过期字典中查找给定的键,并从过期字典中移除。<br>比如在数据库当前状态(如上图所示)，当给book这个key移除过期时间：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis&gt; persist book</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>数据库将更新成如下状态：<div align=center><img src="../../../../images/2018-4/redisKeyExpire/e2.png"/></div></p>
<p>可以从图中看到,当PERSIST book命令执行之后,过期字典中的 book 键消失了。</p>
<h2 id="计算并返回剩余生存时间"><a href="#计算并返回剩余生存时间" class="headerlink" title="计算并返回剩余生存时间"></a>计算并返回剩余生存时间</h2><p><strong>ttl</strong>命令以<strong>秒为单位</strong>返回指定键的剩余生存时间。<strong>pttl</strong>以<strong>毫秒</strong>返回。两个命令都是通过计算当前时间和过期时间的差值得到剩余生存期的。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> name rainbowhorse</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expire name <span class="number">60</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl name</span><br><span class="line">(integer) <span class="number">57</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl name</span><br><span class="line">(integer) <span class="number">27</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; pttl name</span><br><span class="line">(integer) <span class="number">23839</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>

<h1 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h1><p>如果一个键是过期的，它的怎么从内存中消失的，是什么时候被删除的？</p>
<p>redis有三种不同的删除策略：</p>
<ul>
<li><strong>定时删除</strong>。每隔一段时间，对expires字典进行检查，删除里面的过期键。</li>
</ul>
<ul>
<li><strong>立即删除</strong>。在设置键的过期时间时，创建一个回调事件，当过期时间达到时，由时间处理器自动执行键的删除操作。</li>
<li><strong>惰性删除</strong>。键过期了就过期了，不管。每次从dict字典中按key取值时，先检查此key是否已经过期，如果过期了就删除它，并返回nil，如果没过期，就返回键值。</li>
</ul>
<p>由此可见，第二种为被动删除，第一种和第三种为主动删除，且第一种实时性更高。下面对这三种删除策略进行具体分析。</p>
<h2 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h2><ul>
<li>含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除</li>
<li>优点：保证内存被尽快释放</li>
<li>缺点：<ul>
<li>若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key</li>
<li>定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重</li>
<li>没人用</li>
</ul>
</li>
</ul>
<h2 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h2><ul>
<li>含义：每隔一段时间执行一次删除(在redis.conf配置文件设置hz，1s刷新的频率)过期key操作</li>
<li>优点：<ul>
<li>通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用–处理”定时删除”的缺点</li>
<li>定期删除过期key–处理”惰性删除”的缺点</li>
</ul>
</li>
<li>缺点<ul>
<li>在内存友好方面，不如”定时删除”</li>
<li>在CPU时间友好方面，不如”惰性删除”</li>
</ul>
</li>
<li>难点<ul>
<li>合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）（这个要根据服务器运行情况来定了）</li>
</ul>
</li>
</ul>
<p>定期删除可以通过：</p>
<ul>
<li>第一、配置redis.conf 的hz选项，默认为10 （即1秒执行10次，100ms一次，值越大说明刷新频率越快，最Redis性能损耗也越大） </li>
<li>第二、配置redis.conf的maxmemory最大值，当已用内存超过maxmemory限定时，就会触发主动清理策略</li>
</ul>
<h2 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h2><ul>
<li>含义：key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。</li>
<li>优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）</li>
<li>缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）</li>
</ul>
<p><strong>定时删除和定期删除为主动删除</strong>：Redis会定期主动淘汰一批已过去的key。</p>
<p><strong>惰性删除为被动删除</strong>：用到的时候才会去检验key是不是已过期，过期就删除。</p>
<h2 id="redis使用的策略"><a href="#redis使用的策略" class="headerlink" title="redis使用的策略"></a>redis使用的策略</h2><p>redis使用的过期键值删除策略是：<strong>惰性删除加上定期删除，两者配合使用</strong>。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul>
<li>不要放垃圾数据，及时清理无用数据。实验性的数据和下线的业务数据及时删除。</li>
<li>key尽量都设置过期时间。对具有时效性的key设置过期时间，通过redis自身的过期key清理策略来降低过期key对于内存的占用，同时也能够减少业务的麻烦，不需要定期手动清理了。</li>
<li>单Key不要过大。给用户排查问题时遇到过单个string的value有43M的，也有一个list 100多万个大成员占了1G多内存的。这种key在get的时候网络传输延迟会比较大，需要分配的输出缓冲区也比较大，在定期清理的时候也容易造成比较高的延迟. 最好能通过业务拆分，数据压缩等方式避免这种过大的key的产生。</li>
<li>不同业务如果公用一个业务的话，最好使用不同的逻辑db分开。从上面的分析可以看出，Redis的过期Key清理策略和强制淘汰策略都会遍历各个db。将key分布在不同的db有助于过期Key的及时清理。另外不同业务使用不同db也有助于问题排查和无用数据的及时下线。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/9352d20fb2e0?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation"><em><strong>redis的过期时间和过期删除机制</strong></em></a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ(三)—消息幂等</title>
    <url>/RocketMQ-%E4%B8%89-%E2%80%94%E6%B6%88%E6%81%AF%E5%B9%82%E7%AD%89/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在MQ中，<code>Producer</code>和<code>Consumer</code>因为各种原因会进行消息重试处理，在消费消息时，会按照一定规则推送消息到消费端进行消息消费。既然有重试，那么就少不了<strong>幂等</strong>。<div align=center><img width="220" height="160" src="../../../../images/2020/1-4/Idempotent.png" algin="center"/></div></p>
<h1 id="幂等概念"><a href="#幂等概念" class="headerlink" title="幂等概念"></a>幂等概念</h1><p>在消息重试多次时，消费端对该重复消息消费多次与消费一次的结果是相同的，并且多次消费没有对系统产生副作用，那么就称这个过程是消息幂等的。</p>
<blockquote>
<p>例如：支付场景下，消费者消费扣款消息，对一笔订单进行扣款操作，该扣款操作需要扣除10元。</p>
<p>这个扣款操作重复多次与执行一次的效果相同，只进行一次真实扣款，用户的扣款记录中对应该笔订单的只有一条扣款流水。不会多扣。那么可以说这个扣款操作是符合要求的，这个消费过程是消息幂等的。</p>
</blockquote>
<h1 id="消息幂等的场景"><a href="#消息幂等的场景" class="headerlink" title="消息幂等的场景"></a>消息幂等的场景</h1><h2 id="Producer发送消息重复"><a href="#Producer发送消息重复" class="headerlink" title="Producer发送消息重复"></a>Producer发送消息重复</h2><p>​        生产者发送消息时，消息成功投递到<code>broker</code>，但此时发生网络闪断或者生产者down掉，导致<code>broker</code>发送ACK失败。此时生产者由于未能收到消息发送响应，认为发送失败，因此尝试重新发送消息到<code>broker</code>。当消息发送成功后，在<code>broker</code>中就会存在两条相同内容的消息，最终消费者会拉取到两条内容一样并且<code>Message ID</code>也相同的消息，因此造成了消息的重复。</p>
<h2 id="Consumer消费时重复"><a href="#Consumer消费时重复" class="headerlink" title="Consumer消费时重复"></a>Consumer消费时重复</h2><p>​        消费消息时同样会出现重复消费的情况。当消费者在处理业务完成返回消费状态给<code>broker</code>时，由于网络闪断等异常情况导致未能将消费完成的<code>CONSUME_SUCCESS</code>状态返回给<code>broker</code>。<code>broker</code>为了保证消息被至少消费一次的语义，会在网络环境恢复之后再次投递该条被处理的消息，最终造成消费者多次收到内容一样并且<code>Message ID</code>也相同的消息，造成了消息的重复。</p>
<p>所以，无论是发送时重复还是消费时重复，最终的效果均为消费者消费时收到了重复的消息，可以推论出：<strong>只需要在消费者端统一进行幂等处理就能够实现消息幂等。</strong></p>
<h1 id="实现幂等方式"><a href="#实现幂等方式" class="headerlink" title="实现幂等方式"></a>实现幂等方式</h1><h2 id="消息幂等两要素"><a href="#消息幂等两要素" class="headerlink" title="消息幂等两要素"></a>消息幂等两要素</h2><ul>
<li>幂等令牌</li>
<li>处理唯一性的确保</li>
</ul>
<p>必须保证存在幂等令牌的情况下保证业务处理结果的唯一性，才认为幂等实现是成功的。</p>
<h2 id="幂等令牌"><a href="#幂等令牌" class="headerlink" title="幂等令牌"></a>幂等令牌</h2><p>幂等令牌是生产者和消费者两者中的既定协议，在业务中通常是具备唯一业务标识的字符串，如：订单号、流水号等。且一般由生产者端生成并传递给消费者端。</p>
<h2 id="处理唯一性的确保"><a href="#处理唯一性的确保" class="headerlink" title="处理唯一性的确保"></a>处理唯一性的确保</h2><p><strong>服务端应当采用一定的策略保证同一个业务逻辑一定不会重复执行成功多次。</strong>如：使用支付宝进行支付，买一个产品支付多次只会成功一笔。<strong>较为常用的方式是采用缓存去重并且通过对业务标识添加数据库的唯一索引实现幂等。</strong></p>
<blockquote>
<p>具体的思路为：如支付场景下，支付的发起端生成了一个支付流水号，服务端处理该支付请求成功后，数据持久化成功。由于表中对支付流水添加了唯一索引，因此当重复支付时会因为唯一索引的存在报错 <strong>duplicate entry</strong>，服务端的业务逻辑捕获该异常并返回调用侧“重复支付”提示。这样就不会重复扣款。</p>
<p>在上面场景的基础上，还可以引入Redis等缓存组件实现去重：当支付请求打到服务端，首先去缓存进行判断，根据 <em>key=“支付流水号”</em> 去get存储的值，如果返回为空，表明是首次进行支付操作同时将当前的支付流水号作为key、value可以为任意字符串通过<code>set(key, value, expireTime)</code>存储在redis中。当重复的支付请求到来时，尝试进行*get(支付流水号)*操作，这个操作会命中缓存，因此可以认为该请求是重复的支付请求，服务端业务将重复支付的业务提示返回给请求方。</p>
</blockquote>
<p><strong>由于一般都会在缓存使用过程中设置过期时间，缓存可能会失效从而导致请求穿透到持久化存储中(如：MySQL)。因此不能因为引入缓存而放弃使用唯一索引，将二者结合在一起是一个比较好的方案。</strong></p>
<h1 id="RocketMQ下的消息幂等"><a href="#RocketMQ下的消息幂等" class="headerlink" title="RocketMQ下的消息幂等"></a>RocketMQ下的消息幂等</h1><p>RocketMQ作为一款高性能的消息中间件，能够保证消息不丢失但是不能保证消息不重复。</p>
<blockquote>
<p>如果RMQ实现消息去重其实也是可以的，但是考虑到对高可用以及高性能的影响就放弃了。如果RMQ做服务端消息去重，就要对消息做额外的rehash、排序等操作，这会花费较大的空间及时间等代价，收益并不明显。所以RMQ就将消息幂等交给了业务方处理。</p>
</blockquote>
<p>在RMQ中，每条消息都会有一个<code>MessageID</code>，那么能否用该ID作为去重依据，也就是幂等令牌呢？</p>
<p>答案是否定的，因为<code>MessageID</code>可能会出现冲突的情况，因此不建议通过<code>MessageID</code>作为处理依据，应该使用业务唯一标识如：订单号、流水号等作为幂等处理的关键依据。</p>
<p>幂等令牌由消息生产者生成，在发消息消息时，可以通过消息的<code>key</code>设值为该id。对应API为<code>org.apache.rocketmq.common.message.setKeys(String keys)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Message sendMessage = <span class="keyword">new</span> Message(<span class="string">&quot;topic&quot;</span>, message.getBytes());</span><br><span class="line">sendMessage.setKeys(<span class="string">&quot;OD0000000001&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当消息消费者收到该消息时，根据该消息的key做幂等处理，API为 <code>org.apache.rocketmq.common.message.getKeys()</code> 。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(msgs, context) -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 默认msgs只有一条消息</span></span><br><span class="line">        <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">            String key = msg.getKeys();</span><br><span class="line">            <span class="keyword">return</span> walletCharge(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOGGER.error(<span class="string">&quot;钱包扣款消费异常。&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者通过<code>getKeys()</code>能够读取到生产者设置的幂等依据(如：订单号)，然后业务逻辑围绕该id进行幂等处理即可。</p>
<p>如果觉得每次都需要在生产者侧<code>setkey</code>，在消费者侧<code>getkey</code>有点繁琐。也可以将该幂等依据设置在消息协议中，消费者接收到消息后解析该id进行幂等操作。只需要消息的生产者和消费者约定好如何解析id的协议即可。</p>
<h1 id="消费端常见的幂等操作"><a href="#消费端常见的幂等操作" class="headerlink" title="消费端常见的幂等操作"></a>消费端常见的幂等操作</h1><h2 id="业务操作前状态查询"><a href="#业务操作前状态查询" class="headerlink" title="业务操作前状态查询"></a>业务操作前状态查询</h2><p>消费端开始执行业务操作时，通过幂等id首先进行业务状态的查询，如：修改订单状态环节，当订单状态为成功/失败则不需要再进行处理。那么只需要在消费逻辑执行之前通过订单号进行订单状态查询，一旦获取到确定的订单状态则对消息进行提交，通知<code>broker</code>消息状态为：<strong>ConsumeConcurrentlyStatus.CONSUME_SUCCESS</strong> 。</p>
<h2 id="业务操作前数据检索"><a href="#业务操作前数据检索" class="headerlink" title="业务操作前数据检索"></a>业务操作前数据检索</h2><p>逻辑与第一点相似，即消费之前进行数据的检索。如果能够通过业务唯一id查询到对应的数据则不需要进行再后续的业务逻辑。如：下单环节中，在消费者执行异步下单之前首先通过订单号查询订单是否已经存在，这里可以查库也可以查缓存。如果存在则直接返回消费成功，否则进行下单操作。</p>
<h2 id="唯一性约束保证最后一道防线"><a href="#唯一性约束保证最后一道防线" class="headerlink" title="唯一性约束保证最后一道防线"></a>唯一性约束保证最后一道防线</h2><p>上述第二点操作并不能保证一定不出现重复的数据。如：并发插入的场景下，如果没有乐观锁、分布式锁作为保证的前提下，很有可能出现数据的重复插入，因此务必要对幂等id添加唯一性索引，这样就能够保证在并发场景下也能保证数据的唯一性。</p>
<h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><p>上述的第一点中，如果是并发更新的情况，没有使用悲观锁、乐观锁、分布式锁等机制的前提下，进行更新，很可能会出现多次更新导致状态的不准确。如：对订单状态的更新，业务要求订单只能从初始化-&gt;处理中，处理中-&gt;成功，处理中-&gt;失败，不允许跨状态更新。如果没有锁机制，很可能会将初始化的订单更新为成功，成功订单更新为失败等异常的情况。<br>高并发下，建议通过状态机的方式定义好业务状态的变迁，通过乐观锁、分布式锁机制保证多次更新的结果是确定的，悲观锁在并发环境不利于业务吞吐量的提高因此不建议使用。</p>
<h2 id="消息记录表"><a href="#消息记录表" class="headerlink" title="消息记录表"></a>消息记录表</h2><p>这种方案和业务层做的幂等操作类似，由于消息id是唯一的，可以借助该id进行消息的去重操作，间接实现消费的幂等。<br>首先准备一个消息记录表，在消费成功的同时插入一条已经处理成功的消息id记录到该表中，<strong>注意一定要与业务操作处于同一个事务中</strong>，当新的消息到达的时候，根据新消息的id在该表中查询是否已经存在该id，如果存在则表明消息已经被消费过，那么丢弃该消息不再进行业务操作即可。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>肯定还有更多的场景没有涉及到，这里说到的操作均是互相之间有关联的，将他们配合使用更能够保证消费业务的幂等性。</p>
<p>不论怎样，一定要牢记一个原则：<strong>缓存是不可靠的，查询是不可靠的</strong> 。</p>
<p><strong>在高并发的场景下，一定要通过持久化存储的唯一索引以及引入锁机制作为共同保障数据准确性和完整性的最后一道防线</strong>！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://wuwenliang.net/2019/03/28/%E8%B7%9F%E6%88%91%E5%AD%A6RocketMQ%E4%B9%8B%E6%B6%88%E6%81%AF%E5%B9%82%E7%AD%89/">[跟我学RocketMQ之消息幂等]</a></p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ(二)—消息重试</title>
    <url>/RocketMQ-%E4%BA%8C-%E2%80%94%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>由于MQ经常处于复杂的分布式系统中，考虑网络波动、服务宕机、程序异常因素，很有可能出现消息发送或者消费失败的问题。因此，消息的重试就是所有MQ中间件必须考虑到的一个关键点。如果没有消息重试，就可能产生消息丢失的问题，可能对系统产生很大的影响。</p>
<h1 id="Consumer重试"><a href="#Consumer重试" class="headerlink" title="Consumer重试"></a>Consumer重试</h1><h2 id="重试条件"><a href="#重试条件" class="headerlink" title="重试条件"></a>重试条件</h2><p>在RocketMQ中，<strong>只有当消费模式为MessageModel.CLUSTERING(集群模式)时，Broker才会自动进行重试</strong>，对于<code>MessageModel.BROADCASTING</code>(广播消息)是不会重试的。集群模式下，当消息消费失败时，RMQ会通过消息重试机制重新投递消息，努力使该消息消费成功。对于一直无法消费成功的消息，RMQ会在达到最大重试次数之后，将该消息投递至死信队列。然后我们可以关注死信队列DLQ(<em>Dead Letter Queue</em>)，并对该死信消息业务做人工补偿操作。</p>
<blockquote>
<p>当消费者消费该重试消息后，需要返回结果给broker，告知broker消费成功(ConsumeConcurrentlyStatus.CONSUME_SUCCESS)或者需要重新消费(ConsumeConcurrentlyStatus.RECONSUME_LATER)</p>
</blockquote>
<p>RocketMQ规定，以下三种情况统一按照消费失败处理并会发起重试：</p>
<ul>
<li>业务消费方返回<code>ConsumeConcurrentlyStatus.RECONSUME_LATER</code></li>
<li>业务消费方返回null</li>
<li>业务消费方主动/被动抛出异常</li>
</ul>
<p>前两种情况较容易理解，当返回ConsumeConcurrentlyStatus.RECONSUME_LATER或者null时，broker会知道消费失败，后续就会发起消息重试，重新投递该消息。</p>
<p><strong>注意：</strong>对于抛出异常的情况，只要在业务逻辑中显式抛出异常或者非显式抛出异常，broker也会重新投递消息，如果业务对异常做了捕获，那么该消息将不会发起重试。因此对于需要重试的业务，消费方在捕获异常的时候要注意返回<code>ConsumeConcurrentlyStatus.RECONSUME_LATER</code>或<code>null</code>并输出异常日志，打印当前重试次数(推荐返回<strong>ConsumeConcurrentlyStatus.RECONSUME_LATER</strong>)。</p>
<h2 id="重试时间窗"><a href="#重试时间窗" class="headerlink" title="重试时间窗"></a>重试时间窗</h2><p>RocketMQ不支持任意频率的延时调用，当消息需要重试时，会按照broker中指定的重试时间窗进行重试。可以在RMQ的源码<code>org.apache.rocketmq.store.config.MessageStoreConfig#messageDelayLevel</code>找到消息重试配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消息延时级别默认配置</span></span><br><span class="line"><span class="keyword">private</span> String messageDelayLevel = <span class="string">&quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">重试次数</th>
<th align="center"><strong>距离第一次发送的时间间隔</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">10s</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">30s</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">1m</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">2m</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">3m</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">4m</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">5m</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">6m</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">7m</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">8m</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">9m</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">10m</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">20m</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">30m</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">1h</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">2h</td>
</tr>
</tbody></table>
<p>RocketMQ采用了“时间衰减策略”进行消息的重复投递，即重试次数越多，消息消费成功的可能性越小。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>在RMQ的客户端源码<code>DefaultMQPushConsumerImpl.java</code>中，对重试机制做了说明，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxReconsumeTimes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 默认消费次数: 16</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMaxReconsumeTimes() == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.defaultMQPushConsumer.getMaxReconsumeTimes();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先判断消费端有没有显式设置最大重试次数 <code>MaxReconsumeTimes</code>， <strong>如果没有，则设置默认重试次数为16，否则以设置的最大重试次数为准</strong>。</p>
<p>当消息消费失败，服务端会发起消费重试，具体逻辑在broker的源码<code>org.apache.rocketmq.broker.processor.SendMessageProcessor#consumerSendMsgBack</code>中涉及，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前重试次数大于等于最大重试次数或者配置的重试级别小于0，则获取死信队列的Topic。后续将超时的消息send到死信队列中</span></span><br><span class="line"><span class="keyword">if</span> (msgExt.getReconsumeTimes() &gt;= maxReconsumeTimes || delayLevel &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            newTopic = MixAll.getDLQTopic(requestHeader.getGroup());</span><br><span class="line">            queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % DLQ_NUMS_PER_GROUP;</span><br><span class="line"></span><br><span class="line">            topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic,</span><br><span class="line">                DLQ_NUMS_PER_GROUP,</span><br><span class="line">                PermName.PERM_WRITE, <span class="number">0</span></span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == topicConfig) &#123;</span><br><span class="line">                response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">                response.setRemark(<span class="string">&quot;topic[&quot;</span> + newTopic + <span class="string">&quot;] not exist&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果delayLevel为0，则默认加3个级别</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == delayLevel) &#123;</span><br><span class="line">                delayLevel = <span class="number">3</span> + msgExt.getReconsumeTimes();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msgExt.setDelayTimeLevel(delayLevel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况会进入else分支，对于首次重试的消息，默认的delayLevel是0，RMQ会将给该level + 3，也就是加到3，这就是说，如果没有显示的配置延时级别，消息消费重试首次，是延迟了第三个级别发起的重试，从表格中看也就是距离首次发送10s后重试。</p>
<p>当延时级别设置完成，刷新消息的重试次数为当前次数加1，broker将该消息刷盘，逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessageExtBrokerInner msgInner = <span class="keyword">new</span> MessageExtBrokerInner();</span><br><span class="line">        msgInner.setTopic(newTopic);</span><br><span class="line">        msgInner.setBody(msgExt.getBody());</span><br><span class="line">        msgInner.setFlag(msgExt.getFlag());</span><br><span class="line">        MessageAccessor.setProperties(msgInner, msgExt.getProperties());</span><br><span class="line">        msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties()));</span><br><span class="line">        msgInner.setTagsCode(MessageExtBrokerInner.tagsString2tagsCode(<span class="keyword">null</span>, msgExt.getTags()));</span><br><span class="line"></span><br><span class="line">        msgInner.setQueueId(queueIdInt);</span><br><span class="line">        msgInner.setSysFlag(msgExt.getSysFlag());</span><br><span class="line">        msgInner.setBornTimestamp(msgExt.getBornTimestamp());</span><br><span class="line">        msgInner.setBornHost(msgExt.getBornHost());</span><br><span class="line">        msgInner.setStoreHost(<span class="keyword">this</span>.getStoreHost());</span><br><span class="line">        msgInner.setReconsumeTimes(msgExt.getReconsumeTimes() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        String originMsgId = MessageAccessor.getOriginMessageId(msgExt);</span><br><span class="line">        MessageAccessor.setOriginMessageId(msgInner, UtilAll.isBlank(originMsgId) ? msgExt.getMsgId() : originMsgId);</span><br><span class="line"></span><br><span class="line">        PutMessageResult putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br></pre></td></tr></table></figure>

<p>对于重试消息，RMQ会创建新的<code>MessageExtBrokerInner</code>对象，继承自<code>MessageExt</code>。继续进入消息刷盘逻辑，即：<code>putMessage(msgInner)</code>方法，实现类为<code>DefaultMessageStore.java</code>，核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> beginTime = <span class="keyword">this</span>.getSystemClock().now();</span><br><span class="line">PutMessageResult result = <span class="keyword">this</span>.commitLog.putMessage(msg);</span><br></pre></td></tr></table></figure>

<p>主要关注 <code>this.commitLog.putMessage(msg);</code> 这句代码，通过commitLog可以认为这里是真实刷盘操作，也就是消息被持久化了。继续进入<code>commitLog</code>的<code>putMessage</code>方法，核心代码段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE</span><br><span class="line">    || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line">    <span class="comment">// 处理延时级别</span></span><br><span class="line">    <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">            msg.setDelayTimeLevel(<span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更换Topic</span></span><br><span class="line">        topic = ScheduleMessageService.SCHEDULE_TOPIC;</span><br><span class="line">        <span class="comment">// 队列ID为延迟级别-1</span></span><br><span class="line">        queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 备份真实的topic, queueId</span></span><br><span class="line">        MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">        MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">        msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置topic及queueId</span></span><br><span class="line">        msg.setTopic(topic);</span><br><span class="line">        msg.setQueueId(queueId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ScheduleMessageService.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">delayLevel2QueueId</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> delayLevel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delayLevel - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是重试消息，在进行延时级别判断时候，会进入分支逻辑，通过这段逻辑可以看出对于重试的消息，RMQ并不会从原队列中获取消息，而是创建了一个新的Topic进行消息存储的。也就是代码中的<code>SCHEDULE_TOPIC</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCHEDULE_TOPIC = <span class="string">&quot;SCHEDULE_TOPIC_XXXX&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>由此可以看出：</p>
<blockquote>
<p>对于所有消费者消费失败的消息，RMQ都会把重试的消息重新new出来(new MessageExtBrokerInner对象)，然后投递到Topic为<strong>SCHEDULE_TOPIC_XXXX</strong> 下的队列中，然后由定时任务进行调度重试，而重试的周期即是上面的的delayLevel周期。Broker在启动时会创建topic为SCHEDULE_TOPIC_XXXX`，根据延迟level的个数，创建对应数量的队列，也就是说18个level对应了18个队列。注意，这并不是说这个内部主题只会有18个队列，因为Broker通常是集群模式部署的，因此每个节点都有18个队列。</p>
</blockquote>
<p>同时为了保证消息可被找到，也会将原先的Topic和队列id存储到properties中做备份：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// Backup real topic, queueId</span></span><br><span class="line">MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br></pre></td></tr></table></figure>

<h2 id="死信的业务处理方式"><a href="#死信的业务处理方式" class="headerlink" title="死信的业务处理方式"></a>死信的业务处理方式</h2><p>默认的处理机制中，如果只对消息做重复消费，达到最大重试次数之后消息就进入死信队列了。可以根据业务的需要，定义消费的最大重试次数，每次消费的时候判断当前消费次数是否等于最大重试次数的阈值。</p>
<p>如：重试三次就认为当前业务存在异常，继续重试下去也没有意义了，那么就可以将当前的这条消息进行提交，返回broker状态<strong>ConsumeConcurrentlyStatus.CONSUME_SUCCES</strong>，让消息不再重发，同时将该消息存入业务自定义的死信消息表，将业务参数入库，相关的运营通过查询死信表来进行对应的业务补偿操作。</p>
<p>RMQ 的处理方式为将达到最大重试次数(16次)的消息标记为死信消息，将该死信消息投递到DLQ死信队列中，业务需要进行人工干预。实现的逻辑在<code>org.apache.rocketmq.broker.processor.SendMessageProcessor#consumerSendMsgBack</code>方法中，大致思路为首先判断重试次数是否超过16或消息发送延时级别是否小于0，如果是则将消息设置为新的死信。死信topic 为：**%DLQ% + consumerGroup**。</p>
<h3 id="死信源码分析"><a href="#死信源码分析" class="headerlink" title="死信源码分析"></a>死信源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">consumerSendMsgBack</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, <span class="keyword">final</span> RemotingCommand request)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">final</span> ConsumerSendMsgBackRequestHeader requestHeader =</span><br><span class="line">            (ConsumerSendMsgBackRequestHeader)request.decodeCommandCustomHeader(ConsumerSendMsgBackRequestHeader.class);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0.首先判断重试次数是否大于等于16，或者消息延迟级别是否小于0</span></span><br><span class="line">        <span class="keyword">if</span> (msgExt.getReconsumeTimes() &gt;= maxReconsumeTimes</span><br><span class="line">            || delayLevel &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 如果满足判断条件，设置死信队列topic= %DLQ%+consumerGroup</span></span><br><span class="line">            newTopic = MixAll.getDLQTopic(requestHeader.getGroup());</span><br><span class="line">            queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % DLQ_NUMS_PER_GROUP;</span><br><span class="line"></span><br><span class="line">            topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic,</span><br><span class="line">                DLQ_NUMS_PER_GROUP,</span><br><span class="line">                PermName.PERM_WRITE, <span class="number">0</span></span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == topicConfig) &#123;</span><br><span class="line">                response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">                response.setRemark(<span class="string">&quot;topic[&quot;</span> + newTopic + <span class="string">&quot;] not exist&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果延迟级别为0，则设置下一次延迟级别为3+当前重试消费次数，达到时间衰减效果</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == delayLevel) &#123;</span><br><span class="line">                delayLevel = <span class="number">3</span> + msgExt.getReconsumeTimes();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msgExt.setDelayTimeLevel(delayLevel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MessageExtBrokerInner msgInner = <span class="keyword">new</span> MessageExtBrokerInner();</span><br><span class="line">        msgInner.setTopic(newTopic);</span><br><span class="line">        msgInner.setBody(msgExt.getBody());</span><br><span class="line">        msgInner.setFlag(msgExt.getFlag());</span><br><span class="line">        MessageAccessor.setProperties(msgInner, msgExt.getProperties());</span><br><span class="line">        msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties()));</span><br><span class="line">        msgInner.setTagsCode(MessageExtBrokerInner.tagsString2tagsCode(<span class="keyword">null</span>, msgExt.getTags()));</span><br><span class="line"></span><br><span class="line">        msgInner.setQueueId(queueIdInt);</span><br><span class="line">        msgInner.setSysFlag(msgExt.getSysFlag());</span><br><span class="line">        msgInner.setBornTimestamp(msgExt.getBornTimestamp());</span><br><span class="line">        msgInner.setBornHost(msgExt.getBornHost());</span><br><span class="line">        msgInner.setStoreHost(<span class="keyword">this</span>.getStoreHost());</span><br><span class="line">        msgInner.setReconsumeTimes(msgExt.getReconsumeTimes() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        String originMsgId = MessageAccessor.getOriginMessageId(msgExt);</span><br><span class="line">        MessageAccessor.setOriginMessageId(msgInner, UtilAll.isBlank(originMsgId) ? msgExt.getMsgId() : originMsgId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.死信消息投递到死信队列中并落盘</span></span><br><span class="line">        PutMessageResult putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>死信队列的处理逻辑</p>
<ol>
<li>判断消息当前重试次数是否大于等于16，或者消息延迟级别是否小于0</li>
<li>只要满足上述的任意一个条件，设置新的topic(死信topic)为：**%DLQ% + consumerGroup**</li>
<li>进行前置属性的添加</li>
<li>将死信消息投递到步骤2建立的死信topic对应的死信队列中并落盘，使消息持久化</li>
</ol>
<h1 id="Producer重试"><a href="#Producer重试" class="headerlink" title="Producer重试"></a>Producer重试</h1><p>当发生网络抖动等异常情况，<code>Producer</code>侧往broker发送消息失败，即：生产者侧没收到broker返回的ACK，导致<code>Consumer</code>无法进行消息消费，这时RMQ会进行发送重试。</p>
<p>使用<code>DefaultMQProducer</code>进行普通消息发送时，可以设置消息发送失败后最大重试次数，并且能够灵活的配合超时时间进行业务重试逻辑的开发，使用的API如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认重试两次</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> retryTimesWhenSendFailed = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置消息发送失败时最大重试次数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRetryTimesWhenSendFailed</span><span class="params">(<span class="keyword">int</span> retryTimesWhenSendFailed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.retryTimesWhenSendFailed = retryTimesWhenSendFailed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步发送消息，并指定超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(Message msg, <span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.defaultMQProducerImpl.send(msg, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过API可以看出，生产者侧的重试是比较简单的，例如：设置生产者在3s内没有发送成功则重试3次的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步发送消息，如果3秒内没有发送成功，则重试3次</span></span><br><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;DefaultProducerGroup&quot;</span>);</span><br><span class="line">producer.setRetryTimesWhenSendFailed(<span class="number">3</span>);</span><br><span class="line">producer.send(msg, <span class="number">3000L</span>);</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://wuwenliang.net/2019/03/28/%E8%B7%9F%E6%88%91%E5%AD%A6RocketMQ%E4%B9%8B%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95/#RocketMQ%E9%87%8D%E8%AF%95%E6%97%B6%E9%97%B4%E7%AA%97">跟我学RocketMQ之消息重试</a></p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Sping定时任务</title>
    <url>/Sping%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在企业开发中，经常会遇到时间任务调度的需求，比如每天凌晨生成前天报表、数据汇总等动态配置是否开启定时的任务。在Java领域中，定时任务的开源工具也非常多，小到一个Timer类，大到Quartz框架。在Spring中最常见的定时任务方式属<strong>Spring schedule注解的方式</strong>和利用<strong>Quartz动态管理定时任务</strong>。总体来说，个人比较喜欢的还是Quartz，功能强大而且使用方便。<div align=center></p>
<blockquote>
<img width="800" height="300" src="../../../../images/2018-03/quartz/index.png"/>
</blockquote>
</div><span id="more"></span>

<h1 id="Spring-scheduled"><a href="#Spring-scheduled" class="headerlink" title="Spring-@scheduled"></a>Spring-@scheduled</h1><p>对于较简单的任务可以使用Spring内置的定时任务方法@scheduled注解进行配置达到自己的需求。</p>
<h2 id="spring配置文件"><a href="#spring配置文件" class="headerlink" title="spring配置文件"></a>spring配置文件</h2><p>配置spring项目的基础文件spring.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:task</span>=<span class="string">&quot;http://www.springframework.org/schema/task&quot;</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;  </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans  </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context  </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context-3.0.xsd  </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/task  </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/task/spring-task-3.1.xsd&quot;</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">  	<span class="comment">&lt;!-- 开启定时任务 spring的定时任务默认是单线程，多个任务执行起来时间会有问题，所以这里配置了线程池--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">&quot;executor&quot;</span> <span class="attr">pool-size</span>=<span class="string">&quot;5&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">&quot;scheduler&quot;</span> <span class="attr">pool-size</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">executor</span>=<span class="string">&quot;executor&quot;</span> <span class="attr">scheduler</span>=<span class="string">&quot;scheduler&quot;</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<h2 id="Task任务类"><a href="#Task任务类" class="headerlink" title="Task任务类"></a>Task任务类</h2><p>定义了一个任务类ATask，里面有两个定时任务aTask和bTask。编写java业务代码，需要在类声明上边添加**@Component注解<strong>，并在需要定时任务执行的方法声明上添加</strong>@Scheduled**注解以及cron表达式和相关的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定时器的任务方法不能有返回值</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ATask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Scheduled(cron = &quot;0/10 * *  * * ? &quot;)</span> <span class="comment">// 每10秒执行一次</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		DateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">		System.out.println(sdf.format(DateTime.now().toDate()) + <span class="string">&quot;*********A任务每10秒执行一次进入测试&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Scheduled(cron = &quot;0/5 * *  * * ? &quot;)</span> <span class="comment">// 每5秒执行一次</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		DateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">		System.out.println(sdf.format(DateTime.now().toDate()) + <span class="string">&quot;*********B任务每5秒执行一次进入测试&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>启动项目会发现定时任务已经开启。</p>
<div align=center><img width="600" height="200" src="../../../../images/2018-03/quartz/taskCode.png" algin="center"/>

</div>

<h1 id="Spring-Quartz"><a href="#Spring-Quartz" class="headerlink" title="Spring-Quartz"></a>Spring-Quartz</h1><p>@scheduled固然可以实现定时任务，但是仔细想想并不灵活，任务随着应用的启动而执行，并不能动态的进行管理，很是不方便，然而Quartz很好的解决了这一问题。</p>
<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.quartz-scheduler<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="任务管理类QuartzManager"><a href="#任务管理类QuartzManager" class="headerlink" title="任务管理类QuartzManager"></a>任务管理类QuartzManager</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SchedulerFactory schedulerFactory = <span class="keyword">new</span> StdSchedulerFactory();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Description</span>: 添加一个定时任务</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> jobName</span></span><br><span class="line"><span class="comment">	 *            任务名</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> jobGroupName</span></span><br><span class="line"><span class="comment">	 *            任务组名</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> triggerName</span></span><br><span class="line"><span class="comment">	 *            触发器名</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> triggerGroupName</span></span><br><span class="line"><span class="comment">	 *            触发器组名</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> jobClass</span></span><br><span class="line"><span class="comment">	 *            任务</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> cron</span></span><br><span class="line"><span class="comment">	 *            时间设置，参考quartz说明文档</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addJob</span><span class="params">(String jobName, String jobGroupName, String triggerName, String triggerGroupName,</span></span></span><br><span class="line"><span class="params"><span class="function">			Class jobClass, String cron)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Scheduler sched = schedulerFactory.getScheduler();</span><br><span class="line">			<span class="comment">// 任务名，任务组，任务执行类</span></span><br><span class="line">			JobDetail jobDetail = JobBuilder.newJob(jobClass).withIdentity(jobName, jobGroupName).build();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 触发器</span></span><br><span class="line">			TriggerBuilder&lt;Trigger&gt; triggerBuilder = TriggerBuilder.newTrigger();</span><br><span class="line">			<span class="comment">// 触发器名,触发器组</span></span><br><span class="line">			triggerBuilder.withIdentity(triggerName, triggerGroupName);</span><br><span class="line">			triggerBuilder.startNow();</span><br><span class="line">			<span class="comment">// 触发器时间设定</span></span><br><span class="line">			triggerBuilder.withSchedule(CronScheduleBuilder.cronSchedule(cron));</span><br><span class="line">			<span class="comment">// 创建Trigger对象</span></span><br><span class="line">			CronTrigger trigger = (CronTrigger) triggerBuilder.build();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 调度容器设置JobDetail和Trigger</span></span><br><span class="line">			sched.scheduleJob(jobDetail, trigger);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 启动</span></span><br><span class="line">			<span class="keyword">if</span> (!sched.isShutdown()) &#123;</span><br><span class="line">				sched.start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Description</span>: 修改一个任务的触发时间</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> jobName</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> jobGroupName</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> triggerName</span></span><br><span class="line"><span class="comment">	 *            触发器名</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> triggerGroupName</span></span><br><span class="line"><span class="comment">	 *            触发器组名</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> cron</span></span><br><span class="line"><span class="comment">	 *            时间设置，参考quartz说明文档</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modifyJobTime</span><span class="params">(String jobName, String jobGroupName, String triggerName, String triggerGroupName,</span></span></span><br><span class="line"><span class="params"><span class="function">			String cron)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Scheduler sched = schedulerFactory.getScheduler();</span><br><span class="line">			TriggerKey triggerKey = TriggerKey.triggerKey(triggerName, triggerGroupName);</span><br><span class="line">			CronTrigger trigger = (CronTrigger) sched.getTrigger(triggerKey);</span><br><span class="line">			<span class="keyword">if</span> (trigger == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			String oldTime = trigger.getCronExpression();</span><br><span class="line">			<span class="keyword">if</span> (!oldTime.equalsIgnoreCase(cron)) &#123;</span><br><span class="line">				<span class="comment">/** 方式一 ：调用 rescheduleJob 开始 */</span></span><br><span class="line">				<span class="comment">// 触发器</span></span><br><span class="line">				TriggerBuilder&lt;Trigger&gt; triggerBuilder = TriggerBuilder.newTrigger();</span><br><span class="line">				<span class="comment">// 触发器名,触发器组</span></span><br><span class="line">				triggerBuilder.withIdentity(triggerName, triggerGroupName);</span><br><span class="line">				triggerBuilder.startNow();</span><br><span class="line">				<span class="comment">// 触发器时间设定</span></span><br><span class="line">				triggerBuilder.withSchedule(CronScheduleBuilder.cronSchedule(cron));</span><br><span class="line">				<span class="comment">// 创建Trigger对象</span></span><br><span class="line">				trigger = (CronTrigger) triggerBuilder.build();</span><br><span class="line">				<span class="comment">// 方式一 ：修改一个任务的触发时间</span></span><br><span class="line">				sched.rescheduleJob(triggerKey, trigger);</span><br><span class="line">				<span class="comment">/** 方式一 ：调用 rescheduleJob 结束 */</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">/** 方式二：先删除，然后在创建一个新的Job */</span></span><br><span class="line">				<span class="comment">// JobDetail jobDetail =</span></span><br><span class="line">				<span class="comment">// sched.getJobDetail(JobKey.jobKey(jobName, jobGroupName));</span></span><br><span class="line">				<span class="comment">// Class&lt;? extends Job&gt; jobClass = jobDetail.getJobClass();</span></span><br><span class="line">				<span class="comment">// removeJob(jobName, jobGroupName, triggerName,</span></span><br><span class="line">				<span class="comment">// triggerGroupName);</span></span><br><span class="line">				<span class="comment">// addJob(jobName, jobGroupName, triggerName, triggerGroupName,</span></span><br><span class="line">				<span class="comment">// jobClass, cron);</span></span><br><span class="line">				<span class="comment">/** 方式二 ：先删除，然后在创建一个新的Job */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Description</span>: 移除一个任务</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> jobName</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> jobGroupName</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> triggerName</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> triggerGroupName</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeJob</span><span class="params">(String jobName, String jobGroupName, String triggerName, String triggerGroupName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Scheduler sched = schedulerFactory.getScheduler();</span><br><span class="line"></span><br><span class="line">			TriggerKey triggerKey = TriggerKey.triggerKey(triggerName, triggerGroupName);</span><br><span class="line"></span><br><span class="line">			sched.pauseTrigger(triggerKey);<span class="comment">// 停止触发器</span></span><br><span class="line">			sched.unscheduleJob(triggerKey);<span class="comment">// 移除触发器</span></span><br><span class="line">			sched.deleteJob(JobKey.jobKey(jobName, jobGroupName));<span class="comment">// 删除任务</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Description</span>:启动所有定时任务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startJobs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Scheduler sched = schedulerFactory.getScheduler();</span><br><span class="line">			sched.start();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Description</span>:关闭所有定时任务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutdownJobs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Scheduler sched = schedulerFactory.getScheduler();</span><br><span class="line">			<span class="keyword">if</span> (!sched.isShutdown()) &#123;</span><br><span class="line">				sched.shutdown();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="任务执行业务"><a href="#任务执行业务" class="headerlink" title="任务执行业务"></a>任务执行业务</h2><p>这里做一个简单的演示，只实现Job接口打印当前时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJob</span> <span class="keyword">implements</span> <span class="title">Job</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">		DateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">		System.out.println(sdf.format(DateTime.now().toDate()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试动态定时任务"><a href="#测试动态定时任务" class="headerlink" title="测试动态定时任务"></a>测试动态定时任务</h2><p>新建QuartzTest.Java 测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String JOB_NAME = <span class="string">&quot;动态任务调度&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String TRIGGER_NAME = <span class="string">&quot;动态任务触发器&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String JOB_GROUP_NAME = <span class="string">&quot;XLXXCC_JOB_GROUP&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String TRIGGER_GROUP_NAME = <span class="string">&quot;XLXXCC_JOB_GROUP&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;【系统启动】开始(每1秒输出一次)...&quot;</span>);</span><br><span class="line">			QuartzManager.addJob(JOB_NAME, JOB_GROUP_NAME, TRIGGER_NAME, TRIGGER_GROUP_NAME, MyJob.class,<span class="string">&quot;0/1 * * * * ?&quot;</span>);</span><br><span class="line"></span><br><span class="line">			Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;【修改时间】开始(每5秒输出一次)...&quot;</span>);</span><br><span class="line">			QuartzManager.modifyJobTime(JOB_NAME, JOB_GROUP_NAME, TRIGGER_NAME, TRIGGER_GROUP_NAME, <span class="string">&quot;0/5 * * * * ?&quot;</span>);</span><br><span class="line"></span><br><span class="line">			Thread.sleep(<span class="number">15000</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;【移除定时】开始...&quot;</span>);</span><br><span class="line">			QuartzManager.removeJob(JOB_NAME, JOB_GROUP_NAME, TRIGGER_NAME, TRIGGER_GROUP_NAME);</span><br><span class="line">			System.out.println(<span class="string">&quot;【移除定时】成功&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<div align=center><img width="600" height="200" src="../../../../images/2018-03/quartz/quartzResult.png" algin="center"/>

</div>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过以上测试可以明显的看出两者的优劣，Quartz足够灵活强大，但Spring scheduled 在简单任务下也是一个不错的选择。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring+webSocket</title>
    <url>/Spring-webSocket/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>websocket 是 HTML5新增加特性之一，目的是浏览器与服务端建立全双工的通信方式，解决 HTTP请求-响应带来过多的资源消耗，同时对特殊场景应用提供了全新的实现方式，比如聊天、股票交易、游戏等对对实时性要求较高的行业领域。<div align=center><img src="../../../../images//2018-3/websocket/websocket-java.jpg" algin="center"/></div><span id="more"></span></p>
<h1 id="STOMP"><a href="#STOMP" class="headerlink" title="STOMP"></a>STOMP</h1><p>STOMP(Simple Text-Orientated Messaging Protocol) 面向消息的简单文本协议。</p>
<p>WebSocket是一个消息架构，不强制使用任何特定的消息协议，它依赖于应用层解释消息的含义；</p>
<p>与处在应用层的HTTP不同，WebSocket处在TCP上非常薄的一层，会将字节流转换为文本/二进制消息，因此，对于实际应用来说，WebSocket的通信形式层级过低，因此，可以在 WebSocket 之上使用 STOMP协议，来为浏览器 和 server间的 通信增加适当的消息语义。</p>
<p>如何理解 STOMP 与 WebSocket 的关系： </p>
<ol>
<li>HTTP协议解决了 web 浏览器发起请求以及 web 服务器响应请求的细节，假设 HTTP 协议 并不存在，只能使用 TCP 套接字来 编写 web 应用，你可能认为这是一件疯狂的事情； </li>
<li>直接使用 WebSocket（SockJS） 就很类似于 使用 TCP 套接字来编写 web 应用，因为没有高层协议，就需要我们定义应用间所发送消息的语义，还需要确保连接的两端都能遵循这些语义； </li>
<li>同 HTTP 在 TCP 套接字上添加请求-响应模型层一样，STOMP 在 WebSocket 之上提供了一个基于帧的线路格式层，用来定义消息语义；</li>
</ol>
<div align=center><img src="../../../../images//2018-3/websocket/stomp.jpg" algin="center"/></div>

<h1 id="Spring-websocket"><a href="#Spring-websocket" class="headerlink" title="Spring+websocket"></a>Spring+websocket</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>需要添加spring-websocket和spring-messaging依赖，注意和spring-core的版本保持一致。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring-websocket --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-messaging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h2><p>服务端的初始化，只需要两个类：<strong>WebsocketConfig</strong>（stomp节点配置）和<strong>WebSocketController</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.simp.config.MessageBrokerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.AbstractWebSocketMessageBrokerConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.StompEndpointRegistry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过EnableWebSocketMessageBroker 开启使用STOMP协议来传输基于代理(message broker)的消息,此时浏览器支持使用<span class="doctag">@MessageMapping</span> 就像支持<span class="doctag">@RequestMapping</span>一样。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">extends</span> <span class="title">AbstractWebSocketMessageBrokerConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> </span>&#123; </span><br><span class="line">        <span class="comment">//endPoint 注册协议节点,并映射指定的URl</span></span><br><span class="line">        <span class="comment">//注册一个名字为&quot;endpointChat&quot; 的endpoint,并指定 SockJS协议，客户端就可以通过这个端点来进行连接；withSockJS作用是添加SockJS支持。</span></span><br><span class="line">        registry.addEndpoint(<span class="string">&quot;/endpointChat&quot;</span>).withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//配置消息代理(message broker)，定义了两个客户端订阅地址的前缀信息，也就是客户端接收服务端发送消息的前缀信息</span></span><br><span class="line">        <span class="comment">//点对点式增加一个/queue 消息代理</span></span><br><span class="line">        registry.enableSimpleBroker(<span class="string">&quot;/queue&quot;</span>, <span class="string">&quot;/topic&quot;</span>);</span><br><span class="line">        <span class="comment">//定义了服务端接收地址的前缀，也即客户端给服务端发消息的地址前缀</span></span><br><span class="line">        <span class="comment">//registry.setApplicationDestinationPrefixes(“/user”);	</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对以上代码分析：</strong></p>
<ul>
<li>EnableWebSocketMessageBroker 注解表明： 这个配置类不仅配置了 WebSocket，还配置了基于代理的 STOMP 消息；</li>
<li>它复写了 registerStompEndpoints() 方法：添加一个服务端点，来接收客户端的连接。将 “/endpointChat” 路径注册为 STOMP 端点。这个路径与之前发送和接收消息的目的路径有所不同， 这是一个端点，客户端在订阅或发布消息到目的地址前，要连接该端点，即用户发送请求 ：<em>URL=’/127.0.0.1:8080/endpointChat’</em> 与 STOMP server 进行连接，之后再转发到订阅URL；</li>
<li>它复写了 configureMessageBroker() 方法：配置了一个 简单的消息代理，通俗一点讲就是设置消息连接请求的各种规范信息。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.messaging.handler.annotation.MessageMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.simp.SimpMessagingTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> com.thinkgem.jeesite.modules.sys.utils.UserUtils;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/websocket&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebsocketController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> SimpMessagingTemplate template;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@MessageMapping(&quot;/sendMsg&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roomMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 多线程配置推送消息</span></span><br><span class="line">		ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">		executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			template.convertAndSendToUser(userId, <span class="string">&quot;/queue/notifications&quot;</span>,<span class="string">&quot;新消息：这是websocked测试消息&quot;</span>);<span class="comment">// 一对一发送，发送特定的客户端  </span></span><br><span class="line">                <span class="comment">//template.convertAndSend(&quot;/topic/getResponse&quot;,&quot;新消息：这是websocked测试消息&quot;);//广播消息</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		executor.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>template.convertAndSendToUser(user, dest, message)</em> 这个方法官方给出的解释是 Convert the given Object to serialized form, possibly using a MessageConverter, wrap it as a message and send it to the given destination. 意思就是“将给定的对象进行序列化，使用 ‘MessageConverter’ 进行包装转化成一条消息，发送到指定的目标”，通俗点讲就是我们使用这个方法进行消息的转发发送。</p>
<h2 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h2><p>首先引用 <em><a href="../../../../images//2018-3/websocket/sockjs.min.js"><strong>sockjs.js</strong></a></em> 和 <em><a href="../../../../images//2018-3/websocket/stomp.min.js"><strong>stomp.js</strong></a></em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;/js/common/sockjs.min.js&quot;</span>&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/js/common/stomp.min.js&quot;</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">		$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">			connect();</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">		&#125;);</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">		</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">		<span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span>) </span>&#123;</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">             <span class="comment">// TOMP客户端要想接收来自服务器推送的消息，必须先订阅相应的URL，即发送一个SUBSCRIBE帧，然后才能不断接收来自服务器的推送消息； </span></span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">			<span class="keyword">var</span> sock = <span class="keyword">new</span> SockJS(<span class="string">&quot;http://localhost:8080/endpointChat&quot;</span>);</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">			<span class="keyword">var</span> stomp = Stomp.over(sock);</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">			stomp.connect(<span class="string">&#x27;guest&#x27;</span>, <span class="string">&#x27;guest&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">frame</span>) </span>&#123;</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">	</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">				<span class="comment">/**订阅了/user/queue/notifications 发送的消息,这里与在控制器convertAndSendToUser 定义的地址保持一致</span></span></span></span></span></span><br><span class="line"><span class="comment"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">				 *  这里多用了一个/user,并且这个user 是必须的,使用user才会发送消息到指定的用户。</span></span></span></span></span></span><br><span class="line"><span class="comment"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">				 *  */</span></span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">				stomp.subscribe(<span class="string">&quot;/user/queue/notifications&quot;</span>, handleNotification);</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">           		 stomp.subscribe(<span class="string">&#x27;/topic/getResponse&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123; <span class="comment">//订阅/topic/getResponse 目标发送的消息。这个是在控制器的@SendTo中定义的。</span></span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">					<span class="built_in">console</span>.info(response.body);</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">				&#125;);</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">                	<span class="comment">//向服务端发送消息</span></span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">    			stomp.send(<span class="string">&quot;URL&quot;</span>, &#123;&#125;, <span class="built_in">JSON</span>.stringify(message));</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">		<span class="comment">//订阅服务器发送来的消息</span></span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">			<span class="function"><span class="keyword">function</span> <span class="title">handleNotification</span>(<span class="params">message</span>) </span>&#123;</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">				<span class="built_in">console</span>.info(message.body);</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">			&#125;</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml">		&#125;</span></span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="handlebars"><span class="xml"></span></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>利用 stomp的<em>connect(login, passcode, connectCallback, errorCallback, vhost)</em> 方法建立连接，值得注意的是不同版本的 stomp.js 的 connect() 函数的参数会有所不同；</li>
<li>利用 stomp的<em>subscribe(destination, callback, headers)</em> 方法可以订阅服务器发送来的消息，destination 表示服务器发送消息地址；通过 event 的 body 获取消息内容；</li>
<li>利用 stompClient 的<em>send(destination, headers, body)</em> 方法可以向服务端发送消息，第一个参数为发送消息地址，最后一个参数是发送消息的 json 串；</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在客户端请求*/websocket/sendMsg*后会有如下效果：<div align=center><img src="../../../../images//2018-3/websocket/result.png" algin="center"/></div></p>
<p>参考：</p>
<p><a href="https://docs.spring.io/spring/docs/4.3.14.RELEASE/spring-framework-reference/htmlsingle/#websocket"><em><strong>Spring Framework Reference Documentation</strong></em></a></p>
<p><a href="http://tech.lede.com/2017/03/08/qa/websocket+spring/"><em><strong>websocket+spring</strong></em></a></p>
<p><a href="http://www.cnblogs.com/winkey4986/p/5622758.html"><em><strong>spring websocket + stomp 实现广播通信和一对一通信</strong></em></a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tips</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC集成Swagger</title>
    <url>/SpringMVC%E9%9B%86%E6%88%90Swagger/</url>
    <content><![CDATA[<p>当前方便管理项目中的API接口，最流行的莫过于Swagger了，功能强大，UI界面漂亮，并且支持在线测试等等。所以仔细研究了下Swagger的使用。在这里记录下SpringMVC集成Swagger。</p>
<h1 id="引入Maven坐标"><a href="#引入Maven坐标" class="headerlink" title="引入Maven坐标"></a>引入Maven坐标</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Jackson --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Swagger --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Swagger-UI插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-bootstrap-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Swagger配置"><a href="#Swagger配置" class="headerlink" title="Swagger配置"></a>Swagger配置</h1><blockquote>
<p>对于Swagger的配置，其实是自定义一个与Swagger相关的Config类，可以通过Java编码的实现配置。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> max</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 控制是否展示Swagger</span></span><br><span class="line">    <span class="meta">@ReloadableProperty(&quot;swagger.show&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> swaggerShow = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Predicate&lt;RequestHandler&gt; predicate = input -&gt; &#123;</span><br><span class="line">            Class&lt;?&gt; declaringClass = input.declaringClass();</span><br><span class="line">            <span class="keyword">if</span> (declaringClass == TestController.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 被注解的类</span></span><br><span class="line">            <span class="keyword">if</span> (declaringClass.isAnnotationPresent(RestController.class)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 被注解的方法</span></span><br><span class="line">            <span class="keyword">return</span> input.isAnnotatedWith(ResponseBody.class);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .enable(swaggerShow)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .useDefaultResponseMessages(<span class="keyword">false</span>)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(predicate::test)</span><br><span class="line">                <span class="comment">//过滤的接口</span></span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 大标题</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder().title(<span class="string">&quot;消息系统接口服务&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;需要提供更多接口请联系 彩虹马&quot;</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> Contact(<span class="string">&quot;max&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;xxx@xxx.com&quot;</span>))</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口Controller实例如下：</p>
<div align=center><img src="../../../../images/2019/4-6/swagger-1.png" algin="center"/></div>

<h1 id="Swagger注解"><a href="#Swagger注解" class="headerlink" title="Swagger注解"></a>Swagger注解</h1><p>常用注解：</p>
<ol>
<li><p><strong>@Api</strong></p>
<p>该注解将一个Controller（Class）标注为一个swagger资源（API）。在默认情况下，Swagger-Core只会扫描解析具有@Api注解的类，而会自动忽略其他类别资源（JAX-RS endpoints，Servlets等等）的注解。该注解包含以下几个重要属性：</p>
<ul>
<li>tags：API分组标签。具有相同标签的API将会被归并在一组内展示。</li>
<li>value：如果tags没有定义，value将作为Api的tags使用。</li>
</ul>
</li>
<li><p><strong>@ApiOperation</strong></p>
<p>在指定的（路由）路径上，对一个操作或HTTP方法进行描述。具有相同路径的不同操作会被归组为同一个操作对象。不同的HTTP请求方法及路径组合构成一个唯一操作。此注解的属性有：</p>
<ul>
<li>value：对操作的简单说明，长度为120个字母，60个汉字。</li>
<li>notes：对操作的详细说明。</li>
<li>httpMethod：HTTP请求的动作名，可选值有：”GET”, “HEAD”, “POST”, “PUT”, “DELETE”, “OPTIONS” and “PATCH”。</li>
<li>code：默认为200，有效值必须符合标准的<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">HTTP Status Code Definitions</a>。</li>
</ul>
</li>
<li><p><strong>@ApiModelProperty</strong></p>
<p>对model属性的注解，主要的属性值有：</p>
<ul>
<li>value：属性简短描述。</li>
<li>example：属性的示例值。</li>
<li>required：是否为必须值。</li>
</ul>
</li>
</ol>
<p>更多注解可参考：<a href="https://mp.weixin.qq.com/s/ZD0i1-lcqRHtgYL-HW1Xpg">https://mp.weixin.qq.com/s/ZD0i1-lcqRHtgYL-HW1Xpg</a></p>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>启动服务后访问<em>http://{ip}:{port}/doc.html</em>即可进入Swagger。</p>
<p>前端UI没有采用默认的，找到了一个更漂亮的：<a href="https://github.com/xiaoymin/Swagger-Bootstrap-UI">https://github.com/xiaoymin/Swagger-Bootstrap-UI</a></p>
<div align=center><img src="../../../../images/2019/4-6/swagger-2.png" algin="center"/></div>

<div align=center><img src="../../../../images/2019/4-6/swagger-3.png" algin="center"/></div>

<p>注解和页面展示对应关系：</p>
<div align=center><img src="../../../../images/2019/4-6/swagger-5.jpg" algin="center"/></div>

<div align=center><img src="../../../../images/2019/4-6/swagger-4.png" algin="center"/></div>

<h1 id="环境控制"><a href="#环境控制" class="headerlink" title="环境控制"></a>环境控制</h1><p>Swagger提供给内部使用的接口稳定，如果在生产环境不想暴露出去，有以下解决办法：</p>
<ol>
<li><p>设置了<code>spring.profiles.active</code></p>
<p>可以通过<strong>profile</strong>注解来处理。 Swagger的congif类上声明**@Profile({“dev”, “test”})**,发布到生产上使用pro的profile时， swagger是无效的。</p>
</li>
<li><p>无<code>spring.profiles.active</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">  	.enable(<span class="keyword">false</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring下MySQL读写分离</title>
    <url>/Spring%E4%B8%8BMySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>之前的文章已经说明MySQL主从/主主同步环境的搭建，接下来就是要实现在业务代码里面实现读写分离。在当前流行的SSM的框架开发的web项目下，数据库模式为主从同步的环境下编写业务代码。</p>
<div align=center><img width="700" height="300" src="../../../../images/2018-5/MySQL_spring/index.png" algin="center"/>

</div><span id="more"></span>

<h1 id="编写jdbc-propreties"><a href="#编写jdbc-propreties" class="headerlink" title="编写jdbc.propreties"></a>编写jdbc.propreties</h1><p>在这里指定了两个数据库，主从数据库都在本地，只是端口不一致。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#数据库连接池的配置</span></span><br><span class="line"><span class="meta">jdbc.pool.init</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">jdbc.pool.minIdle</span>=<span class="string">3</span></span><br><span class="line"><span class="meta">jdbc.pool.maxActive</span>=<span class="string">20</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#mysql驱动</span></span><br><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment">#主数据库地址</span></span><br><span class="line"><span class="meta">jdbc.master.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;autoReconnect=true</span></span><br><span class="line"><span class="comment">#从数据库地址</span></span><br><span class="line"><span class="meta">jdbc.slave.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3308/test?useUnicode=true&amp;characterEncoding=utf-8&amp;autoReconnect=true</span></span><br><span class="line"><span class="comment">#数据库账号、密码</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">mysqluser</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">mysqlpassword</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<blockquote>
<p>在此之前，项目中一般会使用一个数据库用户远程操作数据库（避免直接使用root用户），因此需要在主从数据库里面都创建一个用户mysqluser，赋予其增删改查的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT select,insert,update,delete ON *.* TO &#x27;mysqluser&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;mysqlpassword&#x27; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h1><p>在spring-dao.xml中配置数据源，部分配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 1.配置数据库相关参数properties的属性：$&#123;url&#125; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">ignore-unresolvable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据源配置, 使用 Druid 数据库连接池 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSourceMaster&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span> </span><br><span class="line">	    <span class="comment">&lt;!-- 数据源驱动类可不写，Druid默认会自动根据URL识别DriverClass --&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span> /&gt;</span></span><br><span class="line">	    </span><br><span class="line">		<span class="comment">&lt;!-- 基本属性 url、user、password --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.master.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 配置初始化大小、最小、最大连接池 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.pool.init&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.pool.minIdle&#125;&quot;</span> /&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.pool.maxActive&#125;&quot;</span> /&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 配置获取连接等待超时的时间 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWait&quot;</span> <span class="attr">value</span>=<span class="string">&quot;60000&quot;</span> /&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;60000&quot;</span> /&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;300000&quot;</span> /&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;validationQuery&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.testSql&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnReturn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 打开removeAbandoned功能 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;removeAbandoned&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 1800秒，也就是30分钟 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;removeAbandonedTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1800&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置监控统计拦截的filters --&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;filters&quot;</span> <span class="attr">value</span>=<span class="string">&quot;stat&quot;</span> /&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionProperties&quot;</span> <span class="attr">value</span>=<span class="string">&quot;druid.stat.slowSqlMillis=5000&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 数据源配置, 使用 Druid 数据库连接池 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSourceSlave&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span> </span><br><span class="line">	    <span class="comment">&lt;!-- 数据源驱动类可不写，Druid默认会自动根据URL识别DriverClass --&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span> /&gt;</span></span><br><span class="line">	    </span><br><span class="line">		<span class="comment">&lt;!-- 基本属性 url、user、password --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.slave.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 配置初始化大小、最小、最大 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.pool.init&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.pool.minIdle&#125;&quot;</span> /&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.pool.maxActive&#125;&quot;</span> /&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 配置获取连接等待超时的时间 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWait&quot;</span> <span class="attr">value</span>=<span class="string">&quot;60000&quot;</span> /&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;60000&quot;</span> /&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;300000&quot;</span> /&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;validationQuery&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.testSql&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnReturn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 打开removeAbandoned功能 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;removeAbandoned&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 1800秒，也就是30分钟 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;removeAbandonedTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1800&quot;</span> /&gt;</span></span><br><span class="line">         </span><br><span class="line">		<span class="comment">&lt;!-- 配置监控统计拦截的filters --&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;filters&quot;</span> <span class="attr">value</span>=<span class="string">&quot;stat&quot;</span> /&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionProperties&quot;</span> <span class="attr">value</span>=<span class="string">&quot;druid.stat.slowSqlMillis=5000&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!--配置动态数据源，这里的targetDataSource就是路由数据源所对应的名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSourceSelector&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.rainbowhorse.common.dynamicDataSource.DataSourceSelector&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetDataSources&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">value-ref</span>=<span class="string">&quot;dataSourceMaster&quot;</span> <span class="attr">key</span>=<span class="string">&quot;master&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">value-ref</span>=<span class="string">&quot;dataSourceSlave&quot;</span> <span class="attr">key</span>=<span class="string">&quot;slave&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置数据源懒加载--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetDataSource&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;dataSourceSelector&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>说明：首先<code>读取配置文件jdbc.properties</code>，然后配置了两个具体的数据源dataSourceMaster、dataSourceSlave。里面配置了数据库连接的具体属性，然后配置了动态数据源，他将决定使用哪个具体的数据源，<strong>这里面的关键就是DataSourceSelector，接下来会实现这个bean</strong>。下一步设置了数据源的懒加载，保证在数据源加载的时候其他依赖的bean已经加载好了。接着就是常规的配置了，mybatis全局配置文件如下。</p>
<h1 id="mybatis全局配置文件"><a href="#mybatis全局配置文件" class="headerlink" title="mybatis全局配置文件"></a>mybatis全局配置文件</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 全局参数 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 使全局的映射器启用或禁用缓存。 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载。 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 当启用时，有延迟加载属性的对象在被调用时将会完全加载任意属性。否则，每种属性将会按需要加载。 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 是否允许单条sql 返回多个数据集  (取决于驱动的兼容性) default:true --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;multipleResultSetsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 是否可以使用列的别名 (取决于驱动的兼容性) default:true --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useColumnLabel&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 允许JDBC 生成主键。需要驱动器支持。如果设为了true，这个设置将强制使用被生成的主键，有一些驱动器不兼容不过仍然可以执行。  default:false  --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 指定 MyBatis 如何自动映射 数据基表的列 NONE：不隐射　PARTIAL:部分  FULL:全部  --&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PARTIAL&quot;</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 这是默认的执行类型  （SIMPLE: 简单； REUSE: 执行器可能重复使用prepared statements语句；BATCH: 执行器可以重复执行语句和批量更新）  --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SIMPLE&quot;</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 使用驼峰命名法转换字段。 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 设置本地缓存范围 session:就会有数据的共享  statement:语句范围 (这样就不会有数据的共享 ) defalut:session --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;localCacheScope&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SESSION&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置但JDBC类型为空时,某些驱动程序 要指定值,default:OTHER，插入空值时不需要指定类型 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;jdbcTypeForNull&quot;</span> <span class="attr">value</span>=<span class="string">&quot;NULL&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 插件配置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.raninbowhorse.common.dynamicDataSource.DateSourceSelectInterceptor&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>这里面的关键就是DateSourceSelectInterceptor这个拦截器，它会拦截所有的数据库操作，然后分析sql语句判断是“读”操作还是“写”操作</strong>，接下来就来实现上述的DataSourceSelector和DateSourceSelectInterceptor。</p>
<h1 id="编写DataSourceSelector"><a href="#编写DataSourceSelector" class="headerlink" title="编写DataSourceSelector"></a>编写DataSourceSelector</h1><p>DataSourceSelector就是在spring-dao.xml配置的，用于动态配置数据源。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承了AbstractRoutingDataSource，动态选择数据源</span></span><br><span class="line"><span class="comment"> * ClassName: DataSourceSelector </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rainbowhorse</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceSelector</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> DynamicDataSourceHolder.getDataSourceType();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要继承AbstractRoutingDataSource并且重写determineCurrentLookupKey()方法就可以动态配置数据源。 </p>
<h1 id="编写DynamicDataSourceHolder"><a href="#编写DynamicDataSourceHolder" class="headerlink" title="编写DynamicDataSourceHolder"></a>编写DynamicDataSourceHolder</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置数据源</span></span><br><span class="line"><span class="comment"> * ClassName: DynamicDataSourceHolder</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rainbowhorse</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSourceHolder</span> </span>&#123;</span><br><span class="line">	<span class="comment">/** 用来存取key，ThreadLocal保证了线程安全 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; CONTEXTHOLDER = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</span><br><span class="line">	<span class="comment">/** 主库 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DB_MASTER = <span class="string">&quot;master&quot;</span>;</span><br><span class="line">	<span class="comment">/** 从库 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DB_SLAVE = <span class="string">&quot;slave&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取线程的数据源</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDataSourceType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String db = CONTEXTHOLDER.get();</span><br><span class="line">		<span class="keyword">if</span> (db == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 如果db为空则默认使用主库（因为主库支持读和写）</span></span><br><span class="line">			db = DB_MASTER;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> db;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置线程的数据源</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDataSourceType</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		CONTEXTHOLDER.set(s);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 清理连接类型</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		CONTEXTHOLDER.remove();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类决定返回的数据源是master还是slave，这个类的初始化需要借助DateSourceSelectInterceptor，拦截所有的数据库操作请求，通过分析SQL语句来判断是读还是写操作，读操作就给DynamicDataSourceHolder设置slave源，写操作就给其设置master源。</p>
<h1 id="编写DateSourceSelectInterceptor"><a href="#编写DateSourceSelectInterceptor" class="headerlink" title="编写DateSourceSelectInterceptor"></a>编写DateSourceSelectInterceptor</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截数据库操作，根据sql判断是读还是写，选择不同的数据源 </span></span><br><span class="line"><span class="comment"> * ClassName: DateSourceSelectInterceptor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rainbowhorse</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Intercepts(&#123; @Signature(type = Executor.class, method = &quot;update&quot;, args = &#123; MappedStatement.class, Object.class &#125;),</span></span><br><span class="line"><span class="meta">		@Signature(type = Executor.class, method = &quot;query&quot;, args = &#123; MappedStatement.class, Object.class,</span></span><br><span class="line"><span class="meta">				RowBounds.class, ResultHandler.class &#125;) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateSourceSelectInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">	<span class="comment">/** 正则匹配 insert、delete、update操作 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REGEX = <span class="string">&quot;.*insert\\\\u0020.*|.*delete\\\\u0020.*|.*update\\\\u0020.*&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">// 判断当前操作是否有事务</span></span><br><span class="line">		<span class="keyword">boolean</span> synchonizationActive = TransactionSynchronizationManager.isSynchronizationActive();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当前事务的readOnly状态</span></span><br><span class="line">		<span class="keyword">boolean</span> readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 获取执行参数</span></span><br><span class="line">		Object[] objects = invocation.getArgs();</span><br><span class="line">		MappedStatement ms = (MappedStatement) objects[<span class="number">0</span>];</span><br><span class="line">		<span class="comment">// 默认设置使用主库</span></span><br><span class="line">		String lookupKey = DynamicDataSourceHolder.DB_MASTER;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 有事务且为readOnly=true状态</span></span><br><span class="line">		<span class="keyword">if</span> (readOnly &amp;&amp; synchonizationActive) &#123;</span><br><span class="line">			<span class="comment">// 读方法</span></span><br><span class="line">			<span class="keyword">if</span> (ms.getSqlCommandType().equals(SqlCommandType.SELECT)) &#123;</span><br><span class="line">				<span class="comment">// selectKey为自增主键（SELECT LAST_INSERT_ID()）方法,使用主库</span></span><br><span class="line">				<span class="keyword">if</span> (ms.getId().contains(SelectKeyGenerator.SELECT_KEY_SUFFIX)) &#123;</span><br><span class="line">					lookupKey = DynamicDataSourceHolder.DB_MASTER;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					BoundSql boundSql = ms.getSqlSource().getBoundSql(objects[<span class="number">1</span>]);</span><br><span class="line">					String sql = boundSql.getSql().toLowerCase(Locale.CHINA).replace(<span class="string">&quot;[\\t\\n\\r]&quot;</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">					<span class="comment">// 如果是insert、delete、update操作 使用主库</span></span><br><span class="line">					<span class="keyword">if</span> (sql.matches(REGEX)) &#123;</span><br><span class="line">						lookupKey = DynamicDataSourceHolder.DB_MASTER;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// 使用从库</span></span><br><span class="line">						lookupKey = DynamicDataSourceHolder.DB_SLAVE;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 一般使用事务的都是写操作，直接使用主库</span></span><br><span class="line">			lookupKey = DynamicDataSourceHolder.DB_MASTER;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------&quot;</span> + readOnly + <span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">		<span class="comment">// 设置数据源</span></span><br><span class="line">		DynamicDataSourceHolder.setDataSourceType(lookupKey);</span><br><span class="line">		<span class="keyword">return</span> invocation.proceed();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (target <span class="keyword">instanceof</span> Executor) &#123;</span><br><span class="line">			<span class="comment">// 如果是Executor（执行增删改查操作），则拦截下来</span></span><br><span class="line">			<span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> target;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个拦截器，所有的insert、delete、update操作设置使用master源，select会使用slave源。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>所有代码都已编写完毕，接下来就是测试了，通过打印的日志可判断是否正确。</p>
<blockquote>
<p>配置多个slave用于负载均衡时，只需要在spring-dao.xml中添加slave1、slave2、slave3……然后修改dataSourceSelector这个bean，在map标签中添加slave1、slave2、slave3……即可，具体的负载均衡策略在DynamicDataSourceHolder、DateSourceSelectInterceptor中实现即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSourceSelector&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.rainbowhorse.common.dynamicDataSource.DataSourceSelector&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetDataSources&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">value-ref</span>=<span class="string">&quot;master&quot;</span> <span class="attr">key</span>=<span class="string">&quot;master&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">value-ref</span>=<span class="string">&quot;slave1&quot;</span> <span class="attr">key</span>=<span class="string">&quot;slave1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">value-ref</span>=<span class="string">&quot;slave2&quot;</span> <span class="attr">key</span>=<span class="string">&quot;slave2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">value-ref</span>=<span class="string">&quot;slave3&quot;</span> <span class="attr">key</span>=<span class="string">&quot;slave3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>梳理一下整个流程：</p>
<p>  1、项目启动后，在依赖的bean加载完成后，数据源通过LazyConnectionDataSourceProxy开始加载，会引用dataSourceSelector加载数据源。<br>  2、DataSourceSelector会选择一个数据源，代码里设置了默认数据源为master，在初始化的时候就默认使用master源。<br>  3、在数据库操作执行时，DateSourceSelectInterceptor拦截器拦截了请求，通过分析SQL决定使用哪个数据源。<strong>“读操作”使用slave源，“写操作”使用master源</strong>。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之FactoryBean</title>
    <url>/Spring%E4%B9%8BFactoryBean/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><strong>FactoryBean</strong> 与 <strong>BeanFactory</strong>名字很像，很容易搞混。但其实它们两个是完全不一样的东东。</p>
<p><strong>BeanFactory</strong>： 以Factory结尾，表示它是一个工厂类，是用于管理Bean的一个工厂。BeanFactory是 IOC 容器的核心接口。它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。</p>
<p><strong>FactoryBean</strong>：以Bean结尾，表示它是一个Bean，不同于普通Bean的是：实现了FactoryBean<T>接口的Bean，根据该Bean的Id从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，而不是FactoryBean本身， 如果要获取FactoryBean对象，可以在id前面加一个&amp;符号来获取。<div align=center><img width="220" height="220" src="../../../../images/2019/1-3/Spring-FactoryBean.jpg" algin="center"/></div></p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>需要在调用dubbo接口时加一层自己的逻辑，实现不同的功能。例如判断直接调用别人接口还是调用HTTP接口。</p>
<p>原本有两个dubbo接口，通讯录员工、通讯录企业接口，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ZK配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">&quot;remote&quot;</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://10.113.29.1:2181?backup=10.113.29.2:2181,10.113.29.3:2181&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;dubbo&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通讯录员工接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">registry</span>=<span class="string">&quot;remote&quot;</span> <span class="attr">id</span>=<span class="string">&quot;employeeService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.facishare.open.addressbook.api.EmployeeService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;5000&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通讯录企业接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">registry</span>=<span class="string">&quot;remote&quot;</span> <span class="attr">id</span>=<span class="string">&quot;enterpriseService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.facishare.open.addressbook.api.EnterpriseService&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;5000&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="代理对象"><a href="#代理对象" class="headerlink" title="代理对象"></a>代理对象</h2><p>需要新建一个代理对象，实现上述两个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrganizationServiceProxy</span> <span class="keyword">extends</span> <span class="title">EmployeeService</span>, <span class="title">EnterpriseService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 可添加自定义方法</span></span><br><span class="line">  <span class="function">String <span class="title">getCode</span><span class="params">(String tenantId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="FactoryBean-重点"><a href="#FactoryBean-重点" class="headerlink" title="FactoryBean(重点)"></a>FactoryBean(重点)</h2><blockquote>
<p>FactoryBean有三个方法，意义非常明确：</p>
<p><strong>getObject</strong>希望返回需要注册到Spring容器中去的bean实体。</p>
<p><strong>getObjectType</strong>希望返回注册的这个Object的具体类型。</p>
<p><strong>isSingleton</strong>方法希望返回这个bean是不是单例的。如果是，那么Spring容器全局将只保持一个该实例对象，否则每次getBean都将获取到一个新的该实例对象。</p>
</blockquote>
<p>因为需要动态获取bean，所以同时实现了<em>InitializingBean</em>和<em>ApplicationContextAware</em>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrganizationServiceFactoryBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">FactoryBean</span>&lt;<span class="title">EmployeeServiceProxy</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理对象，可直接注入使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> OrganizationServiceProxy organizationServiceProxy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被代理对象的bean名称，以逗号隔开</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String beanNames;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String beanNames)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanNames = beanNames;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        OrganizationServiceFactoryBean.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrganizationServiceProxy <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> organizationServiceProxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> OrganizationServiceProxy.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Splitter.on(<span class="string">&quot;,&quot;</span>).splitToList(beanNames);</span><br><span class="line">        List&lt;Object&gt; instances = Lists.newArrayList();</span><br><span class="line">      	<span class="comment">// 判断bean是否存在走对应的条件</span></span><br><span class="line">        <span class="comment">/*if (!applicationContext.containsBean(list.get(0))) &#123;</span></span><br><span class="line"><span class="comment">            employeeServiceProxy = new EmployeeServiceProxyImpl();</span></span><br><span class="line"><span class="comment">            return;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">      </span><br><span class="line">        list.forEach(o -&gt; &#123;</span><br><span class="line">            instances.add(applicationContext.getBean(o));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        OrganizationHandler handler = <span class="keyword">new</span> OrganizationHandler(instances);</span><br><span class="line">        organizationServiceProxy = Reflection.newProxy(OrganizationServiceProxy.class, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrganizationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被代理对象实例的List集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List instances;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrganizationHandler</span><span class="params">(List instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.instances = instances;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      	<span class="comment">// OrganizationServiceProxy中的自定义方法可以在这里实现</span></span><br><span class="line">        <span class="keyword">switch</span> (method.getName()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;OrganizationServiceProxy 的toString()方法&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;getCode&quot;</span>:</span><br><span class="line">                System.out.println(args);</span><br><span class="line">            	<span class="comment">// dosomething...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (Object instance : instances) &#123;</span><br><span class="line">            Method[] methods = instance.getClass().getDeclaredMethods();</span><br><span class="line">            <span class="keyword">for</span> (Method method1 : methods) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(method1.getName())) &#123;</span><br><span class="line">                    <span class="keyword">return</span> method.invoke(instance, args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// something else...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring文件配置"><a href="#Spring文件配置" class="headerlink" title="Spring文件配置"></a>Spring文件配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--ceshi112 ZK--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">&quot;remote&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">address</span>=<span class="string">&quot;zookeeper://10.113.29.1:2181?backup=10.113.29.2:2181,10.113.29.3:2181&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">protocol</span>=<span class="string">&quot;dubbo&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通讯录员工  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">registry</span>=<span class="string">&quot;remote&quot;</span> <span class="attr">id</span>=<span class="string">&quot;employeeService&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">&quot;com.facishare.open.addressbook.api.EmployeeService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">protocol</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;5000&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通讯录企业   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">registry</span>=<span class="string">&quot;remote&quot;</span> <span class="attr">id</span>=<span class="string">&quot;enterpriseService&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">&quot;com.facishare.open.addressbook.api.EnterpriseService&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">protocol</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;5000&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>/&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 通过beanFactory获取organizationServiceProxy代理对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;organizationServiceProxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.facishare.open.demo.proxy.OrganizationServiceFactoryBean&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:beanName</span>=<span class="string">&quot;employeeService,enterpriseService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;,&quot;classpath:dubbo-consumer.xml&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrganizationServiceProxy organizationServiceProxy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListResult&lt;Integer&gt; ids = organizationServiceProxy.getAdminIds(<span class="string">&quot;61037&quot;</span>);</span><br><span class="line">        System.out.println(ids);</span><br><span class="line">        ListResult&lt;EnterpriseSimpleInfo&gt; list = organizationServiceProxy.getEnterpriseSimpleList(Lists.newArrayList(<span class="number">61037</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>FactoryBean的功能更像是一种代理。有一种场景是，我们使用一个通用的类来在xml文件中注册bean，我们希望通过该通用bean产生另外一个我们希望的bean，而这个需求FactoryBean就可以办到，只需要拦你需要代理的bean，然后转换成希望的bean再注册。一个应用场景就是Rpc服务器端的bean注册，以及Rpc客户端的服务调用，都可以通过一个第三方bean来产生我们真正需要的bean。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之动态代理</title>
    <url>/Spring%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Spring主要有两大思想，一个是AOP，一个是IOC。对于Spring的核心AOP来说，动态代理机制是其核心，想要明白AOP原理，一定要了解动态代理机制。</p>
<div align=center><img src="../../../../images/2018-4/DynamicProxy/proxy-index.jpg" algin="center"/></div>

<span id="more"></span>

<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><blockquote>
<p>给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即操作者不直接操控原对象，而是通过代理对象简介地操控原对象。</p>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>代理模式分为静态代理和动态代理：</p>
<ul>
<li>静态代理：代理类是在编译时就实现好。也就是说 Java 编译完成后代理类是一个实际的 class 文件。</li>
<li>动态代理：动态代理类的字节码是在程序运行时由Java反射机制动态生成。也就是说 Java 编译完之后并没有实际的 class 文件，而是在运行时动态生成的类字节码，并加载到JVM中。</li>
</ul>
<h1 id="Spring静态代理"><a href="#Spring静态代理" class="headerlink" title="Spring静态代理"></a>Spring静态代理</h1><blockquote>
<p>由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</p>
</blockquote>
<p>静态代理之前已经说过 <a href="http://rainbowhorse.site/spring-aop%E4%B8%A4%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F/"><em><strong>Spring-AOP两种配置方式</strong></em></a></p>
<h1 id="Spring动态代理"><a href="#Spring动态代理" class="headerlink" title="Spring动态代理"></a>Spring动态代理</h1><h2 id="JDK动态代理-对有实现接口的对象做代理"><a href="#JDK动态代理-对有实现接口的对象做代理" class="headerlink" title="JDK动态代理(对有实现接口的对象做代理)"></a>JDK动态代理(对有实现接口的对象做代理)</h2><div align=center><img src="../../../../images/2018-4/DynamicProxy/yuanli.png" algin="center"/></div>

<h3 id="实现方式说明"><a href="#实现方式说明" class="headerlink" title="实现方式说明"></a>实现方式说明</h3><p>JDK动态代理中 需要了解的两个重要的类或接口 [<strong>InvocationHandler</strong> 和 <strong>Proxy</strong>]</p>
<ol>
<li>InvocationHandler接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数说明：</span></span><br><span class="line">    <span class="comment">// Object proxy：指被代理的对象</span></span><br><span class="line">    <span class="comment">// Method method：所要调用被代理对象的某个方法的Method对象</span></span><br><span class="line">    <span class="comment">// Object[] args：被代理对象某个方法调用时所需要的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>可以将InvocationHandler接口的子类想象成一个代理的最终操作类。</p>
<p>说明：<strong>每一个动态代理对象都必须要实现InvocationHandler这个接口</strong>，并且每个代理类（Proxy）的实例都关联到了一个handle，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为InvocationHandler这个接口的invoke方法来进行调用。同时在invoke的方法里，可以对被代理对象的方法调用做增强处理(如添加事务、日志、权限认证等操作)。</p>
<ol start="2">
<li>Proxy类</li>
</ol>
<p>Proxy类是专门完成代理的操作类，可以通过此类为一个或多个接口动态地生成实现类，该类常用的调用方法为<strong>newProxyInstance</strong></p>
<div align=center><img src="../../../../images/2018-4/DynamicProxy/interfere.png" algin="center"/></div>

<p>newProxyInstance方法参数说明如下：</p>
<ul>
<li>ClassLoader loader：类加载器，定义了由哪个ClassLoader对象来对生成的代理对象进行加载</li>
<li>Class&lt;?&gt;[] interfaces：得到被代理类全部的接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口，这样我就能调用这组接口中的方法了</li>
<li>InvocationHandler h：得到InvocationHandler接口的子类实例</li>
</ul>
<h3 id="实现实例"><a href="#实现实例" class="headerlink" title="实现实例"></a>实现实例</h3><p>一、首先定义了一个Subject类型的接口：Subject.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 学习</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 说话</span></span><br><span class="line">	<span class="function">String <span class="title">say</span><span class="params">(String words)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二、接着定义一个接口的实现类，这个类就是我们示例中的被代理对象：RealSubject.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被代理类</span></span><br><span class="line"><span class="comment"> * ClassName: RealSubject </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rainbowhorse</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;I am study now.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(String words)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;I say &quot;</span> + words;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三、定义一个动态代理类（必须要实现 InvocationHandler 接口）：DynamicProxy.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK动态代理类</span></span><br><span class="line"><span class="comment"> * ClassName: DynamicProxy </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rainbowhorse</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 这个就是要代理的真实对象</span></span><br><span class="line">	<span class="keyword">private</span> Object subject;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造方法，给要代理的真实对象赋初值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object subject)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.subject = subject;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">// 在代理真实对象前可以添加一些自己的操作</span></span><br><span class="line">		System.out.println(<span class="string">&quot;before method&quot;</span>);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;Method:&quot;</span> + method);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span></span><br><span class="line">		Object invoke = method.invoke(subject, args);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 在代理真实对象后也可以添加一些自己的操作</span></span><br><span class="line">		System.out.println(<span class="string">&quot;after method&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> invoke;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四、代理测试类：Client.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 要代理的真实对象</span></span><br><span class="line">		Subject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的</span></span><br><span class="line">		InvocationHandler handler = <span class="keyword">new</span> DynamicProxy(realSubject);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 通过Proxy的newProxyInstance方法来动态创建我们的代理对象</span></span><br><span class="line"><span class="comment">		 * 参数一：这里使用handler这个类的ClassLoader对象来加载代理对象</span></span><br><span class="line"><span class="comment">		 * 参数二：这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样就能调用这组接口中的方法了</span></span><br><span class="line"><span class="comment">		 * 参数三：这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Subject subject = (Subject) Proxy.newProxyInstance(handler.getClass().getClassLoader(),</span><br><span class="line">				realSubject.getClass().getInterfaces(), handler);</span><br><span class="line"></span><br><span class="line">		System.out.println(subject.getClass().getName());</span><br><span class="line">		subject.study();</span><br><span class="line">		System.out.println();</span><br><span class="line">		</span><br><span class="line">		String string = subject.say(<span class="string">&quot;Hello World.&quot;</span>);</span><br><span class="line">		System.out.println(string);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行-&gt;控制台输出结果如下</p>
<div align=center><img src="../../../../images/2018-4/DynamicProxy/JDKProxy.png" algin="center"/></div>

<h2 id="CGLib动态代理-对没有实现接口的普通类做代理"><a href="#CGLib动态代理-对没有实现接口的普通类做代理" class="headerlink" title="CGLib动态代理[对没有实现接口的普通类做代理]"></a>CGLib动态代理[对没有实现接口的普通类做代理]</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p> CGLib（Code Generation Library）是一个优秀的动态代理框架，它的底层使用ASM（JAVA字节码处理框架）在内存中动态的生成被代理类的子类。使用CGLib即使被代理类没有实现任何接口也可以实现动态代理功能。但是不能对final修饰的类进行代理。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>  通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用。<strong>JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。</strong></p>
<h3 id="实现实例-1"><a href="#实现实例-1" class="headerlink" title="实现实例"></a>实现实例</h3><p>一、定义一个没有实现接口的代理委托类：CGLibRealSubject.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没有实现接口的代理委托类 </span></span><br><span class="line"><span class="comment"> * ClassName: CGLibRealSubject </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rainbowhorse</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibRealSubject</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;I am study now.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(String words)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;I say &quot;</span> + words;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二、定义一个CGLib动态代理类: CGLibDynamicProxy.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibDynamicProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 创建代理对象</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">	 *            被代理的对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">		<span class="comment">// 声明增强类实例</span></span><br><span class="line">		Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">		<span class="comment">// 设置被代理类字节码，CGLIB根据字节码生成被代理类的子类</span></span><br><span class="line">		enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">		<span class="comment">// 设置要代理的拦截器，回调函数，即一个方法拦截 new MethodInterceptor()</span></span><br><span class="line">		enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">// 创建代理对象 实例</span></span><br><span class="line">		<span class="keyword">return</span> enhancer.create();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 在代理真实对象操作前 我们可以添加一些自己的操作</span></span><br><span class="line">		System.out.println(<span class="string">&quot;before method&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Object object = proxy.invokeSuper(obj, args);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 在代理真实对象操作后 我们也可以添加一些自己的操作</span></span><br><span class="line">		System.out.println(<span class="string">&quot;after method&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> object;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三、创建测试客户端类：CGLibClient.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  CGLib动态代理测试类</span></span><br><span class="line"><span class="comment"> * ClassName: CGLibClient </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rainbowhorse</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibClient</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		CGLibDynamicProxy cglib = <span class="keyword">new</span> CGLibDynamicProxy();</span><br><span class="line">		CGLibRealSubject realSubject = (CGLibRealSubject) cglib.getProxyInstance(<span class="keyword">new</span> CGLibRealSubject());</span><br><span class="line">		</span><br><span class="line">		realSubject.study();</span><br><span class="line">		System.out.println();</span><br><span class="line">		</span><br><span class="line">		System.out.println(realSubject.say(<span class="string">&quot;Hello World.&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行-&gt;控制台输出结果如下</p>
<div align=center><img src="../../../../images/2018-4/DynamicProxy/cglibResult.png" algin="center"/></div>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Spirng的AOP的动态代理实现机制有两种，分别是:</p>
<p><strong>1）JDK动态代理</strong></p>
<p><strong>具体实现原理：</strong></p>
<ol>
<li>通过实现InvocationHandlet接口创建自己的调用处理器</li>
<li>通过为Proxy类指定ClassLoader对象和一组interface来创建动态代理</li>
<li>通过反射机制获取动态代理类的构造函数，其唯一参数类型就是调用处理器接口类型</li>
<li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数参入</li>
</ol>
<p><strong>JDK动态代理是面向接口的代理模式，如果被代理目标没有接口那么Spring也无能为力</strong></p>
<p><strong>Spring通过java的反射机制生产被代理接口的新的匿名实现类，重写了其中AOP的增强方法。</strong></p>
<p><strong>2）CGLib动态代理</strong></p>
<p><strong>CGLib是一个强大、高性能的Code生产类库，可以实现运行期动态扩展java类，Spring在运行期间通过CGlib继承要被动态代理的类，重写父类的方法，实现AOP面向切面编程。</strong></p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ul>
<li>JDK动态代理是面向接口，在创建代理实现类时比CGLib要快，创建代理速度快。</li>
</ul>
<ul>
<li>CGLib动态代理是通过字节码底层继承要代理类来实现（如果被代理类被final关键字所修饰，那么会失败），在创建代理这一块没有JDK动态代理快，但是运行速度比JDK动态代理要快。</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li><div align=center><img src="../../../../images/2018-4/MySQL_master_slave/db_2.png" algin="center"/></div></li>
</ul>
<ul>
<li>如果要被代理的对象<strong>不是个实现类</strong>，那么Spring会<strong>强制使用CGLib来实现动态代理</strong>。</li>
</ul>
<h2 id="Spring中配置动态代理方式"><a href="#Spring中配置动态代理方式" class="headerlink" title="Spring中配置动态代理方式"></a>Spring中配置动态代理方式</h2><p>通过配置Spring的中**<a href="aop:config">aop:config</a>**标签来显示的指定使用动态代理机制 <strong>proxy-target-class=true表示使用CGLib代理，如果为false就是默认使用JDK动态代理</strong>。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring反射调用Bean方法</title>
    <url>/Spring%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8Bean%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><code>Spring</code>通过<code>ApplicationContextAware</code>反射调用服Bean方法，<code>ApplicationContextAware</code>常用方法封装。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringReflectUtils</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring容器 spring应用上下文对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        SpringReflectUtils.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * bean名称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 要查询的bean的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true：包含</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.containsBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过对象名称获取spring bean对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name bean的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回与给定对象类型唯一匹配的bean实例(如果有)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requiredType bean 必须匹配的类型； 可以是接口或超</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 匹配所需类型的单个 bean 的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBean(requiredType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回与给定对象类型（包括子类）匹配的 bean 实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 要匹配的类或接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Map&lt;bean名称, bean实例&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Map&lt;String, T&gt; <span class="title">getBeansOfType</span><span class="params">(Class&lt;T&gt; type)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBeansOfType(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据bean名称、方法名反射调用spring bean中的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName 服务名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName  方法名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> params      参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">springInvokeMethod</span><span class="params">(String serviceName, String methodName, Object[] params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object service = getBean(serviceName);</span><br><span class="line">        Class&lt;? extends Object&gt;[] paramClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (params != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> paramsLength = params.length;</span><br><span class="line">            paramClass = <span class="keyword">new</span> Class[paramsLength];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paramsLength; i++) &#123;</span><br><span class="line">                paramClass[i] = params[i].getClass();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到方法</span></span><br><span class="line">        Method method = ReflectionUtils.findMethod(service.getClass(), methodName, paramClass);</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        <span class="keyword">return</span> ReflectionUtils.invokeMethod(method, service, params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>UML工具-PowerDesigner设计数据库</title>
    <url>/UML%E5%B7%A5%E5%85%B7-PowerDesigner%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在数据库的开发设计中，PowerDesiger（PD）是一个较为常用的UML工具。PowerDesiger为各类数据模型提供了直观的符号表示，不仅使设计人员能更方便、更快捷地使非计算机专业技术人员展示数据库设计和应用系统设计，使系统设计人员与使用系统的业务人员更易于相互理解和交流，同时也使项目组内的交流更为直观、准确，更便于协调工作，从而加速系统的设计和开发过程。PowerDesiger设计完成后的数据库可直接生成SQL语句。<div align=center><img width="200" height="100" src="../../../../images/2017/12/PowerDesigner/logo-powerdesigner.png" algin="center"/></div><span id="more"></span></p>
<h1 id="使用ODBC连接MySQL"><a href="#使用ODBC连接MySQL" class="headerlink" title="使用ODBC连接MySQL"></a>使用ODBC连接MySQL</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><strong>PowerDesigner本身是32位的程序（特别重要），故不管在32位或者64位操作系统中，都需要安装32位的MySQL Connector /ODBC。</strong></p>
<p>MySQL Connector /ODBC下载地址：<em><a href="https://dev.mysql.com/downloads/connector/odbc/">https://dev.mysql.com/downloads/connector/odbc/</a></em></p>
<h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><ol>
<li>安装完ODBC之后，打开PowerDesigner，新建一个Model，File—&gt;New Model</li>
</ol>
<div align=center><img width="500" height="300" src="../../../../images/2017/12/PowerDesigner/2.png" algin="center"/>

</div>

<ol start="2">
<li>选择工具栏中的Database—&gt; Update Model from Database，如下图</li>
</ol>
<div align=center><img width="450" height="300" src="../../../../images/2017/12/PowerDesigner/3.png" algin="center"/>

</div>

<ol start="3">
<li>打开配置对话框，选择[Using a data source]，点击输入框后的图标</li>
</ol>
<div align=center><img width="450" height="300" src="../../../../images/2017/12/PowerDesigner/4.png" algin="center"/>

</div>

<ol start="4">
<li>配置ODBC数据源</li>
</ol>
<div align=center><img width="450" height="300" src="../../../../images/2017/12/PowerDesigner/5.png" algin="center"/></div>

<div align=center><img width="450" height="300" src="../../../../images/2017/12/PowerDesigner/6.png" algin="center"/></div>

<div align=center><img width="450" height="300" src="../../../../images/2017/12/PowerDesigner/7.png" algin="center"/></div>

<p>说明：这里提供了ANSI和Unicode两种字符集版本的Driver，<strong>Unicode提供更丰富的字符集，一般推荐使用Unicode</strong>。</p>
<div align=center><img width="450" height="300" src="../../../../images/2017/12/PowerDesigner/8.png" algin="center"/></div>

<div align=center><img width="450" height="300" src="../../../../images/2017/12/PowerDesigner/9.png" algin="center"/></div>

<p>点击完成，配置连接信息。</p>
<div align=center><img width="450" height="300" src="../../../../images/2017/12/PowerDesigner/10.png" algin="center"/></div>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">说明：</span><br><span class="line">Data Source Name：指定当前配置的ODBC数据源名称，可随意填写。</span><br><span class="line">Description：指定ODBC数据源的描述信息，可根据用途随意填写。</span><br><span class="line">TCP/IP Server：采用TCP/IP协议连接服务器，如果是本地填写localhost或者127.0.0.1（根据实际MySQL用户情况选择），如果是远程服务器则填写相应IP地址即可。</span><br><span class="line">Port：默认3306，根据实际MySQL的端口设置填写。</span><br><span class="line">lNamed Pipe：命名管道方式连接，只适用于widows下的本地连接。连接性能比TCP/IP方式更高，更安全。请按照MySQL的配置文件my.ini中的socket参数指定的值填写，如果没有设置则默认为MySQL（但是目前为止这种方式我还没有测试成功）。</span><br><span class="line">User：数据库用户名。</span><br><span class="line">Password：数据库密码。</span><br><span class="line">Database：数据库中的database。</span><br></pre></td></tr></table></figure>

<p>信息输入完之后可以选择Test测试配置是否正确，点击OK就结束了配置。</p>
<div align=center><img width="450" height="300" src="../../../../images/2017/12/PowerDesigner/12.png" algin="center"/></div>

<div align=center><img width="450" height="300" src="../../../../images/2017/12/PowerDesigner/13.png" algin="center"/></div>

<div align=center><img width="450" height="300" src="../../../../images/2017/12/PowerDesigner/14.png" algin="center"/></div>

<div align=center><img width="450" height="300" src="../../../../images/2017/12/PowerDesigner/15.png" algin="center"/></div>

<p>到这里已经可以连接数据库了。</p>
<h1 id="设计数据库"><a href="#设计数据库" class="headerlink" title="设计数据库"></a>设计数据库</h1><p>如果在已有的数据库上需要设计和修改，先取消所有表，再选择需要设计或修改的数据库，选择表，点击ok。</p>
<div align=center><img width="450" height="300" src="../../../../images/2017/12/PowerDesigner/2-1.png" algin="center"/></div>

<p>连接后的UML如下，可以新建和修改表</p>
<div align=center><img width="450" height="300" src="../../../../images/2017/12/PowerDesigner/2-2.png" algin="center"/></div>

<p>同时可对表进行主外键设计，现在主外键已经很少用到了。</p>
<div align=center><img width="450" height="300" src="../../../../images/2017/12/PowerDesigner/2-3.png" algin="center"/></div>

<p>双击表之间的连接线，点击Joins</p>
<div align=center><img width="450" height="300" src="../../../../images/2017/12/PowerDesigner/2-4.png" algin="center"/></div>

<p>点击【确定】按钮，即可如我们所愿： </p>
<div align=center><img width="450" height="300" src="../../../../images/2017/12/PowerDesigner/2-6.png" algin="center"/></div>

<h1 id="生成建表语句"><a href="#生成建表语句" class="headerlink" title="生成建表语句"></a>生成建表语句</h1><p>点击Database—&gt;Generate Database</p>
<div align=center><img width="450" height="300" src="../../../../images/2017/12/PowerDesigner/2-7.png" algin="center"/></div>

<div align=center><img width="450" height="300" src="../../../../images/2017/12/PowerDesigner/2-8.png" algin="center"/></div>

<p>点击【确定】按钮之后，可以在桌面上找到shiro.sql这样的一个文件，打开，即可看到建表语句： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"><span class="comment">/* DBMS name:      MySQL 5.0                                    */</span></span><br><span class="line"><span class="comment">/* Created on:     2017.12.6 17:22:25                          */</span></span><br><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> shiro.u_permission;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> shiro.u_role;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> shiro.u_role_permission;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> shiro.u_user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> shiro.u_user_role;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"><span class="comment">/* User: shiro                                                  */</span></span><br><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> shiro;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"><span class="comment">/* Table: u_permission                                          */</span></span><br><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> shiro.u_permission</span><br><span class="line">(</span><br><span class="line">   id                   <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">   url                  <span class="type">national</span> <span class="type">varchar</span>(<span class="number">256</span>) comment <span class="string">&#x27;url地址&#x27;</span>,</span><br><span class="line">   name                 <span class="type">national</span> <span class="type">varchar</span>(<span class="number">64</span>) comment <span class="string">&#x27;url描述&#x27;</span>,</span><br><span class="line">   <span class="keyword">primary</span> key (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"><span class="comment">/* Table: u_role                                                */</span></span><br><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> shiro.u_role</span><br><span class="line">(</span><br><span class="line">   id                   <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">   name                 <span class="type">national</span> <span class="type">varchar</span>(<span class="number">32</span>) comment <span class="string">&#x27;角色名称&#x27;</span>,</span><br><span class="line">   type                 <span class="type">national</span> <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;角色类型&#x27;</span>,</span><br><span class="line">   <span class="keyword">primary</span> key (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"><span class="comment">/* Table: u_role_permission                                     */</span></span><br><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> shiro.u_role_permission</span><br><span class="line">(</span><br><span class="line">   rid                  <span class="type">bigint</span>(<span class="number">20</span>) comment <span class="string">&#x27;角色ID&#x27;</span>,</span><br><span class="line">   pid                  <span class="type">bigint</span>(<span class="number">20</span>) comment <span class="string">&#x27;权限ID&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"><span class="comment">/* Table: u_user                                                */</span></span><br><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> shiro.u_user</span><br><span class="line">(</span><br><span class="line">   id                   <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">   nickname             <span class="type">national</span> <span class="type">varchar</span>(<span class="number">20</span>) comment <span class="string">&#x27;用户昵称&#x27;</span>,</span><br><span class="line">   email                <span class="type">national</span> <span class="type">varchar</span>(<span class="number">128</span>) comment <span class="string">&#x27;邮箱|登录帐号&#x27;</span>,</span><br><span class="line">   pswd                 <span class="type">national</span> <span class="type">varchar</span>(<span class="number">32</span>) comment <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">   create_time          datetime comment <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">   last_login_time      datetime comment <span class="string">&#x27;最后登录时间&#x27;</span>,</span><br><span class="line">   status               <span class="type">bigint</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="number">1</span> comment <span class="string">&#x27;1:有效，0:禁止登录&#x27;</span>,</span><br><span class="line">   <span class="keyword">primary</span> key (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"><span class="comment">/* Table: u_user_role                                           */</span></span><br><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> shiro.u_user_role</span><br><span class="line">(</span><br><span class="line">   uid                  <span class="type">bigint</span>(<span class="number">20</span>) comment <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">   rid                  <span class="type">bigint</span>(<span class="number">20</span>) comment <span class="string">&#x27;角色ID&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> shiro.u_user_role <span class="keyword">add</span> <span class="keyword">constraint</span> FK_Reference_1 <span class="keyword">foreign</span> key (uid)</span><br><span class="line">      <span class="keyword">references</span> shiro.u_user (id) <span class="keyword">on</span> <span class="keyword">delete</span> restrict <span class="keyword">on</span> update restrict;</span><br></pre></td></tr></table></figure>

<p>得到SQL语句后可直接导入到数据库。由此我们设计数据库已经完成。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里只是简单介绍了PowerDesigner进行数据库模型设计，自动生成SQL语句等功能。PowerDesigner还有很多技巧和功能在摸索中。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>About</title>
    <url>/about/</url>
    <content><![CDATA[<p>​                    </p>
<p>​                    喜欢新鲜的事物，钻研技术，热爱互联网行业🍭。</p>
<p>​                                做自己喜欢做的事。</p>
<p>​                            菜鸟程序猿一只，欢迎分享知识。</p>
<p>​                                                                    From 🌈彩虹马</p>
]]></content>
  </entry>
  <entry>
    <title>logback推荐配置</title>
    <url>/logback%E6%8E%A8%E8%8D%90%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>大约从16年，不管是我参与别人已搭建好的项目还是自己单独搭建的项目，日志框架基本都换成了logback。</p>
<div align=center><img src="../../../../images/2018-8/logback.jpg" algin="center"/></div><span id="more"></span>
# logback优点

<ul>
<li>内核重写、测试充分、初始化内存加载更小，这一切让logback性能和log4j相比有诸多倍的提升</li>
<li>logback非常自然地直接实现了slf4j，这个严格来说算不上优点，只是这样，再理解slf4j的前提下会很容易理解logback，也同时很容易用其他日志框架替换logback</li>
<li>logback有比较齐全的文档</li>
<li>logback当配置文件修改了，支持自动重新加载配置文件，扫描过程快且安全，它并不需要另外创建一个扫描线程</li>
<li>支持自动去除旧的日志文件，可以控制已经产生日志文件的最大数量</li>
</ul>
<h1 id="配置的正确姿势"><a href="#配置的正确姿势" class="headerlink" title="配置的正确姿势"></a>配置的正确姿势</h1><p>我们大部分Java后台都是Maven工程，标准目录如下：</p>
<table>
<thead>
<tr>
<th align="center">包路径</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">src/main/java</td>
<td align="center">java源代码文件，编译到target/classes</td>
</tr>
<tr>
<td align="center">src/main/resource</td>
<td align="center">正式包资源库，编译时会复制到target/classes</td>
</tr>
<tr>
<td align="center">src/test/java</td>
<td align="center">测试java源代码文件，编译到target/test-classes</td>
</tr>
<tr>
<td align="center">src/test/resource</td>
<td align="center">测试时资源库，编译时复制到target/test-classes</td>
</tr>
</tbody></table>
<p>建议配置2个logback配置文件：</p>
<table>
<thead>
<tr>
<th align="center">路径</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">src/main/resources/logback.xml</td>
<td align="center">异步打印到按天轮转的日志文件中。jar包不要配置，避免污染业务配置。</td>
</tr>
<tr>
<td align="center">src/test/resources/logback-test.xml</td>
<td align="center">测试时候使用，打印到stdout</td>
</tr>
</tbody></table>
<ol>
<li>线上和开发环境的配置要分离，对于java项目：<ol>
<li>src/main/resources 目录下的东西都是正式环境使用的</li>
<li>src/test/resources 目录下的东西才是本机开发环境使用的</li>
</ol>
</li>
</ol>
<p>如果发现自己本机开发启动程序的时候，经常要修改 src/main/resources 目录下的东东，那就说明用错了。<br>这样做的一个后果就是，当提交代码的时候，忘记修改回来，结果发布到线上去了。轻则日志量暴增，重则引起运营事故。所以一定千万注意！</p>
<h1 id="推荐的配置内容"><a href="#推荐的配置内容" class="headerlink" title="推荐的配置内容"></a>推荐的配置内容</h1><h2 id="logback-xml-推荐配置1"><a href="#logback-xml-推荐配置1" class="headerlink" title="logback.xml 推荐配置1"></a>logback.xml 推荐配置1</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;false&quot;</span> <span class="attr">scanPeriod</span>=<span class="string">&quot;60 seconds&quot;</span> <span class="attr">debug</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;RollingFile&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 可让每天产生一个日志文件，最多 7 个，自动回滚 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;catalina.home&#125;/logs/fs-app-%d&#123;yyyyMMdd&#125;.log.zip<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>7<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 异常栈中去掉包含如下字符的行避免打印很多无用的信息--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;12&#125; %msg%rEx&#123;full,</span><br><span class="line">                java.lang.Thread,</span><br><span class="line">                javassist,</span><br><span class="line">                sun.reflect,</span><br><span class="line">                org.springframework,</span><br><span class="line">                org.apache,</span><br><span class="line">                org.eclipse.jetty,</span><br><span class="line">                $Proxy,</span><br><span class="line">                java.net,</span><br><span class="line">                java.io,</span><br><span class="line">                javax.servlet,</span><br><span class="line">                org.junit,</span><br><span class="line">                com.mysql,</span><br><span class="line">                com.sun,</span><br><span class="line">                org.mybatis.spring,</span><br><span class="line">                cglib,</span><br><span class="line">                CGLIB,</span><br><span class="line">                java.util.concurrent,</span><br><span class="line">                okhttp,</span><br><span class="line">                org.jboss,</span><br><span class="line">                &#125;%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 异步输出日志避免阻塞服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ASYNC&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">queueSize</span>&gt;</span>512<span class="tag">&lt;/<span class="name">queueSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFile&quot;</span>/&gt;</span></span><br><span class="line">      	<span class="tag">&lt;<span class="name">includeCallerData</span>&gt;</span>true<span class="tag">&lt;/<span class="name">includeCallerData</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 配置基础组件为WARN级别，避免打印过多影响服务自己日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;druid.sql&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.hibernate&quot;</span> <span class="attr">level</span>=<span class="string">&quot;WARN&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework&quot;</span> <span class="attr">level</span>=<span class="string">&quot;WARN&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache&quot;</span> <span class="attr">level</span>=<span class="string">&quot;WARN&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ASYNC&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="logback-xml-推荐配置2"><a href="#logback-xml-推荐配置2" class="headerlink" title="logback.xml 推荐配置2"></a>logback.xml 推荐配置2</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;WARN&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">File</span>&gt;</span>$&#123;catalina.base&#125;/logs/warn.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>WARN<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;yyyy/MM/dd-HH:mm:ss.SSS&#125;]-[%level]-[%thread]-[%class:%line]- %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;catalina.base&#125;/logs/warn.%d&#123;yyyy-MM-dd&#125;.log.zip<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ALL&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">File</span>&gt;</span>$&#123;catalina.base&#125;/logs/all.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;yyyy/MM/dd-HH:mm:ss.SSS&#125;]-[%level]-[%thread]-[%class:%line]- %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;catalina.base&#125;/logs/all.%d&#123;yyyy-MM-dd&#125;.log.zip<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>7<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;yyyy/MM/dd-HH:mm:ss.SSS&#125;]-[%level]-[%thread]-[%class:%line]- %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.facishare.open&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;WARN&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ALL&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;WARN&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ALL&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="logback-test-xml-推荐配置"><a href="#logback-test-xml-推荐配置" class="headerlink" title="logback-test.xml 推荐配置"></a>logback-test.xml 推荐配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;false&quot;</span> <span class="attr">scanPeriod</span>=<span class="string">&quot;60 seconds&quot;</span> <span class="attr">debug</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;12&#125; %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.hibernate&quot;</span> <span class="attr">level</span>=<span class="string">&quot;WARN&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework&quot;</span> <span class="attr">level</span>=<span class="string">&quot;WARN&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache&quot;</span> <span class="attr">level</span>=<span class="string">&quot;WARN&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="推荐日志级别"><a href="#推荐日志级别" class="headerlink" title="推荐日志级别"></a>推荐日志级别</h1><p>极为严格的做法是：只要*log.error()*记录的内容，都需要人及时响应的，有些公司会针对error进行字符串告警。<br>那么，针对一些如：没有权限、参数错误、非法请求等，由于不合理的请求进来的，就建议打印warn而不是error，否则狼来了喊多了就没有用了。也会淹没真正的错误。<br>简单来讲，真正影响到正常用户的正常请求而且需要及时响应的错误，就打印ERROR，否则打印WARN。<br>一般信息打印info，针对调试操作，打印debug。</p>
<h1 id="推荐使用日志占位符"><a href="#推荐使用日志占位符" class="headerlink" title="推荐使用日志占位符"></a>推荐使用日志占位符</h1><blockquote>
<p>log.info(“this is a={}, b={}”, a, b)</p>
</blockquote>
<p>使用占位符，是真正需要打印的时候，才进行字符串拼接；如果不打印就不会拼接字符串。</p>
<blockquote>
<p>log.error(“cannot open url={}”, url, e)</p>
</blockquote>
<p>针对error，务必把异常栈打印出来，这里有一个exception对象，不需要使用占位符，如果多一个占位符，则只会打印<code>e.getMessage()</code>的内容，就不方便查问题了。 </p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>logback行号输出问号问题</title>
    <url>/logback%E8%A1%8C%E5%8F%B7%E8%BE%93%E5%87%BA%E9%97%AE%E5%8F%B7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Logback日志输出使用 <code>AsyncAppender</code> 时，输出的文件行号信息是 <strong>?:?</strong> ，问题产生原因及解决方案。<span id="more"></span></p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在 <a href="http://rainbowhorse.site/logback%E6%8E%A8%E8%8D%90%E9%85%8D%E7%BD%AE/">logback推荐配置</a> 一文中，列举了logback常用的几种配置，使用的是logback异步输出日志AsyncAppender。但在实际的开发中，遇到了日志没有输出类和行号，而输出的文件行号信息是 **?:?**。</p>
<p>输出的日志类似于这种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">framework-server-demo 2017-07-17 14:15:11,876 INFO [main] o.s.j.e.a.AnnotationMBeanExporter [?:?] - Located managed bean &#x27;refreshScope&#x27;: registering with JMX server as MBean [org.springframework.cloud.context.scope.refresh:name=refreshScope,type=RefreshScope]</span><br><span class="line">framework-server-demo 2017-07-17 14:15:11,881 INFO [main] o.s.j.e.a.AnnotationMBeanExporter [?:?] - Located managed bean &#x27;configurationPropertiesRebinder&#x27;: registering with JMX server as MBean [org.springframework.cloud.context.properties:name=configurationPropertiesRebinder,context=43f2f92d,type=ConfigurationPropertiesRebinder]</span><br><span class="line">framework-server-demo 2017-07-17 14:15:11,887 INFO [main] o.s.j.e.a.AnnotationMBeanExporter [?:?] - Located managed bean &#x27;refreshEndpoint&#x27;: registering with JMX server as MBean [org.springframework.cloud.endpoint:name=refreshEndpoint,type=RefreshEndpoint]</span><br><span class="line">framework-server-demo 2017-07-17 14:15:11,888 INFO [main] o.s.b.a.e.j.EndpointMBeanExporter [?:?] - Registering beans for JMX exposure on startup</span><br><span class="line">framework-server-demo 2017-07-17 14:15:12,709 INFO [main] application [?:?] - jolokia: No access restrictor found, access to any MBean is allowed</span><br><span class="line">framework-server-demo 2017-07-17 14:15:12,714 INFO [main] application [?:?] - jolokia: jolokia:type=Config is already registered. Adding it with jolokia:type=Config,uuid=43140813-0dc0-413d-96c0-5de1799eadd3, but you should revise your setup in order to either use a qualifier or ensure, that only a single agent gets registered (otherwise history functionality might not work)</span><br><span class="line">framework-server-demo 2017-07-17 14:15:12,714 INFO [main] application [?:?] - jolokia: Cannot register (legacy) MBean handler for config store with name jmx4perl:type=Config since it already exists. This is the case if another agent has been already started within the same JVM. The registration is skipped.</span><br><span class="line">framework-server-demo 2017-07-17 14:15:12,715 INFO [main] application [?:?] - jolokia: Jolokia Discovery MBean registration is skipped because there is already one registered.</span><br></pre></td></tr></table></figure>

<h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>输出文件以及行号信息需要 <code>stacktrace</code> 获取 <code>callerdata</code>，<strong>因为性能原因 logback 的 AsyncAppender 默认是不记录该信息。即默认为false</strong>。</p>
<p>官方文档： <a href="https://logback.qos.ch/manual/appenders.html#AsyncAppender">https://logback.qos.ch/manual/appenders.html#AsyncAppender</a></p>
<table>
<thead>
<tr>
<th>Property Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>includeCallerData</td>
<td>boolean</td>
<td>Extracting caller data can be rather expensive. To improve performance, by default, caller data associated with an event is not extracted when the event added to the event queue. By default, only “cheap” data like the thread name and the MDC are copied. You can direct this appender to include caller data by setting the includeCallerData property to true.</td>
</tr>
</tbody></table>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>如文档说明，只需要在 <strong>logback</strong> 配置文件里 <strong>AsyncAppender</strong> 中添加 <strong>includeCallerData</strong> 并设置为 <strong>true</strong> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;includeCallerData&gt;true&lt;/includeCallerData&gt; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-AOP两种配置方式</title>
    <url>/spring-aop%E4%B8%A4%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。<div align=center><img width="600" height="200" src="../../../../images/2017-9-12/SpringAOP/spring.png" algin="center"/></div><span id="more"></span></p>
<p>AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p>
<p>使用”横切”技术，AOP把软件系统分为两个部分：<strong>核心关注点</strong>和<strong>横切关注点</strong>。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如<code>权限认证</code>、<code>日志</code>、<code>事务</code>。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p>
<h2 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h2><p>1、横切关注点</p>
<p>对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点</p>
<p>2、切面（Aspect）</p>
<p>类是对物体特征的抽象，切面就是对横切关注点的抽象</p>
<p>3、连接点（Joinpoint）</p>
<p>被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器</p>
<p>4、切入点（Pointcut）</p>
<p>对连接点进行拦截的定义</p>
<p>5、通知（Advice）</p>
<p>所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类</p>
<p>6、目标对象</p>
<p>代理的目标对象</p>
<p>7、织入（Weave）</p>
<p>将切面应用到目标对象并导致代理对象创建的过程</p>
<p>8、引入（Introduction）</p>
<p>在不修改代码的前提下，引入可以在<strong>运行期</strong>为类动态地添加一些方法或字段</p>
<h2 id="Spring对AOP的支持"><a href="#Spring对AOP的支持" class="headerlink" title="Spring对AOP的支持"></a>Spring对AOP的支持</h2><p><strong>Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理</strong>。因此，AOP代理可以直接使用容器中的其它bean实例作为目标，这种关系可由IOC容器的依赖注入提供。Spring创建代理的规则为：</p>
<p>1、<strong>默认使用Java动态代理来创建AOP代理</strong>，这样就可以为任何接口实例创建代理了</p>
<p>2、<strong>当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理</strong>，也可强制使用CGLIB</p>
<p>AOP编程其实是很简单的事情，纵观AOP编程，程序员只需要参与三个部分：</p>
<p>1、定义普通业务组件</p>
<p>2、定义切入点，一个切入点可能横切多个业务组件</p>
<p>3、定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作</p>
<p>所以进行AOP编程的关键就是定义切入点和定义增强处理，一旦定义了合适的切入点和增强处理，AOP框架将自动生成AOP代理，即：<strong>代理对象的方法=增强处理+被代理对象</strong>的方法。</p>
<div align=center><img width="700" height="300" src="../../../../images/2017-9-12/SpringAOP/Aop.png" algin="center"/>

</div>

<h1 id="Spring配置AOP的两种方式"><a href="#Spring配置AOP的两种方式" class="headerlink" title="Spring配置AOP的两种方式"></a>Spring配置AOP的两种方式</h1><h2 id="注解配置AOP"><a href="#注解配置AOP" class="headerlink" title="注解配置AOP"></a>注解配置AOP</h2><p>注解配置AOP（使用 AspectJ 类库实现的），大致分为三步： </p>
<ol>
<li>使用注解@Aspect来定义一个切面，在切面中定义切入点(@Pointcut),通知类型(@Before, @AfterReturning,@After,@AfterThrowing,@Around). </li>
<li>开发需要被拦截的类。 </li>
<li>将切面配置到xml中，当然，我们也可以使用自动扫描Bean的方式。这样的话，那就交由Spring AOP容器管理。 </li>
</ol>
<p>applicationContext的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  	<span class="comment">&lt;!-- proxy-target-class等于true是强制使用cglib代理，proxy-target-class默认是false，如果你的类实现了接口 就走JDK代理，如果没有，走cglib代理  --&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 对于单例模式建议使用cglib代理，虽然JDK动态代理比cglib代理速度快，但性能不如cglib --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 激活自动代理功能 打开aop对@Aspectj的注解支持 ,相当于为注解提供解析功能--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">	</span><br><span class="line">  	<span class="comment">&lt;!-- 激活组件扫描功能,在包com.spring.aop及其子包下面自动扫描通过注解配置的组件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.spring.aop&quot;</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">&lt;!-- 切面 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.spring.aop.aspect.ServiceAspect&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为Aspect<code>切面</code>类添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.aop.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 系统服务组件Aspect切面Bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明这是一个组件</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//声明这是一个切面Bean</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Log log = LogFactory.getLog(ServiceAspect.class);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置切入点,该方法无方法体,主要为方便同类中其他方法使用此处配置的切入点</span></span><br><span class="line">	<span class="meta">@Pointcut(&quot;execution(* com.spring.aop.service..*(..))&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aspect</span><span class="params">()</span></span>&#123;	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 配置前置通知,使用在方法aspect()上注册的切入点</span></span><br><span class="line"><span class="comment">	 * 同时接受JoinPoint切入点对象,可以没有该参数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Before(&quot;aspect()&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(log.isInfoEnabled())&#123;</span><br><span class="line">			log.info(<span class="string">&quot;before &quot;</span> + joinPoint);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置后置通知,使用在方法aspect()上注册的切入点</span></span><br><span class="line">	<span class="meta">@After(&quot;aspect()&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(log.isInfoEnabled())&#123;</span><br><span class="line">			log.info(<span class="string">&quot;after &quot;</span> + joinPoint);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置环绕通知,使用在方法aspect()上注册的切入点</span></span><br><span class="line">	<span class="meta">@Around(&quot;aspect()&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			((ProceedingJoinPoint) joinPoint).proceed();</span><br><span class="line">			<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">			<span class="keyword">if</span>(log.isInfoEnabled())&#123;</span><br><span class="line">				log.info(<span class="string">&quot;around &quot;</span> + joinPoint + <span class="string">&quot;\tUse time : &quot;</span> + (end - start) + <span class="string">&quot; ms!&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">			<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">			<span class="keyword">if</span>(log.isInfoEnabled())&#123;</span><br><span class="line">				log.info(<span class="string">&quot;around &quot;</span> + joinPoint + <span class="string">&quot;\tUse time : &quot;</span> + (end - start) + <span class="string">&quot; ms with exception : &quot;</span> + e.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置后置返回通知,使用在方法aspect()上注册的切入点</span></span><br><span class="line">	<span class="meta">@AfterReturning(&quot;aspect()&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturn</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(log.isInfoEnabled())&#123;</span><br><span class="line">			log.info(<span class="string">&quot;afterReturn &quot;</span> + joinPoint);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置抛出异常后通知,使用在方法aspect()上注册的切入点</span></span><br><span class="line">	<span class="meta">@AfterThrowing(pointcut=&quot;aspect()&quot;, throwing=&quot;ex&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrow</span><span class="params">(JoinPoint joinPoint, Exception ex)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(log.isInfoEnabled())&#123;</span><br><span class="line">			log.info(<span class="string">&quot;afterThrow &quot;</span> + joinPoint + <span class="string">&quot;\t&quot;</span> + ex.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserService.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.aop.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.spring.mvc.bean.User;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户服务模型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Log log = LogFactory.getLog(UserService.class);</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(log.isInfoEnabled())&#123;</span><br><span class="line">			log.info(<span class="string">&quot;getUser method . . .&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(log.isInfoEnabled())&#123;</span><br><span class="line">			log.info(<span class="string">&quot;saveUser method . . .&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="keyword">long</span> id)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(log.isInfoEnabled())&#123;</span><br><span class="line">			log.info(<span class="string">&quot;delete method . . .&quot;</span>);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;spring aop ThrowAdvice演示&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.spring.aop.service.UserService;</span><br><span class="line"><span class="keyword">import</span> com.spring.mvc.bean.User;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spring AOP测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tester</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Log log = LogFactory.getLog(Tester.class);</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//启动Spring容器</span></span><br><span class="line">		ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">		<span class="comment">//获取service组件</span></span><br><span class="line">		UserService service = (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">		<span class="comment">//以普通的方式调用UserService对象的三个方法</span></span><br><span class="line">		User user = service.get(<span class="number">1L</span>);</span><br><span class="line">		service.save(user);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			service.delete(<span class="number">1L</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">if</span>(log.isWarnEnabled())&#123;</span><br><span class="line">				log.warn(<span class="string">&quot;Delete user : &quot;</span> + e.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">INFO [spring.aop.aspect.ServiceAspect:<span class="number">40</span>] <span class="function">before <span class="title">execution</span><span class="params">(User com.spring.aop.service.UserService.get(<span class="keyword">long</span>)</span>)</span></span><br><span class="line"><span class="function">INFO [spring.aop.service.UserService:19] getUser method . . .</span></span><br><span class="line"><span class="function">INFO [spring.aop.aspect.ServiceAspect:60] around <span class="title">execution</span><span class="params">(User com.spring.aop.service.UserService.get(<span class="keyword">long</span>)</span>)	Use time : 42 ms!</span></span><br><span class="line"><span class="function">INFO [spring.aop.aspect.ServiceAspect:48] after <span class="title">execution</span><span class="params">(User com.spring.aop.service.UserService.get(<span class="keyword">long</span>)</span>)</span></span><br><span class="line"><span class="function">INFO [spring.aop.aspect.ServiceAspect:74] afterReturn <span class="title">execution</span><span class="params">(User com.spring.aop.service.UserService.get(<span class="keyword">long</span>)</span>)</span></span><br><span class="line"><span class="function">INFO [spring.aop.aspect.ServiceAspect:40] before <span class="title">execution</span><span class="params">(<span class="keyword">void</span> com.spring.aop.service.UserService.save(User)</span>)</span></span><br><span class="line"><span class="function">INFO [spring.aop.service.UserService:26] saveUser method . . .</span></span><br><span class="line"><span class="function">INFO [spring.aop.aspect.ServiceAspect:60] around <span class="title">execution</span><span class="params">(<span class="keyword">void</span> com.spring.aop.service.UserService.save(User)</span>)	Use time : 2 ms!</span></span><br><span class="line"><span class="function">INFO [spring.aop.aspect.ServiceAspect:48] after <span class="title">execution</span><span class="params">(<span class="keyword">void</span> com.spring.aop.service.UserService.save(User)</span>)</span></span><br><span class="line"><span class="function">INFO [spring.aop.aspect.ServiceAspect:74] afterReturn <span class="title">execution</span><span class="params">(<span class="keyword">void</span> com.spring.aop.service.UserService.save(User)</span>)</span></span><br><span class="line"><span class="function">INFO [spring.aop.aspect.ServiceAspect:40] before <span class="title">execution</span><span class="params">(<span class="keyword">boolean</span> com.spring.aop.service.UserService.delete(<span class="keyword">long</span>)</span>)</span></span><br><span class="line"><span class="function">INFO [spring.aop.service.UserService:32] delete method . . .</span></span><br><span class="line"><span class="function">INFO [spring.aop.aspect.ServiceAspect:65] around <span class="title">execution</span><span class="params">(<span class="keyword">boolean</span> com.spring.aop.service.UserService.delete(<span class="keyword">long</span>)</span>)	Use time : 5 ms with exception : spring aop ThrowAdvice演示</span></span><br><span class="line"><span class="function">INFO [spring.aop.aspect.ServiceAspect:48] after <span class="title">execution</span><span class="params">(<span class="keyword">boolean</span> com.spring.aop.service.UserService.delete(<span class="keyword">long</span>)</span>)</span></span><br><span class="line"><span class="function">INFO [spring.aop.aspect.ServiceAspect:74] afterReturn <span class="title">execution</span><span class="params">(<span class="keyword">boolean</span> com.spring.aop.service.UserService.delete(<span class="keyword">long</span>)</span>)</span></span><br><span class="line"><span class="function">WARN [studio.spring.aop.Tester:32] Delete user : Null return value from advice does not match primitive return type <span class="keyword">for</span>: <span class="keyword">public</span> <span class="keyword">boolean</span> com.spring.aop.service.UserService.<span class="title">delete</span><span class="params">(<span class="keyword">long</span>)</span> <span class="keyword">throws</span> java.lang.Exception</span></span><br></pre></td></tr></table></figure>

<p>可以看到，正如我们预期的那样，虽然我们并没有对UserSerivce类包括其调用方式做任何改变，但是Spring仍然拦截到了其中方法的调用，或许这正是AOP的魔力所在。</p>
<h2 id="XML配置AOP"><a href="#XML配置AOP" class="headerlink" title="XML配置AOP"></a>XML配置AOP</h2><p>XML配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 系统服务组件的切面Bean --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.spring.aop.aspect.ServiceAspect&quot;</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- AOP配置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 声明一个切面,并注入切面Bean,相当于@Aspect --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;simpleAspect&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;serviceAspect&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 配置一个切入点,相当于@Pointcut --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.spring.aop.service..*(..))&quot;</span> <span class="attr">id</span>=<span class="string">&quot;simplePointcut&quot;</span>/&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 配置通知,相当于@Before、@After、@AfterReturn、@Around、@AfterThrowing --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;simplePointcut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;simplePointcut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;simplePointcut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;afterReturn&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;simplePointcut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;afterThrow&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;ex&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>ServiceAspect.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置前置通知,拦截返回值为com.spring.mvc.bean.User的方法</span></span><br><span class="line"><span class="meta">@Before(&quot;execution(com.spring.mvc.bean.User com.spring.aop.service..*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeReturnUser</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(log.isInfoEnabled())&#123;</span><br><span class="line">		log.info(<span class="string">&quot;beforeReturnUser &quot;</span> + joinPoint);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置前置通知,拦截参数为com.spring.mvc.bean.User的方法</span></span><br><span class="line"><span class="meta">@Before(&quot;execution(* com.spring.aop.service..*(com.spring.mvc.bean.User))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeArgUser</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(log.isInfoEnabled())&#123;</span><br><span class="line">		log.info(<span class="string">&quot;beforeArgUser &quot;</span> + joinPoint);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置前置通知,拦截含有long类型参数的方法,并将参数值注入到当前方法的形参id中</span></span><br><span class="line"><span class="meta">@Before(&quot;aspect()&amp;&amp;args(id)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeArgId</span><span class="params">(JoinPoint joinPoint, <span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(log.isInfoEnabled())&#123;</span><br><span class="line">		log.info(<span class="string">&quot;beforeArgId &quot;</span> + joinPoint + <span class="string">&quot;\tID:&quot;</span> + id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserService.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.aop.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.spring.mvc.bean.User;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户服务模型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Log log = LogFactory.getLog(UserService.class);</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(log.isInfoEnabled())&#123;</span><br><span class="line">			log.info(<span class="string">&quot;getUser method . . .&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(log.isInfoEnabled())&#123;</span><br><span class="line">			log.info(<span class="string">&quot;saveUser method . . .&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="keyword">long</span> id)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(log.isInfoEnabled())&#123;</span><br><span class="line">			log.info(<span class="string">&quot;delete method . . .&quot;</span>);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;spring aop ThrowAdvice演示&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>SpringAop可以用来：</p>
<ol>
<li>Spring声明式事务管理配置。</li>
<li>在执行方法前,判断是否具有权限。</li>
<li>对部分函数的调用进行日志记录。监控部分重要函数，若抛出指定的异常，可以以短信或邮件方式通知相关人员。</li>
<li>使用Spring AOP实现MySQL数据库读写分离。</li>
<li>信息过滤</li>
<li>……</li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>关于服务监控的思考</title>
    <url>/%E5%85%B3%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>目前开源的组件如<code>Skywalking</code>、<code>Zipkin</code>只能做到横向监控，没法针对某一时间段方法纵向监控和告警。基于这种痛点和对一些组件的了解，自己写了一套可满足自己业务需求的服务监控组件，结合了<code>Grafana</code>、<code>Loki</code>、<code>Promtail</code>、<code>Elasticsearch</code>、<code>Kafka</code>等，可实现<strong>服务接口级监控、监控告警、告警日志在线查看</strong>等特性。<span id="more"></span></p>
<h1 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h1><ul>
<li><code>Grafana</code>：<a href="http://rainbowhorse.site/Grafana%E6%90%AD%E5%BB%BA/">Grafana 搭建</a></li>
<li><code>Loki</code>：<a href="http://rainbowhorse.site/%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86Loki%E6%90%AD%E5%BB%BA/">轻量级日志采集Loki搭建</a></li>
<li><code>Elasticsearch</code>：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/getting-started.html">介绍及使用文档</a></li>
<li>消息中间件：<code>kafka</code></li>
<li>服务监控组件(未开源)：<code>service-profiler</code></li>
</ul>
<h1 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h1><ol>
<li><code>Client</code>收集服务调用信息后生成数据快照(<code>Snapshot</code>)，通过<code>Kafka</code>定时上报到<code>Server</code>端。<code>Client</code>通过<code>Promtail</code>采集错误日志上报到<code>Loki</code>服务器。</li>
<li><code>Server</code>端统计聚合<code>Client</code>端上报的信息后落库<code>ES</code>。<code>Loki</code>服务端接收到<code>Client</code>端上报的日志后存储至磁盘并生成索引。</li>
<li>通过<code>Grafana</code>整合统计信息和错误日志，通过丰富的仪表盘实时展示相关指标与分析结果。</li>
<li>当相关指标超过自定义阈值时，通过通知平台告警到相关研发人员，及时处理告警。</li>
</ol>
<div align=center><img src="../../../../images/2021/10-12/m4.png" algin="center"/></div><!-- more -->

<h1 id="日志采集"><a href="#日志采集" class="headerlink" title="日志采集"></a>日志采集</h1><p>日志采集使用的是较为轻量级的<code>Loki</code>。<code>Loki</code>的搭建和使用可参考<a href="http://rainbowhorse.site/%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86Loki%E6%90%AD%E5%BB%BA/">轻量级日志采集Loki搭建</a>。</p>
<p>需要在<code>Grafana</code>中配置<code>Loki</code>的信息，然后在<code>Explore</code>中展示日志。</p>
<div align=center><img src="../../../../images/2021/10-12/m5.png" algin="center"/></div>

<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>下面展示图是实际应用到项目中的大屏和监控效果图。</p>
<div align=center><img src="../../../../images/2021/10-12/m3.png" algin="center"/></div>

<div align=center><img src="../../../../images/2021/10-12/m2.png" algin="center"/></div>

<div align=center><img src="../../../../images/2021/10-12/m1.png" algin="center"/></div>

<div align=center><img src="../../../../images/2021/10-12/m6.jpg" algin="center"/></div>

<p>在调用链路视图中，可以查看到整个调用分析中，每一个应用的<strong>调用类型</strong>、<strong>服务名</strong>、<strong>方法名称</strong>、<strong>实例名称</strong>、耗时区间，以及<strong>平均耗时</strong>等。能一步定位到哪一个方法存在性能瓶颈。</p>
<p>借助于<code>Grafana</code>的特性，可让数据大屏展示更丰富：</p>
<ol>
<li>解决服务黑盒问题，让服务调用可视化，纵向分析服务调用；</li>
<li>可及时发现服务调用失败、超时信息并告警，并可进行性能指标分析，让研发人员及时发现并解决问题；</li>
<li>全方位、立体化、可视化监控。可选择具体系统编码、应用、方法进行查看，可根据各列进行排序。无需手动刷新，系统动态进行刷新（刷新时间可自定义）；</li>
<li>可动态调整超时时间设置(应用无需重启)，可自定义设置单个方法的超时时间；</li>
<li>结合<code>Grafana</code>特性可自定义告警阈值。可根据业务调整告警阈值。</li>
</ol>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>服务监控组件通过切面捕获服务调用信息，<strong>捕获数据后异步存储后通过消息中间件上报到服务端，客户端无阻塞</strong>，正常情况下性损极小(微秒级)。</p>
]]></content>
      <categories>
        <category>监控</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式下ID生成算法 SnowFlake</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8BID%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95-SnowFlake/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在做系统开发时，系统唯一ID是我们在设计一个系统的时候经常遇到的问题，也常常为这个问题纠结。生成ID的方法有很多，适应不同的场景、需求及性能要求。所以有些比较复杂的系统会有多个ID生成策略。在这里总结一下常用到的ID生成策略。<div align=center><img width="700" height="300" src="../../../../images/2017-9-21/%E8%87%AA%E5%A2%9EID/index.png" algin="center"/></div><span id="more"></span></p>
<h1 id="数据库自增长序列或字段"><a href="#数据库自增长序列或字段" class="headerlink" title="数据库自增长序列或字段"></a>数据库自增长序列或字段</h1><p>最常见的方式，利用数据库，全表中唯一。如MySQL的<code>AUTO_INCREMENT</code>。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>简单，代码方便，性能可以接受。</li>
<li>数字ID天然排序，对分页或者需要排序的结果很有帮助。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>不同数据库语法和实现不同，数据库迁移的时候或多数据库版本支持的时候需要处理。</li>
<li>在单个数据库或读写分离或一主多从的情况下，只有一个主库可以生成。有单点故障的风险。</li>
<li>在性能达不到要求的情况下，比较难于扩展。</li>
<li>如果遇见多个系统需要合并或者涉及到数据迁移会相当痛苦。</li>
<li>分表分库的时候会有麻烦。</li>
</ol>
<h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><p>针对主库单点，如果有多个Master库，则每个Master库设置的起始数字不一样，步长一样，可以是Master的个数。比如：Master1 生成的是 1, 4, 7, 10，Master2生成的是2, 5, 8, 11，Master3生成的是3, 6, 9, 12。这样就可以有效生成集群中的唯一ID，也可以大大降低ID生成数据库操作的负载。</p>
<h1 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h1><p>常见的方式。可以利用数据库也可以利用程序生成，一般来说全球唯一。</p>
<h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><ol>
<li>简单，代码方便。</li>
<li>生成ID性能非常好，基本不会有性能问题。</li>
<li>全球唯一，在遇见数据迁移，系统数据合并，或者数据库变更等情况下，可以从容应对。</li>
</ol>
<h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>没有排序，无法保证趋势递增。</li>
<li>UUID往往是使用字符串存储，查询的效率比较低。</li>
<li>存储空间比较大，如果是海量数据库，就需要考虑存储量的问题。</li>
<li>传输数据量大。</li>
<li>不可读。</li>
</ol>
<h1 id="Twitter-SnowFlake算法"><a href="#Twitter-SnowFlake算法" class="headerlink" title="Twitter-SnowFlake算法"></a>Twitter-SnowFlake算法</h1><p>有些时候我们希望能使用简单一些的 ID，并且希望 ID 能够按照时间有序生成，为了解决这个问题，Twitter 发明了 <a href="https://github.com/twitter/snowflake"><em>SnowFlake</em></a> 算法，不依赖第三方介质例如 Redis、数据库，本地生成程序生成分布式自增 ID，这个 ID 只能保证在工作组中的机器生成的 ID 唯一，不能像 UUID 那样保证时空唯一。</p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><div align=center><img width="700" height="300" src="../../../../images/2017-9-21/%E8%87%AA%E5%A2%9EID/snowflake.png" algin="center"/>

</div>

<p>除了最高位bit标记为不可用以外，其余三组bit占位均可浮动，看具体的业务需求而定。默认情况下41bit的时间戳可以支持该算法使用到2082年，10bit的工作机器id可以支持1023台机器，序列号支持1毫秒产生4095个自增序列id。</p>
<h3 id="SnowFlake-–-时间戳"><a href="#SnowFlake-–-时间戳" class="headerlink" title="SnowFlake – 时间戳"></a>SnowFlake – 时间戳</h3><p>这里时间戳的细度是<strong>毫秒级</strong>，建议使用64位linux系统机器，因为有vdso，gettimeofday()在用户态就可以完成操作，减少了进入内核态的损耗。</p>
<h3 id="SnowFake-–-工作机器ID"><a href="#SnowFake-–-工作机器ID" class="headerlink" title="SnowFake – 工作机器ID"></a>SnowFake – 工作机器ID</h3><p>严格意义上来说这个bit段的使用可以是<strong>进程级</strong>，机器级的话你可以使用MAC地址来唯一标示工作机器，工作进程级可以使用IP+Path来区分工作进程。如果工作机器比较少，可以使用配置文件来设置这个id是一个不错的选择，如果机器过多配置文件的维护是一个灾难性的事情。</p>
<h3 id="SnowFlake-–-序列号"><a href="#SnowFlake-–-序列号" class="headerlink" title="SnowFlake – 序列号"></a>SnowFlake – 序列号</h3><p>序列号就是一系列的自增id（多线程建议使用atomic），为了处理在同一毫秒内需要给多条消息分配id，若同一毫秒把序列号用完了，则 “等待至下一毫秒”。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="Sequence类"><a href="#Sequence类" class="headerlink" title="Sequence类"></a>Sequence类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Snowflake 生成的 64 位 long 类型的 ID，结构如下:&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 1) 01 位标识，由于 long 在 Java 中是有符号的，最高位是符号位，正数是 0，负数是 1，ID 一般使用正数，所以最高位是 0&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 2) 41 位时间截(毫秒级)，注意，41 位时间截不是存储当前时间的时间截，而是存储时间截的差值(当前时间 - 开始时间)得到的值，</span></span><br><span class="line"><span class="comment"> *       开始时间截，一般是业务开始的时间，由我们程序来指定，如 SnowflakeIdWorker 中的 startTimestamp 属性。</span></span><br><span class="line"><span class="comment"> * 41 位的时间截，可以使用 70 年: (2^41)/(1000*60*60*24*365) = 69.7 年&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 3) 10 位的数据机器位，可以部署在 1024 个节点，包括 5 位 datacenterId 和 5 位 workerId&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 4) 12 位序列，毫秒内的计数，12 位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生 4096 个 ID 序号&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * SnowFlake 的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生 ID 碰撞(由数据中心 ID 和机器 ID 作区分)，并且效率较   高，经测试，SnowFlake 每秒能够产生约 26 万个 ID。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** 开始时间截 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> twepoch = <span class="number">1288834974657L</span>;</span><br><span class="line">	<span class="comment">/** 机器id所占的位数 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>;</span><br><span class="line">	<span class="comment">/** 数据标识id所占的位数 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterIdBits = <span class="number">5L</span>;</span><br><span class="line">	<span class="comment">/** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line">	<span class="comment">/** 支持的最大数据标识id，结果是31 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxDatacenterId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line">	<span class="comment">/** 序列在id中占的位数 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;</span><br><span class="line">	<span class="comment">/** 机器ID向左移12位 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdShift = sequenceBits;</span><br><span class="line">	<span class="comment">/** 数据标识id向左移17位(12+5) */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line">	<span class="comment">/** 时间截向左移22位(5+5+12) */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line">	<span class="comment">/** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 工作机器ID(0~31) */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> workerId;</span><br><span class="line">	<span class="comment">/** 数据中心ID(0~31) */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> datacenterId;</span><br><span class="line">	<span class="comment">/** 毫秒内序列(0~4095) */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line">	<span class="comment">/** 上次生成ID的时间截 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Sequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		datacenterId = getDatacenterId(maxDatacenterId);</span><br><span class="line">		workerId = getMaxWorkerId(datacenterId, maxWorkerId);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Sequence</span><span class="params">(<span class="keyword">long</span> workerId, <span class="keyword">long</span> datacenterId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">this</span>.workerId = workerId;</span><br><span class="line">		<span class="keyword">this</span>.datacenterId = datacenterId;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取 maxWorkerId</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> datacenterId	 数据中心id</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> maxWorkerId	 机器id</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span>	maxWorkerId</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getMaxWorkerId</span><span class="params">(<span class="keyword">long</span> datacenterId, <span class="keyword">long</span> maxWorkerId)</span> </span>&#123;</span><br><span class="line">		StringBuilder mpid = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		mpid.append(datacenterId);</span><br><span class="line">		String name = ManagementFactory.getRuntimeMXBean().getName();</span><br><span class="line">		<span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(name)) &#123;</span><br><span class="line">			<span class="comment">// GET jvmPid</span></span><br><span class="line">			mpid.append(name.split(<span class="string">&quot;@&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//MAC + PID 的 hashcode 获取16个低位</span></span><br><span class="line">		<span class="keyword">return</span> (mpid.toString().hashCode() &amp; <span class="number">0xffff</span>) % (maxWorkerId + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 数据标识id部分</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> maxDatacenterId</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getDatacenterId</span><span class="params">(<span class="keyword">long</span> maxDatacenterId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> id = <span class="number">0L</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			InetAddress ip = InetAddress.getLocalHost();</span><br><span class="line">			NetworkInterface network = NetworkInterface.getByInetAddress(ip);</span><br><span class="line">			<span class="keyword">if</span> (network == <span class="keyword">null</span>) &#123;</span><br><span class="line">				id = <span class="number">1L</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">byte</span>[] mac = network.getHardwareAddress();</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">null</span> != mac) &#123;</span><br><span class="line">					id = ((<span class="number">0x000000FF</span> &amp; (<span class="keyword">long</span>) mac[mac.length - <span class="number">1</span>]) | (<span class="number">0x0000FF00</span> &amp; (((<span class="keyword">long</span>) mac[mac.length - <span class="number">2</span>]) &lt;&lt; <span class="number">8</span>))) &gt;&gt; <span class="number">6</span>;</span><br><span class="line">					id = id % (maxDatacenterId + <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.err.println(<span class="string">&quot; getDatacenterId: &quot;</span> + e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获得下一个ID (该方法是线程安全的)</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> nextId</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span></span><br><span class="line">		<span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;<span class="comment">// 闰秒</span></span><br><span class="line">			<span class="keyword">long</span> offset = lastTimestamp - timestamp;</span><br><span class="line">			<span class="keyword">if</span> (offset &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					wait(offset &lt;&lt; <span class="number">1</span>);</span><br><span class="line">					timestamp = timeGen();</span><br><span class="line">					<span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>, offset));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>, offset));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//$NON-NLS-解决跨毫秒生成ID序列号始终为偶数的缺陷$</span></span><br><span class="line">		<span class="comment">// 如果是同一时间生成的，则进行毫秒内序列</span></span><br><span class="line">		<span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">			sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">			<span class="comment">// 毫秒内序列溢出</span></span><br><span class="line">			<span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">// 阻塞到下一个毫秒,获得新的时间戳</span></span><br><span class="line">				timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;<span class="comment">// 时间戳改变，毫秒内序列重置</span></span><br><span class="line">			sequence = <span class="number">0L</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		// 如果是同一时间生成的，则进行毫秒内序列</span></span><br><span class="line"><span class="comment">		if (lastTimestamp == timestamp) &#123;</span></span><br><span class="line"><span class="comment">		    long old = sequence;</span></span><br><span class="line"><span class="comment">		    sequence = (sequence + 1) &amp; sequenceMask;</span></span><br><span class="line"><span class="comment">		    // 毫秒内序列溢出</span></span><br><span class="line"><span class="comment">		    if (sequence == old) &#123;</span></span><br><span class="line"><span class="comment">		        // 阻塞到下一个毫秒,获得新的时间戳</span></span><br><span class="line"><span class="comment">		        timestamp = tilNextMillis(lastTimestamp);</span></span><br><span class="line"><span class="comment">		    &#125;</span></span><br><span class="line"><span class="comment">		&#125; else &#123;// 时间戳改变，毫秒内序列重置</span></span><br><span class="line"><span class="comment">		    sequence = ThreadLocalRandom.current().nextLong(0, 2);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		**/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 上次生成ID的时间截</span></span><br><span class="line">		lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 移位并通过或运算拼到一起组成64位的ID</span></span><br><span class="line">		<span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) <span class="comment">//</span></span><br><span class="line">				| (datacenterId &lt;&lt; datacenterIdShift) <span class="comment">//</span></span><br><span class="line">				| (workerId &lt;&lt; workerIdShift) <span class="comment">//</span></span><br><span class="line">				| sequence;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 阻塞到下一个毫秒，直到获得新的时间戳</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> lastTimestamp 上次生成ID的时间截</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 当前时间戳</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">tilNextMillis</span><span class="params">(<span class="keyword">long</span> lastTimestamp)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line">		<span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">			timestamp = timeGen();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> timestamp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回以毫秒为单位的当前时间</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 当前时间(毫秒)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">timeGen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SystemClock.now();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SystemClock类"><a href="#SystemClock类" class="headerlink" title="SystemClock类"></a>SystemClock类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 高并发场景下System.currentTimeMillis()的性能问题的优化</span></span><br><span class="line"><span class="comment"> * System.currentTimeMillis()的调用比new一个普通对象要耗时的多（具体耗时高出多少我还没测试过，有人说是100倍左右）&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * System.currentTimeMillis()之所以慢是因为去跟系统打了一次交道&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 后台定时更新时钟，JVM退出时，线程自动回收&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 10亿：43410,206,210.72815533980582%&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 1亿：4699,29,162.0344827586207%&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 1000万：480,12,40.0%&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 100万：50,10,5.0%&lt;p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemClock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> period;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong now;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SystemClock</span><span class="params">(<span class="keyword">long</span> period)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.period = period;</span><br><span class="line">        <span class="keyword">this</span>.now = <span class="keyword">new</span> AtomicLong(System.currentTimeMillis());</span><br><span class="line">        scheduleClockUpdating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SystemClock INSTANCE = <span class="keyword">new</span> SystemClock(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SystemClock <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleClockUpdating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor(<span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">                Thread thread = <span class="keyword">new</span> Thread(runnable, <span class="string">&quot;System Clock&quot;</span>);</span><br><span class="line">                thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> thread;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        scheduler.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                now.set(System.currentTimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, period, period, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> now.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance().currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">nowDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Timestamp(instance().currentTimeMillis()).toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGen</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Sequence sequence = <span class="keyword">new</span> Sequence();</span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 使用Sequence生成主键，利用Snowflake算法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sequenceId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> nextId = sequence.nextId();</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(nextId);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//测试代码</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> id = sequenceId();</span><br><span class="line">            <span class="comment">//System.out.println(Long.toBinaryString(id));</span></span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SnowFlake算法可以根据自身项目的需要进行一定的修改。比如估算未来的数据中心个数，每个数据中心的机器数以及统一毫秒可以能的并发数来调整在算法中所需要的bit数。</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol>
<li>不依赖于数据库，灵活方便，且性能优于数据库。</li>
<li>ID按照时间在单机上是递增的。</li>
</ol>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>在单机上是递增的，但是由于涉及到分布式环境，每台机器上的时钟不可能完全同步，也许有时候也会出现不是全局递增的情况。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在项目中SnowFlake算法生成ID是第一选择，兼具性能和灵活性。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式数据库和缓存双写一致性解析</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>缓存由于其高并发和高性能的特性，已经在项目中被广泛使用。在读取缓存方面，都是按照先从缓存中读取，缓存中不存在再从数据库加载同时存入缓存的流程操作。但是在更新缓存方面，对于更新完数据库，是更新缓存还是删除缓存。又或是先删除缓存再更新数据库，其实都有很大的争议。<div align=center><img width="700" height="300" src="../../../../images/2018-7/cache/10.png" algin="center"/></p>
</div><span id="more"></span>

<h1 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h1><p>说明：从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。因此， 接下来的讨论的思路不依赖于给缓存设置过期时间这个方案。</p>
<p>在这里讨论三种更新策略：</p>
<ul>
<li>先更新数据库，再更新缓存</li>
<li>先删除缓存，再更新数据库</li>
<li>先更新数据库，再删除缓存</li>
</ul>
<h1 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a>先更新数据库，再更新缓存</h1><p>这套方案普遍反对，有如下两种原因：</p>
<h2 id="线程安全角度"><a href="#线程安全角度" class="headerlink" title="线程安全角度"></a>线程安全角度</h2><p>同时有请求A和请求B进行更新操作，那么会出现</p>
<p>（1）线程A更新了数据库<br>（2）线程B更新了数据库<br>（3）线程B更新了缓存<br>（4）线程A更新了缓存</p>
<p>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。</p>
<h2 id="业务场景角度"><a href="#业务场景角度" class="headerlink" title="业务场景角度"></a>业务场景角度</h2><p>（1）如果是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。</p>
<p>（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。</p>
<h1 id="先删缓存，再更新数据库"><a href="#先删缓存，再更新数据库" class="headerlink" title="先删缓存，再更新数据库"></a>先删缓存，再更新数据库</h1><p>该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形：</p>
<p>（1）请求A进行写操作，删除缓存<br>（2）请求B查询发现缓存不存在<br>（3）请求B去数据库查询得到旧值<br>（4）请求B将旧值写入缓存<br>（5）请求A将新值写入数据库</p>
<p>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</p>
<p>解决方案就是采用<strong>延时双删策略</strong>。伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String key,Object data)</span></span>&#123;</span><br><span class="line">       redis.delKey(key);</span><br><span class="line">       db.updateData(data);</span><br><span class="line">       Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">       redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转化为中文描述就是：</p>
<p>（1）先淘汰缓存<br>（2）再写数据库（这两步和原来一样）<br>（3）休眠1秒，再次淘汰缓存</p>
<p>这么做，可以将1秒内所造成的缓存脏数据，再次删除。那么这个睡眠时间如何确定呢？</p>
<p>针对上面的情形，应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>
<p><strong>如果用了mysql的读写分离架构怎么办？</strong></p>
<p>在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。</p>
<p>（1）请求A进行写操作，删除缓存<br>（2）请求A将数据写入数据库了，<br>（3）请求B查询缓存发现，缓存没有值<br>（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值<br>（5）请求B将旧值写入缓存<br>（6）数据库完成主从同步，从库变为新值</p>
<p>上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。</p>
<p><strong>采用这种同步淘汰策略，吞吐量降低怎么办？</strong></p>
<p>那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。</p>
<p><strong>第二次删除,如果删除失败怎么办？</strong></p>
<p>第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：</p>
<p>（1）请求A进行写操作，删除缓存<br>（2）请求B查询发现缓存不存在<br>（3）请求B去数据库查询得到旧值<br>（4）请求B将旧值写入缓存<br>（5）请求A将新值写入数据库<br>（6）请求A试图去删除请求B写入对缓存值，结果失败了。</p>
<p>这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。</p>
<p><strong>如何解决呢？</strong></p>
<p>具体解决方案，就是第三种方案。</p>
<h1 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title="先更新数据库，再删除缓存"></a>先更新数据库，再删除缓存</h1><p>老外提出了一个缓存更新套路，名为《<em>Cache-Aside pattern</em>》。其中指出</p>
<ul>
<li><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li>
<li><strong>命中</strong>：应用程序从cache中取数据，取到后返回。</li>
<li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li>
</ul>
<p>另外，知名社交网站facebook也在论文《Scaling Memcache at Facebook》中提出，他们用的也是先更新数据库，再删缓存的策略。</p>
<p><strong>这种情况不存在并发问题么？</strong></p>
<p>不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生：</p>
<p>（1）缓存刚好失效<br>（2）请求A查询数据库，得一个旧值<br>（3）请求B将新值写入数据库<br>（4）请求B删除缓存<br>（5）请求A将查到的旧值写入缓存</p>
<p>如果发生上述情况，确实是会发生脏数据。</p>
<p><strong>然而，发生这种情况的概率又有多少呢？</strong></p>
<p>发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。</p>
<p><strong>如何解决上述并发问题？</strong></p>
<p>首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。</p>
<p><strong>还有其他造成不一致的原因么？</strong></p>
<p>有的，这也是缓存更新策略（2）和缓存更新策略（3）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略（2）里留下的最后一个疑问。</p>
<p><strong>如何解决？</strong></p>
<p>提供一个保障的重试机制即可，这里给出两套方案。<br><strong>方案一：</strong></p>
<p>如下图所示</p>
<div align=center><img width="700" height="300" src="../../../../images/2018-7/cache/11.png" algin="center"/>


</div>

<p>流程如下所示<br>（1）更新数据库数据；<br>（2）缓存因为种种问题删除失败<br>（3）将需要删除的key发送至消息队列<br>（4）自己消费消息，获得需要删除的key<br>（5）继续重试删除操作，直到成功</p>
<p>然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。</p>
<p><strong>方案二：</strong></p>
<div align=center><img width="700" height="300" src="../../../../images/2018-7/cache/12.png" algin="center"/>


</div>

<p>流程如下图所示：</p>
<p>（1）更新数据库数据<br>（2）数据库会将操作信息写入binlog日志当中<br>（3）订阅程序提取出所需要的数据以及key<br>（4）另起一段非业务代码，获得该信息<br>（5）尝试删除缓存操作，发现删除失败<br>（6）将这些信息发送至消息队列<br>（7）重新从消息队列中获得该数据，重试操作。</p>
<p><strong>备注说明：</strong>上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。另外，重试机制，采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可，这里只是提供一个思路。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/rjzheng/p/9041659.html"><em>分布式之数据库和缓存双写一致性方案解析</em></a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title>动态修改日志级别</title>
    <url>/%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>日志是我们定位问题的关键，尤其是在线上。但是有时我们输出的日志信息不够充足，给排查问题带来了极大的困扰。如果能够不重启应用，就能动态调整日志级别的话，无疑给我们排查问题带来了极大的帮助。<span id="more"></span> <code>Spring Boot 1.5</code> 从开始，<code>Spring Boot Actuator</code> 组件就已提供动态修改日志级别的能力。在这里基于<code>SpringMVC</code>封装了<code>log-config-core</code>的jar，提供了更丰富的功能。<div align=center><img width="420" height="220" src="../../../../images/2019/4-6/log_level.jpg" algin="center"/></div></p>
<p>项目地址在我的GitHub：<a href="https://github.com/mx-go/log-config-core/tree/master">https://github.com/mx-go/log-config-core/tree/master</a></p>
<p><strong>项目必须使用logback作为日志输出组件。</strong></p>
<h1 id="引入Maven坐标"><a href="#引入Maven坐标" class="headerlink" title="引入Maven坐标"></a>引入Maven坐标</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.mx-go<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log-config-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>jar包中的<code>LogbackServlet</code>通过<code>web-fragment</code>会自动注册到服务中，jar包提供以下功能：</p>
<ul>
<li>获取服务所有logger level信息</li>
<li>获取单个logger level信息</li>
<li>设置指定logger的logger level</li>
<li>获取所有日志文件信息</li>
<li>查询某日志文件最近N行日志</li>
</ul>
<h2 id="获取服务所有logger-level信息"><a href="#获取服务所有logger-level信息" class="headerlink" title="获取服务所有logger level信息"></a>获取服务所有logger level信息</h2><p>通过访问：<a href="http://ip:prot/logback/all">http://ip:prot/logback/all</a>           <strong>GET</strong>           无参数</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">访问：http:<span class="comment">//localhost:8081/logback/all</span></span><br><span class="line">返回：</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;level&quot;</span>: <span class="string">&quot;INFO&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;logger&quot;</span>: <span class="string">&quot;ROOT&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;level&quot;</span>: <span class="string">&quot;INFO&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;logger&quot;</span>: <span class="string">&quot;com.rainbowhorse.open&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;level&quot;</span>: <span class="string">&quot;INFO&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;logger&quot;</span>: <span class="string">&quot;org.hibernate&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;level&quot;</span>: <span class="string">&quot;INFO&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;logger&quot;</span>: <span class="string">&quot;org.springframework&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取单个logger-level信息"><a href="#获取单个logger-level信息" class="headerlink" title="获取单个logger level信息"></a>获取单个logger level信息</h2><p>通过访问：<a href="http://ip:prot/logback/getLogger">http://ip:prot/logback/getLogger</a>        <strong>GET</strong>        参数<strong>logger</strong>[必填]</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">访问：http:<span class="comment">//localhost:8081/logback/getLogger?logger=com.rainbowhorse.open</span></span><br><span class="line">返回：</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;level&quot;</span>: <span class="string">&quot;INFO&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;logger&quot;</span>: <span class="string">&quot;com.rainbowhorse.open&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设置指定logger的logger-level"><a href="#设置指定logger的logger-level" class="headerlink" title="设置指定logger的logger level"></a>设置指定logger的logger level</h2><p>通过访问：<a href="http://ip:prot/logback/setLevel">http://ip:prot/logback/setLevel</a>        GET        参数<strong>logger</strong>[必填]、<strong>level</strong>[选填]、<strong>newLevel</strong>[必填]</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">访问：http:<span class="comment">//localhost:8081/logback/setLevel?newLevel=DEBUG&amp;logger=com.rainbowhorse.open</span></span><br><span class="line">返回：</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: <span class="string">&quot;修改日志level成功&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取所有日志文件信息"><a href="#获取所有日志文件信息" class="headerlink" title="获取所有日志文件信息"></a>获取所有日志文件信息</h2><p>通过访问：<a href="http://ip:prot/logback/getLogFiles">http://ip:prot/logback/getLogFiles</a>        <strong>GET</strong>        无参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">访问：http://localhost:8081/logback/getLogFiles</span><br><span class="line">返回：</span><br><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;parent&quot;: &quot;../logs&quot;,</span><br><span class="line">            &quot;size&quot;: 36828,</span><br><span class="line">            &quot;name&quot;: &quot;admin.log&quot;,</span><br><span class="line">            &quot;lastModified&quot;: &quot;2019-05-11 17:03:59&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;status&quot;: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查询某日志文件最近N行日志"><a href="#查询某日志文件最近N行日志" class="headerlink" title="查询某日志文件最近N行日志"></a>查询某日志文件最近N行日志</h2><p>通过访问：<a href="http://ip:prot/logback/peekFile">http://ip:prot/logback/peekFile</a>        <strong>GET</strong>        参数<strong>file</strong>[必填]、<strong>num</strong>[选填,默认1000]</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">访问：http:<span class="comment">//localhost:8081/logback/peekFile?file=admin.log&amp;num=10</span></span><br><span class="line">返回：</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;2019-05-11 17:13:00,212 WARN [http-nio-8081-exec-6] change logger level start! logger: com.rainbowhorse.open, oldLevel: , newLevel: DEBUG&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2019-05-11 17:13:03,778 DEBUG [http-nio-8081-exec-7] debug&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2019-05-11 17:13:03,778 INFO [http-nio-8081-exec-7] info&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2019-05-11 17:13:03,778 ERROR [http-nio-8081-exec-7] error&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2019-05-11 17:13:18,337 INFO [http-nio-8081-exec-9] logback servlet request uri: /setLevel&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2019-05-11 17:13:18,337 WARN [http-nio-8081-exec-9] change logger level start! logger: com.rainbowhorse.open, oldLevel: , newLevel: INFO&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2019-05-11 17:13:21,441 INFO [http-nio-8081-exec-10] info&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2019-05-11 17:13:21,442 ERROR [http-nio-8081-exec-10] error&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2019-05-11 17:13:25,276 INFO [http-nio-8081-exec-2] logback servlet request uri: /getLogFiles&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2019-05-11 17:13:30,515 INFO [http-nio-8081-exec-3] logback servlet request uri: /peekFile&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>博客建成第一天</title>
    <url>/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E6%88%90%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<blockquote>
<p>经过几天的努力，自己的博客终于搭建起来了，打心里很开心。</p>
<p>这不是贴吧，不是豆瓣，不是CSDN，这是我自己在互联网上的一小点领地。</p>
<p>从开始博客基本样式，到域名，自己一步一步摸索搭建起来的，我相信自己可以做的更好，加油!</p>
</blockquote>
<div align=center><img width="300" height="300" src="../../../../images/avatar.jpg" algin="center"/></div>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>命中SpringCloudGateway组件BUG</title>
    <url>/%E5%91%BD%E4%B8%ADSpringCloudGateway%E7%BB%84%E4%BB%B6BUG/</url>
    <content><![CDATA[<p>生产环境网关模块偶发的<code>OutOfDirectMemoryError</code>错误排查起来困难且曲折，2021-02-05号也出现过此问题，起初以为是JVM堆内存过小(当时是2g)导致，后调整到8g(2月5号调整)。但是经过上次调整后5月7号又出现此问题，于是猜测可能是由于网关模块存在内存泄露导致。</p>
<h1 id="症状"><a href="#症状" class="headerlink" title="症状"></a>症状</h1><h2 id="报错详情"><a href="#报错详情" class="headerlink" title="报错详情"></a>报错详情</h2><p>网关模块偶现<code>OutOfDirectMemoryError</code>错误，两次问题出现相隔大概3个月。两次发生的时机都是正在大批量接收数据(大约500w)，TPS 60左右，网关服务波动不大，完全能抗住，按理不应该出现此错误。</p>
<p>详细报错信息如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">2021-05-06 13:44:18|WARN |[reactor-http-epoll-5]|[AbstractChannelHandlerContext.java : 311]|An exception <span class="string">&#x27;io.netty.util.internal.OutOfDirectMemoryError: failed to allocate 16384 byte(s) of direct memory (used: 8568993562, max: 8589934592)&#x27;</span> [<span class="built_in">enable</span> DEBUG level <span class="keyword">for</span> full stacktrace] was thrown by a user handler<span class="string">&#x27;s exceptionCaught() method while handling the following exception:</span></span><br><span class="line"><span class="string">io.netty.util.internal.OutOfDirectMemoryError: failed to allocate 16384 byte(s) of direct memory (used: 8568993562, max: 8589934592)</span></span><br><span class="line"><span class="string">        at io.netty.util.internal.PlatformDependent.incrementMemoryCounter(PlatformDependent.java:754)</span></span><br><span class="line"><span class="string">        at io.netty.util.internal.PlatformDependent.allocateDirectNoCleaner(PlatformDependent.java:709)</span></span><br><span class="line"><span class="string">        at io.netty.buffer.UnpooledUnsafeNoCleanerDirectByteBuf.allocateDirect(UnpooledUnsafeNoCleanerDirectByteBuf.java:30)</span></span><br><span class="line"><span class="string">        at io.netty.buffer.UnpooledDirectByteBuf.&lt;init&gt;(UnpooledDirectByteBuf.java:64)</span></span><br><span class="line"><span class="string">        at io.netty.buffer.UnpooledUnsafeDirectByteBuf.&lt;init&gt;(UnpooledUnsafeDirectByteBuf.java:41)</span></span><br><span class="line"><span class="string">        at io.netty.buffer.UnpooledUnsafeNoCleanerDirectByteBuf.&lt;init&gt;(UnpooledUnsafeNoCleanerDirectByteBuf.java:25)</span></span><br><span class="line"><span class="string">        at io.netty.buffer.UnsafeByteBufUtil.newUnsafeDirectByteBuf(UnsafeByteBufUtil.java:625)</span></span><br><span class="line"><span class="string">        at io.netty.buffer.PooledByteBufAllocator.newDirectBuffer(PooledByteBufAllocator.java:359)</span></span><br><span class="line"><span class="string">        at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:187)</span></span><br><span class="line"><span class="string">        at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:178)</span></span><br><span class="line"><span class="string">        at io.netty.channel.unix.PreferredDirectByteBufAllocator.ioBuffer(PreferredDirectByteBufAllocator.java:53)</span></span><br><span class="line"><span class="string">        at io.netty.channel.DefaultMaxMessagesRecvByteBufAllocator$MaxMessageHandle.allocate(DefaultMaxMessagesRecvByteBufAllocator.java:114)</span></span><br><span class="line"><span class="string">        at io.netty.channel.epoll.EpollRecvByteAllocatorHandle.allocate(EpollRecvByteAllocatorHandle.java:75)</span></span><br><span class="line"><span class="string">        at io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:777)</span></span><br><span class="line"><span class="string">        at io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:475)</span></span><br><span class="line"><span class="string">        at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:378)</span></span><br><span class="line"><span class="string">        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)</span></span><br><span class="line"><span class="string">        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span></span><br><span class="line"><span class="string">        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span></span><br><span class="line"><span class="string">        at java.lang.Thread.run(Thread.java:748)</span></span><br></pre></td></tr></table></figure>

<h2 id="JVM配置"><a href="#JVM配置" class="headerlink" title="JVM配置"></a>JVM配置</h2><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line">-server -Xmx8g -Xms8g -Xmn1024m -XX:PermSize=<span class="number">512</span>m -Xss256k -XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:+CMSParallel<span class="comment">RemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70 -Djava.awt.headless=true -Djava.net.preferIPv4Stack=true</span></span><br></pre></td></tr></table></figure>

<h2 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h2><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">spring cloud : Hoxton.SR5</span><br><span class="line">spring cloud starter gateway : 2.2.3.RELEASE</span><br><span class="line">spring boot starter : 2.3.0.RELEASE</span><br><span class="line">netty : 4.1.54.Final</span><br><span class="line">reactor-netty: 0.9.7.RELEASE</span><br></pre></td></tr></table></figure>

<h1 id="山重水复疑无路"><a href="#山重水复疑无路" class="headerlink" title="山重水复疑无路"></a>山重水复疑无路</h1><blockquote>
<p>JVM参数详解：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p>
</blockquote>
<p>报错的信息是<code>OutOfDirectMemoryError</code>，即堆外内存不足，于是复习了下JVM堆外内存的相关知识。</p>
<ol>
<li>堆外内存是在NIO中使用的；</li>
<li>堆外内存通过 <code>-XX:MaxDirectMemorySize</code> 参数控制大小，注意和 <code>-XX:+DisableExplicitGC</code> 参数的搭配使用；</li>
<li>JDK8中堆外内存默认和堆内存一样大（-Xmx）；</li>
<li>JDK8如果配置 <code>-XX:MaxDirectMemorySize</code> 参数，则堆外内存大小以设置的参数为准；</li>
</ol>
<p><code>SpringCloudGateway</code>是基于<code>WebFlux</code>框架实现的，而<code>WebFlux</code>框架底层则使用了高性能的<code>Reactor</code>模式通信框架<code>Netty</code>。</p>
<p>网上查阅相关资料，有些场景是因为堆外内存没有手动<code>release</code>导致，于是简单查看了网关模块的相关代码发现并无此问题，关键的地方也都调用了相关方法释放内存。堆外内存通过操作堆的命令无法看到，只能监控实例总内存走势判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放内存方法</span></span><br><span class="line">DataBufferUtils.release(dataBuffer);</span><br></pre></td></tr></table></figure>

<p>Dump堆内存下来也没有发现有什么问题</p>
<div align=center><img src="../../../../images/2020/9-12/heapdump.png" algin="center"/></div>

<h1 id="柳暗花明又一村"><a href="#柳暗花明又一村" class="headerlink" title="柳暗花明又一村"></a>柳暗花明又一村</h1><p>抱着试一试的想法到<code>SpringCloudGateway</code>官方仓库issue搜索有没有人遇到相同的问题，果不其然，有人提了类似的issue。<a href="https://github.com/spring-cloud/spring-cloud-gateway/issues/1704">https://github.com/spring-cloud/spring-cloud-gateway/issues/1704</a></p>
<p>在issue中开发人员也给出了回应，<mark class="hl-label pink">确实是SpringCloudGateway的BUG！此问题已在2.2.6.RELEASE版本中修复。而我们项目中使用版本为2.2.3.RELEASE，所以就会出现这个问题。</mark> </p>
 <mark class="hl-label red">原因是：包装原生的pool后没有释放内存。</mark> 

<div align=center><img src="../../../../images/2020/9-12/commit_log.jpg" algin="center"/></div>

<div align=center><img src="../../../../images/2020/9-12/bug_detail.jpg" algin="center"/></div>

<p>提交记录：<a href="https://github.com/spring-cloud/spring-cloud-gateway/pull/2019">https://github.com/spring-cloud/spring-cloud-gateway/pull/2019</a></p>
<p>变更的代码：<a href="https://github.com/spring-cloud/spring-cloud-gateway/pull/2019/commits/4e0f3b0beb51c54e3d5850e00540ff3d19a4264d">https://github.com/spring-cloud/spring-cloud-gateway/pull/2019/commits/4e0f3b0beb51c54e3d5850e00540ff3d19a4264d</a></p>
<h1 id="出乎意料"><a href="#出乎意料" class="headerlink" title="出乎意料"></a>出乎意料</h1><p>问题原因已经找到，想着在测试环境复现后升级版本再验证即可。可结果却出乎了我的意料。</p>
<ol>
<li>测试环境将堆内存调小尝试进行复现生产问题，在压测将近1个小时后出现了同样的问题，复现成功。</li>
<li>升级<code>SpringCloudGateway</code>的版本至<code>2.2.6.RELEASE</code>。</li>
<li><mark class="hl-label red">重新压测，问题再次出现。</mark> </li>
</ol>
<p>你没看错，问题再次出现，且报错信息一模一样。我很快又陷入了沉思。</p>
<h1 id="深究原因"><a href="#深究原因" class="headerlink" title="深究原因"></a>深究原因</h1><p>排除了组件的问题，剩下的就是代码的问题了，最有可能的就是程序中没有显示调用释放内存导致。</p>
<p>网关模块共定义了三个过滤器，一个全局过滤器<code>RequestGatewayFilter implements GlobalFilter</code>。两个自定义过滤器 <code>RequestDecryptGatewayFilterFactory extends AbstractGatewayFilterFactory</code>和<code>ResponseEncryptGatewayFilterFactory extends AbstractGatewayFilterFactory</code>。</p>
<p>依次仔细排查相关逻辑，在全局过滤器<code>RequestGatewayFilter</code>中有一块代码引起了我的注意：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">    HttpHeaders headers = request.getHeaders();</span><br><span class="line">    <span class="keyword">return</span> DataBufferUtils.join(exchange.getRequest().getBody())</span><br><span class="line">            .flatMap(dataBuffer -&gt; &#123;</span><br><span class="line">                DataBufferUtils.retain(dataBuffer);</span><br><span class="line">                Flux&lt;DataBuffer&gt; cachedFlux = Flux.defer(() -&gt; Flux.just(dataBuffer.slice(<span class="number">0</span>, dataBuffer.readableByteCount())));</span><br><span class="line">                </span><br><span class="line">                ServerHttpRequest mutatedRequest = <span class="keyword">new</span> ServerHttpRequestDecorator(exchange.getRequest()) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Flux&lt;DataBuffer&gt; <span class="title">getBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> cachedFlux;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> HttpHeaders <span class="title">getHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> headers;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange.mutate().request(mutatedRequest).build());</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，<mark class="hl-label blue">Request的Body是只能读取一次的，如果直接通过在Filter中读取，而不封装回去回导致后面的服务无法读取数据。</mark> </p>
<blockquote>
<p>此全局过滤器的目的就是把原有的request请求中的body内容读出来，并且使用ServerHttpRequestDecorator这个请求装饰器对request进行包装，重写getBody方法，并把包装后的请求放到过滤器链中传递下去。这样后面的过滤器中再使用exchange.getRequest().getBody()来获取body时，实际上就是调用的重载后的getBody方法，获取的最先已经缓存了的body数据。这样就能够实现body的多次读取了。</p>
</blockquote>
<p>但是将<code>DataBuffer</code>读取出来后并没有手动释内存，会导致堆外内存持续增长。于是添加了一行代码手动释放堆外内存：<mark class="hl-label red">DataBufferUtils.release(dataBuffer);</mark> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">    HttpHeaders headers = request.getHeaders();</span><br><span class="line">    <span class="keyword">return</span> DataBufferUtils.join(exchange.getRequest().getBody())</span><br><span class="line">                .flatMap(dataBuffer -&gt; &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[dataBuffer.readableByteCount()];</span><br><span class="line">                    dataBuffer.read(bytes);</span><br><span class="line">                  <span class="comment">// 释放堆外内存</span></span><br><span class="line">                    DataBufferUtils.release(dataBuffer);</span><br><span class="line">                    ServerHttpRequest mutatedRequest = <span class="keyword">new</span> ServerHttpRequestDecorator(exchange.getRequest()) &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Flux&lt;DataBuffer&gt; <span class="title">getBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> Flux.defer(() -&gt; &#123;</span><br><span class="line">                                DataBuffer buffer = exchange.getResponse().bufferFactory().wrap(bytes);</span><br><span class="line">                                DataBufferUtils.retain(buffer);</span><br><span class="line">                                <span class="keyword">return</span> Mono.just(buffer);</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> HttpHeaders <span class="title">getHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> headers;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="keyword">return</span> chain.filter(exchange.mutate().request(mutatedRequest).build());</span><br><span class="line">                &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次压测未出现堆外内存溢出问题。终究还是自己大意了。。</p>
<blockquote>
<p>后在网络上查询到了类似的案例：<a href="https://github.com/reactor/reactor-netty/issues/788">https://github.com/reactor/reactor-netty/issues/788</a></p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个问题排查花费了自己不少的时间，自己也没有想到这么曲折。问题是解决了，但是暴露了自身的很多问题，比如针对不同版本JVM内存分配不够熟悉、对<code>SpringCloudGateway</code>不够熟悉及太过相信官方开源版本。在直接内存中排查了很久，浪费了不少时间。同时自己也学到了不少东西：</p>
<ol>
<li>遇到问题主要先去思考，要全面且细致，慢慢去分析，抽丝剥茧；</li>
<li>一定要细致再细致，耐心再耐心的去还原问题，思考问题；</li>
<li>JVM直接内存的使用和配置、场景；</li>
<li>不要对开源组件过分信任，遇到问题时，对开源组件持怀疑态度；</li>
</ol>
]]></content>
      <categories>
        <category>组件</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>回顾过去 展望未来</title>
    <url>/%E5%9B%9E%E9%A1%BE%E8%BF%87%E5%8E%BB-%E5%B1%95%E6%9C%9B%E6%9C%AA%E6%9D%A5/</url>
    <content><![CDATA[<p>时间过的可真的是快，转眼间到了2018年，今年的元旦没有出去跨年，而是在家里静静的等待着2018年的到来，不知道是欣喜还是忧郁。2017年我的年度目标只实现了90%，并没有完全达到期望。</p>
<div align=center><img width="700" height="300" src="../../../../images/2018-01/time/2018%E5%8A%A0%E6%B2%B9.jpg" algin="center"/>

</div><span id="more"></span>

<p>自己最近一年来特别不想熬夜，一熬夜第二天就感觉特别的累。这一年自己也学到了很多的东西，虽然感觉很累，但是觉得很开心。公司放假的安排也出来了，腊月二十四，放假立马就回家，又到了一年抢票的时间。几多欢喜几多愁啊。2018也是自己的本命年，加油！加油！</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Redis的分布式锁</title>
    <url>/%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。分布式服务下各个服务同时访问共享资源时，分布式锁就派上用场了。redis用来做缓存很常见，它还有一个非常重要的功能就是做分布式锁。</p>
<h1 id="采坑记录"><a href="#采坑记录" class="headerlink" title="采坑记录"></a>采坑记录</h1><p>Redis分布式锁大部分人都会想到：<code>setnx+lua</code>，或者<code>set key value px milliseconds nx</code>，自己也是吃了这方面的亏。</p>
<p>事情的发展是，我们的服务是分布式服务，其中有个功能是调用第三方接口进行外呼，外呼接口中有个参数<em>accessToken</em>是需要另外两个参数通过HTTP请求换取。每个租户所有员工共用这一个<em>accessToken</em>，<em>accessToken</em>的有效期为<em>120min</em>。刚开始写的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String redisKey = REDIS_KEY_PREFIX + <span class="string">&quot;_&quot;</span> + accountId + <span class="string">&quot;_&quot;</span> + appId + <span class="string">&quot;_&quot;</span> + secret;            </span><br><span class="line">String accessToken = jedis.get(redisKey);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isBlank(accessToken)) &#123;</span><br><span class="line">     accessToken = <span class="keyword">this</span>.getAccessToken(accountId, appId, secret);</span><br><span class="line">     jedis.set(redisKey, accessToken, <span class="string">&quot;nx&quot;</span>, <span class="string">&quot;ex&quot;</span>, <span class="number">5400</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>getAccessToken</em>是获取<em>accessToken</em>的动作。自己还是太年轻，以为一个<em>setnx</em>就可以解决问题(实际等于没加锁)。在高并发的情况下多个请求会同时进入<em>getAccessToken</em>方法获取多个<em>accessToken</em>，但是第三方系统里面存储的是最后一次请求的那个<em>accessToken</em>，由于<em>getAccessToken</em>是HTTP请求且每个请求时间都是不确定的，导致我们这边根本就不知道第三方系统存储的是哪个，结果就是客户反馈外呼电话一直提示“请检查accessToken是否正确”，赶紧排查问题 。</p>
<h1 id="封装redis分布式锁"><a href="#封装redis分布式锁" class="headerlink" title="封装redis分布式锁"></a>封装redis分布式锁</h1><p>自己当时也是那个着急，就搞了个不太完善的redis分布式锁。</p>
<p>首先有个<strong>RedisDistributeLock</strong>类，里面提供了分布式加锁和释放锁的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis实现的分布式锁。会阻塞当前线程。</span></span><br><span class="line"><span class="comment"> * 只处理了 多个服务访问同一个redis实例， 且该redis实例正常工作的情况。</span></span><br><span class="line"><span class="comment"> * 没有处理 redis故障切换的情况。</span></span><br><span class="line"><span class="comment"> * 时间漂移的问题也没有很好的解决办法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisDistributeLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Jedis <span class="title">getRedisClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mini second.</span></span><br><span class="line"><span class="comment">     * 考虑到时间漂移，这个值应该设置大一些。</span></span><br><span class="line"><span class="comment">     * 但是如果设置的过大，当获得lock的线程挂掉以后，别的服务就长时间获取不到该lock, 必须等到该lock过期。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> lockTimeOut = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requireLock</span><span class="params">(String lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        Jedis jedis = <span class="keyword">this</span>.getRedisClient();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">            ret = jedis.setnx(lock, String.valueOf(now + RedisDistributeLock.lockTimeOut)).intValue();</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> == ret) &#123;</span><br><span class="line">                <span class="comment">/**lock不存在，可以获得锁*/</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                String curLockValue = jedis.get(lock);</span><br><span class="line">                <span class="comment">/**这个时刻有可能lock又被删除了，所以重新做一次检查*/</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == curLockValue) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/**lock过期了*/</span></span><br><span class="line">                <span class="keyword">if</span> (now &gt; Long.parseLong(curLockValue)) &#123;</span><br><span class="line">                    String oldLockValue = jedis.getSet(lock, String.valueOf(now + RedisDistributeLock.lockTimeOut));</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == oldLockValue) &#123;</span><br><span class="line">                        <span class="comment">/**要么getset之前lock不存在, 要么getset之前lock存在但没有值，</span></span><br><span class="line"><span class="comment">                         * 我不确定会不会出现第二种情况，所以重新去请求锁。*/</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (now &gt; Long.parseLong(oldLockValue)) &#123;</span><br><span class="line">                        <span class="comment">/**抢到了这个过期的lock, 并且已经已经设置成功*/</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">(String lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        Jedis jedis = <span class="keyword">this</span>.getRedisClient();</span><br><span class="line">        <span class="comment">//jedis.eva</span></span><br><span class="line">        <span class="keyword">if</span> (now &lt; Long.valueOf(jedis.get(lock))) &#123;</span><br><span class="line">            jedis.del(lock);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在分布式下只需将需要同步的代码块放在<code>distributeLock.requireLock</code>和<code>distributeLock.releaseLock</code>中即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String lock_key = REDIS_KEY_PREFIX + <span class="string">&quot;_&quot;</span> + accountId + <span class="string">&quot;_&quot;</span> + appId + <span class="string">&quot;_&quot;</span> + secret;</span><br><span class="line">String accessToken;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    distributeLock.requireLock(lock_key);</span><br><span class="line">    &#123;</span><br><span class="line">        accessToken = client.get(redis_key);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(accessToken)) &#123;</span><br><span class="line">            accessToken = <span class="keyword">this</span>.getAccessToken();</span><br><span class="line">            client.set(redis_key, accessToken);</span><br><span class="line">            client.expire(redis_key, <span class="number">3</span>);</span><br><span class="line">            log.info(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + accessToken);</span><br><span class="line">        &#125;</span><br><span class="line">        distributeLock.releaseLock(lock_key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Excetion e)&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    distributeLock.releaseLock(lock_key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然解决了同步获取<em>accessToken</em>的问题，但是对于异常情况的考虑还是欠缺，请求线程同时还是阻塞的，自己测试在TPS为700时还可以扛住，高于单个服务负载或是redis故障时请求被阻塞会导致服务受到影响。</p>
<h1 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h1><p>Redisson是基于Redlock实现同时也是redis官方推荐的分布式JAVA客户端，和Jedis相比它实现了分布式和可扩展的JAVA数据结构。在Redisson中提供了现成的分布式锁的方法。</p>
<p><img src="../../../../images/2018-8/Redisson.jpg" alt="Redisson"></p>
<h2 id="Maven引入Redisson"><a href="#Maven引入Redisson" class="headerlink" title="Maven引入Redisson"></a>Maven引入Redisson</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="分布式锁用法"><a href="#分布式锁用法" class="headerlink" title="分布式锁用法"></a>分布式锁用法</h2><p>在分布式下加锁<em>lock</em>和释放锁<em>unlock</em>的伪代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RedissonClient redisson;</span><br><span class="line"></span><br><span class="line">String lock_key = REDIS_KEY_PREFIX + accountId + <span class="string">&quot;_&quot;</span> + appId + <span class="string">&quot;_&quot;</span> + secret;</span><br><span class="line">String accessToken = client.get(redis_key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer()</span><br><span class="line">                .setTimeout(<span class="number">1000000</span>)</span><br><span class="line">                .setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>);</span><br><span class="line">        redisson = Redisson.create(config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(accessToken)) &#123;</span><br><span class="line">    <span class="comment">// 1.获得锁对象实例</span></span><br><span class="line">    RLock lock = redisson.getLock(lock_key);</span><br><span class="line">    <span class="comment">// 2.获取分布式锁</span></span><br><span class="line">    lock.lock(); </span><br><span class="line">    accessToken = client.get(redis_key);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(accessToken)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            accessToken = <span class="keyword">this</span>.getAccessToken();</span><br><span class="line">            client.set(redis_key, accessToken);</span><br><span class="line">            client.expire(redis_key, <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 3.释放锁</span></span><br><span class="line">            lock.unlock(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当然，分布式锁不止基于redis和redisson这两种方案，还有数据库乐观锁、基于ZooKeeper的分布式锁等。但是在基于redis方面，通过自己的分析及测试，<strong>Redisson在分布式锁方面是还是首选</strong>，同时Redisson不光是针对锁，同时提供了很多客户端操作redis的方法，也需要自己去摸索。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>增强式SnowFlake(雪花算法)</title>
    <url>/%E5%A2%9E%E5%BC%BA%E5%BC%8FSnowFlake-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在众多分布式ID中，雪花算法是比较简单且常用的算法，分布式ID一般具有的特性有：</p>
<ol>
<li><strong>唯一性</strong>：生成的ID全局唯一，在特定范围内冲突极小。</li>
<li><strong>有序性</strong>：生成的ID全局或按规则有序，便于数据库插入及排序。</li>
<li><strong>可用性</strong>：可保证高并发下的可用性，确保任何时候都能正确的生成ID。</li>
<li><strong>自主性</strong>：分布式情况下不依赖中心认证即可自行生成ID。</li>
<li><strong>安全性</strong>：不暴露系统和业务的信息，如：订单数、用户数….</li>
</ol>
<h1 id="常见的分布式ID生成方式比较"><a href="#常见的分布式ID生成方式比较" class="headerlink" title="常见的分布式ID生成方式比较"></a>常见的分布式ID生成方式比较</h1><table>
<thead>
<tr>
<th align="center">比较点</th>
<th align="center">SnowFlake</th>
<th align="center"><a href="https://github.com/Meituan-Dianping/Leaf">Leaf</a></th>
<th align="center"><a href="https://github.com/baidu/uid-generator">UidGenerator</a></th>
<th align="center"><a href="https://redis.io/">Redis</a></th>
</tr>
</thead>
<tbody><tr>
<td align="center">依赖数据库</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">可选</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">支持分布式</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">可预测</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">依赖性</td>
<td align="center">毫秒级时间戳 + 标识 位 + 序列号</td>
<td align="center">时间戳 + node + pid + 序列号</td>
<td align="center">秒级时间戳 + workId + 序列</td>
<td align="center">Redis单线程自增</td>
</tr>
<tr>
<td align="center">维护中</td>
<td align="center">多个变种</td>
<td align="center">是</td>
<td align="center">否</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h1 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h1><p><code>SnowFlake</code>是Twitter开源的分布式ID生成算法，生成的一个<code>64bit</code>的<code>long</code>类型数值，组成部分使用了时间戳，保证了粗略自增。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li><strong>高性能高可用</strong>：完全在内存中生成，不依赖数据库。</li>
<li><strong>高吞吐</strong>：每秒能生成数百万的自增ID。</li>
<li><strong>ID自增</strong>：生成的ID粗略自增，存入数据库索引效率高，减少内存碎片。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><strong>时钟回拨</strong>：强依赖系统时间，如果系统时间被回拨或者改变，可能会造成ID冲突或者重复。</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>总体结构如下，包含四个部分：</p>
<div align=center><img src="../../../../images/2022/7-9/snowflake_1.png" algin="center"/></div>

<p><strong>符号位</strong>：<code>1bit</code>。最高位是符号位，固定为0。0表示正，1表示负。</p>
<p><strong>时间戳</strong>：<code>41bit</code>。毫秒级时间戳（41位的长度可以使用69年）。</p>
<p><strong>标识位</strong>：<code>5bit</code>数据中心ID（DataCenterId），<code>5bit</code>工作机器ID（WorkId），两个标识位组合最多可支持部署1024个节点。</p>
<p><strong>序列号</strong>：<code>12bit</code>。递增序列号，毫秒内生成的ID通过序列号表示唯一，<code>12bit</code>每毫秒可产生4096个ID。</p>
<blockquote>
<p>默认的雪花算法是64bit，具体长度也可以自行配置。</p>
<ul>
<li><p>如果并发很高，增加序列号位数。</p>
</li>
<li><p>如果希望运行的更久，增加时间戳的位数。</p>
</li>
<li><p>如果需要支持更多节点部署，增加标识位长度。</p>
</li>
</ul>
</blockquote>
<h2 id="分配标识位"><a href="#分配标识位" class="headerlink" title="分配标识位"></a>分配标识位</h2><p><code>DataCenterId</code>和<code>WorkId</code>都只有<code>5bit</code>，最大值为<code>31</code>。在Mybatis-Plus中标识位的获取依赖Mac地址和进程PID，虽然能够做到尽量不重复，但是仍有小几率重复。可通过<strong>预分配</strong>和<strong>动态分配</strong>来避免标识位重复。</p>
<h3 id="预分配"><a href="#预分配" class="headerlink" title="预分配"></a>预分配</h3><p>通过人工申请每个服务的实例节点标识位。</p>
<p>此方案没有代码开发量，在服务固定节点或者项目少时可以用，但是无法解决服务动态扩容的问题。</p>
<h3 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h3><p>通过将标识位存放在 <code>Redis</code>、<code>Zookeeper</code>、<code>MySQL</code> 等中间件，在服务启动的时候去请求标识位，请求后标识位更新为下一个可用的标识位。通过存放标识位，延伸出另一个问题：雪花算法的 ID 是 <strong>服务内唯一还是全局唯一</strong>。</p>
<p>以<code>Redis</code>为例，如果要做服务内唯一，存放标识位的Redis节点使用自己项目内的就可以；如果是全局唯一，所有使用雪花算法的应用，要用同一个<code>Redis</code>节点。</p>
<p>两者的区别仅是<strong>不同的服务间是否公用Redis</strong>。如果没有全局唯一的需求，最好使服务内唯一，因为这样可以避免单点问题。</p>
<blockquote>
<p>服务的节点数超过1024，则需要做额外的扩展；可以扩展10bit 标识位，或者选择开源分布式ID框架</p>
</blockquote>
<p><strong>动态分配实现方案</strong></p>
<p>Redis存储一个<code>Hash</code>结构Key，包含两个键值对：<code>DataCenterId</code> 和 <code>WorkerId</code>。</p>
<div align=center><img src="../../../../images/2022/7-9/snowflake_2.png" algin="center"/></div>

<p>在应用启动时，通过<strong>Lua脚本</strong>去Redis获取标识位。<code>DataCenterId</code>和<code>WorkerId</code>的获取与自增在<strong>Lua脚本</strong>中完成，调用返回后就是可用的标识位。</p>
<div align=center><img src="../../../../images/2022/7-9/snowflake_3.png" algin="center"/></div>

<p>具体<strong>Lua脚本</strong>逻辑如下：</p>
<ol>
<li>第一个服务节点在获取时，<code>Redis</code>可能是没有 <code>cache:id:generator</code> Hash key的，先判断Hash是否存在，不存在初始化Hash，<code>DataCenterId</code>、<code>WorkerId</code> 初始化为<strong>0</strong>；</li>
<li>如果Hash已存在，判断 <code>DataCenterId</code>、<code>WorkerId</code>是否等于最大值<strong>31</strong>，满足条件初始化<code>DataCenterId</code>、<code>WorkerId</code> 设置为<strong>0</strong>返回；</li>
<li><code>DataCenterId</code>和<code>WorkerId</code> 的排列组合一共是<strong>1024</strong>，在进行分配时，先分配<code>WorkerId</code>；</li>
<li>判断<code>WorkerId</code>是否 <strong>!= 31</strong>，条件成立对<code>WorkerId</code>自增，并返回；如果<strong>WorkerId = 31</strong>，自增<code>DataCenterId</code>并将<code>WorkerId</code>设置为<strong>0</strong>；</li>
</ol>
<p><code>DataCenterId</code>、<code>WorkerId</code>是一直向下推进的，总体形成一个环状。通过<strong>Lua脚本的原子性</strong>，保证<strong>1024</strong>节点下的雪花算法生成不重复。如果标识位等于<strong>1024</strong>，则从头开始继续循环推进。</p>
<div align=center><img src="../../../../images/2022/7-9/snowflake_4.png" algin="center"/></div>

<h3 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h3><ul>
<li><code>KEY</code>：为Redis的HashKey。</li>
<li><code>ARGV</code>：一个或两个参数。系统编码、模块编码。</li>
<li><code>RETURN</code>：返回值为英文冒号分隔的字符串。<code>DataCenterId:WorkerId</code></li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Hash Key</span></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 分隔符</span></span><br><span class="line"><span class="keyword">local</span> SPLITTER = <span class="string">&#x27;:&#x27;</span></span><br><span class="line"><span class="keyword">local</span> SYSTEM_CODE = ARGV[<span class="number">1</span>] .. SPLITTER</span><br><span class="line"><span class="keyword">local</span> SERVICE_NAME = ARGV[<span class="number">2</span>] <span class="keyword">and</span> ARGV[<span class="number">2</span>] .. SPLITTER <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">local</span> MAX_ID = <span class="number">31</span></span><br><span class="line"><span class="keyword">local</span> FIELD_DATA_CENTER = SYSTEM_CODE .. SERVICE_NAME .. <span class="string">&#x27;dataCenterId&#x27;</span></span><br><span class="line"><span class="keyword">local</span> FIELD_WORKER = SYSTEM_CODE .. SERVICE_NAME .. <span class="string">&#x27;workerId&#x27;</span></span><br><span class="line"><span class="comment">-- 看能不能获取到</span></span><br><span class="line"><span class="keyword">local</span> datacenterId = redis.call(<span class="string">&#x27;HGET&#x27;</span>, key, FIELD_DATA_CENTER)</span><br><span class="line"><span class="keyword">local</span> workerId = redis.call(<span class="string">&#x27;HGET&#x27;</span>, key, FIELD_WORKER)</span><br><span class="line"><span class="comment">-- dataCenterId或workId为空 or daCenterId或workId有一个达到最大值。此时需要重置dataCenterId和workId为0</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">not</span> datacenterId <span class="keyword">or</span> <span class="keyword">not</span> workerId) <span class="keyword">or</span> (<span class="built_in">tonumber</span>(datacenterId) == MAX_ID <span class="keyword">and</span> <span class="built_in">tonumber</span>(workerId) == MAX_ID) <span class="keyword">then</span></span><br><span class="line">    datacenterId = <span class="number">0</span></span><br><span class="line">    workerId = <span class="number">0</span></span><br><span class="line">    redis.call(<span class="string">&#x27;HSET&#x27;</span>, key, FIELD_DATA_CENTER, datacenterId)</span><br><span class="line">    redis.call(<span class="string">&#x27;HSET&#x27;</span>, key, FIELD_WORKER, workerId)</span><br><span class="line">    <span class="keyword">return</span> datacenterId .. SPLITTER .. workerId</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 当workId达到最大值且dataCenterId未达到最大值时，需要将dataCenterId自增、workId重置为0</span></span><br><span class="line"><span class="comment">-- 否则直接自增workId</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">tonumber</span>(workerId) == MAX_ID <span class="keyword">and</span> <span class="built_in">tonumber</span>(datacenterId) ~= MAX_ID) <span class="keyword">then</span></span><br><span class="line">    workerId = <span class="number">0</span></span><br><span class="line">    datacenterId = redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, FIELD_DATA_CENTER, <span class="number">1</span>)</span><br><span class="line">    redis.call(<span class="string">&#x27;HSET&#x27;</span>, key, FIELD_WORKER, workerId)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    workerId = redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, FIELD_WORKER, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 返回包含workId和dataCenterId的固定格式字符串</span></span><br><span class="line"><span class="keyword">return</span> datacenterId .. SPLITTER .. workerId</span><br></pre></td></tr></table></figure>

<h3 id="SpringBoot中使用"><a href="#SpringBoot中使用" class="headerlink" title="SpringBoot中使用"></a>SpringBoot中使用</h3><p>可以将上面<strong>Lua脚本</strong>保存为<code>IdGen.lua</code>，在开发中编码、调试会更加方便。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pair&lt;Integer, Integer&gt; <span class="title">getIdentifier</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DefaultRedisScript&lt;String&gt; redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">        String script = FileUtils.readFileToString(<span class="keyword">new</span> File(<span class="keyword">this</span>.getClass().getResource(<span class="string">&quot;/scripts/IdGen.lua&quot;</span>).getPath()), Charset.defaultCharset());</span><br><span class="line">        redisScript.setScriptText(script);</span><br><span class="line">        redisScript.setResultType(String.class);</span><br><span class="line">        <span class="comment">// KEY可自定义，ARGV可传一个或两个</span></span><br><span class="line">        String result = redisTemplate.execute(redisScript, Lists.newArrayList(<span class="string">&quot;cache:snowflake:id&quot;</span>), <span class="string">&quot;SYSTEM_CODE&quot;</span>, <span class="string">&quot;MODULE_NAME&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> dataCenterId = Integer.parseInt(result.split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> workId = Integer.parseInt(result.split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> Pair.of(dataCenterId, workId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>雪花算法可满足大部分场景，如无必要，<strong>不建议引入开源方案增加系统复杂度</strong>。</p>
]]></content>
      <categories>
        <category>设计</category>
      </categories>
  </entry>
  <entry>
    <title>大话数据库连接池</title>
    <url>/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>数据库连接池在Java数据库相关中间件产品群中，应该算是最底层最基础的一类产品，作为企业应用开发必不可少的组件，无数开发者们贡献了一个又一个的优秀产品，它们有的随着时代发展，功成身退，有的还在不断迭代，老而弥坚，更有新生代产品，或性能无敌、或功能全面。接下来就聊一聊  “那些年，我们用过的数据库连接池。”<div  align=center><img src="../../../../images/2018-02/dataSource/index.jpg" algin="center"/></div></p>
<h1 id="第一、二代连接池"><a href="#第一、二代连接池" class="headerlink" title="第一、二代连接池"></a>第一、二代连接池</h1><p>区分一个数据库连接池是属于第一代产品还是代二代产品有一个最重要的特征就是看它在架构和设计时采用的线程模型，因为这直接影响的是并发环境下存取数据库连接的性能。</p>
<p>一般来讲采用单线程同步的架构设计都属于第一代连接池，二采用多线程异步架构的则属于第二代。比较有代表性的就是Apache Commons DBCP，在1.x版本中，一直延续着单线程设计模式，到2.x才采用多线程模型。</p>
<p>用版本发布时间来辨别区分两代产品，则一个偷懒的好方法。以下是这些常见数据库连接池最新版本的发布时间：</p>
<table>
<thead>
<tr>
<th>数据库连接池</th>
<th>最新版本</th>
<th>发布时间</th>
</tr>
</thead>
<tbody><tr>
<td>C3P0</td>
<td>c3p0-0.9.5.2</td>
<td>on 9 Dec 2015</td>
</tr>
<tr>
<td>DBCP</td>
<td>2.2.0</td>
<td>27 December 2017</td>
</tr>
<tr>
<td>Druid</td>
<td>0.11.0</td>
<td>Dec 4 2017</td>
</tr>
<tr>
<td>HikariCP</td>
<td>2.7.6</td>
<td>2018-01-14</td>
</tr>
</tbody></table>
<p>从表中可以看出，C3P0已经很久没有更新了。DBCP更新速度很慢，基本处于不活跃状态，而Druid和HikariCP处于活跃状态的更新中，这就是我们说的二代产品了。</p>
<p>二代产品对一代产品的超越是颠覆性的，除了一些“历史原因”，你很难再找到第二条理由说服自己不选择二代产品，但任何成功都不是偶然的，二代产品的成功很大程度上得益于前代产品们打下的基础，站在巨人的肩膀上，新一代的连接池的设计师们将这一项“工具化”的产品，推向了极致。其中，最具代表性的两款产品是：</p>
<ul>
<li>HikariCP</li>
<li>Druid</li>
</ul>
<h1 id="彻底死掉的C3P0"><a href="#彻底死掉的C3P0" class="headerlink" title="彻底死掉的C3P0"></a>彻底死掉的C3P0</h1><p>C3P0是我使用的第一款数据库连接池，在很长一段时间内，它一直是Java领域内数据库连接池的代名词，当年盛极一时的Hibernate都将其作为内置的数据库连接池，可以业内对它的稳定性还是认可的。C3P0功能简单易用，稳定性好这是它的优点，但是性能上的缺点却让它彻底被打入冷宫。C3P0的性能很差，差到即便是同时代的产品相比它也是垫底的，更不用和Druid、HikariCP等相比了。正常来讲，有问题很正常，改就是了，但c3p0最致命的问题就是架构设计过于复杂，让重构变成了一项不可能完成的任务。随着国内互联网大潮的涌起，性能有硬伤的c3p0彻底的退出了历史舞台。</p>
<div align=center><img src="../../../../images/2018-02/dataSource/1.png" algin="center"/>
</div>


<h1 id="咸鱼翻身的DBCP"><a href="#咸鱼翻身的DBCP" class="headerlink" title="咸鱼翻身的DBCP"></a>咸鱼翻身的DBCP</h1><p>DBCP（DataBase Connection Pool）属于Apache顶级项目Commons中的核心子项目（最早在Jakarta Commons里就有）,在Apache的生态圈中的影响里十分广泛，比如最为大家所熟知的Tomcat就在内部集成了DBCP，实现JPA规范的OpenJPA，也是默认集成DBCP的。但DBCP并不是独立实现连接池功能的，它内部依赖于Commons中的另一个子项目Pool，连接池最核心的“池”，就是由Pool组件提供的，因此，DBCP的性能实际上就是Pool的性能，DBCP和Pool的依赖关系如下表：</p>
<table>
<thead>
<tr>
<th>Apache Commons DBCP</th>
<th>Apache Commons Pool</th>
</tr>
</thead>
<tbody><tr>
<td>v1.2.2</td>
<td>v1.3</td>
</tr>
<tr>
<td>v1.3</td>
<td>v1.5.4</td>
</tr>
<tr>
<td>v1.4</td>
<td>v1.5.4</td>
</tr>
<tr>
<td>v2.0.x</td>
<td>v2.2</td>
</tr>
<tr>
<td>v2.1.x</td>
<td>v2.4.2</td>
</tr>
<tr>
<td>v2.2.x</td>
<td>v2.5.0</td>
</tr>
</tbody></table>
<p>可以看到，因为核心功能依赖于Pool，所以DBCP本身只能做小版本的更新，真正大版本的更迭则完全依托于pool。有很长一段时间，pool都还是停留在1.x版本，这直接导致DBCP也更新乏力。很多依赖DBCP的应用在遇到性能瓶颈之后，别无选择，只能将其替换掉，DBCP忠实的拥趸tomcat就在其tomcat 7.0版本中，自己重新设计开发出了一套连接池（Tomcat JDBC Pool）。好在，在2013年事情终于迎来转机，13年9月Commons-Pool 2.0版本发布，14年2月份，DBCP也终于迎来了自己的2.0版本，基于新的线程模型全新设计的“池”让DBCP重焕青春，虽然和新一代的连接池相比仍有一定差距，但差距并不大，DBCP2.x版本已经稳稳达到了和新一代产品同级别的性能指标（见下图）。</p>
<div align=center><img src="../../../../images/2018-02/dataSource/3.png" algin="center"/>


</div>

<p>DBCP终于靠Pool咸鱼翻身，打了一个漂亮的翻身仗，但长时间的等待已经完全消磨了用户的耐心，与新一代的产品项目相比，DBCP没有任何优势，试问，谁会在有选择的前提下，去选择那个并不优秀的呢？也许，现在还选择DBCP2的唯一理由，就是情怀吧。</p>
<h1 id="性能无敌的HikariCP"><a href="#性能无敌的HikariCP" class="headerlink" title="性能无敌的HikariCP"></a>性能无敌的HikariCP</h1><p>HikariCP号称“性能杀手”（It’s Faster），它的表现究竟如何呢，先来看下官网提供的数据：</p>
<div align=center><img src="../../../../images/2018-02/dataSource/4.png" algin="center"/>


</div>

<p>不光性能强劲，稳定性也不差：</p>
<div align=center><img src="../../../../images/2018-02/dataSource/5.png" algin="center"/>


</div>

<p>那它是怎么做到如此强劲的呢？官网给出的说明如下：</p>
<ul>
<li>字节码精简：优化代码，直到编译后的字节码最少，这样，CPU缓存可以加载更多的程序代码；</li>
<li>优化代理和拦截器：减少代码，例如HikariCP的Statement proxy只有100行代码；</li>
<li>自定义数组类型（FastStatementList）代替ArrayList：避免每次get()调用都要进行range check，避免调用remove()时的从头到尾的扫描；</li>
<li>自定义集合类型（ConcurrentBag）：提高并发读写的效率；</li>
<li>其他缺陷的优化，比如对于耗时超过一个CPU时间片的方法调用的研究（但没说具体怎么优化）。</li>
</ul>
<p>可以看到，上述这几点优化，和现在能找到的资料来看，HakariCP在性能上的优势应该是得到共识的，再加上它自身小巧的身形，在当前的“云时代、微服务”的背景下，HakariCP一定会得到更多人的青睐。</p>
<h1 id="功能全面的Druid"><a href="#功能全面的Druid" class="headerlink" title="功能全面的Druid"></a>功能全面的Druid</h1><p>近几年，阿里在开源项目上动作频频，除了有像fastJson、dubbo这类项目，更有像AliSQL这类的大型软件，今天说的Druid，就是阿里众多优秀开源项目中的一个。它除了提供性能卓越的连接池功能外，还集成了SQL监控，黑名单拦截等功能，用它自己的话说，Druid是“为监控而生”。借助于阿里这个平台的号召力，产品一经发布就赢得了大批用户的拥趸，从用户使用的反馈来看，Druid也确实没让用户失望。</p>
<p>相较于其他产品，Druid另一个比较大的优势，就是中文文档比较全面（毕竟是国人的项目么），在github的<a href="https://github.com/alibaba/druid/wiki/%E9%A6%96%E9%A1%B5"><em>wiki页面</em></a>，列举了日常使用中可能遇到的问题，对一个新用户来讲，上面提供的内容已经足够指导它完成产品的配置和使用了。</p>
<p>下图为Druid自己提供的性能测试数据：</p>
<div align=center><img src="../../../../images/2018-02/dataSource/6.png" algin="center"/>

</div>

<p>现在项目开发中，我还是比较倾向于使用Durid，它不仅仅是一个数据库连接池，它还包含一个ProxyDriver，一系列内置的JDBC组件库，一个SQL Parser。</p>
<h2 id="Druid-相对于其他数据库连接池的优点"><a href="#Druid-相对于其他数据库连接池的优点" class="headerlink" title="Druid 相对于其他数据库连接池的优点"></a>Druid 相对于其他数据库连接池的优点</h2><ol>
<li><p>强大的监控特性，通过Druid提供的监控功能，可以清楚知道连接池和SQL的工作情况。</p>
<p>a. 监控SQL的执行时间、ResultSet持有时间、返回行数、更新行数、错误次数、错误堆栈信息；</p>
<p>b. SQL执行的耗时区间分布。什么是耗时区间分布呢？比如说，某个SQL执行了1000次，其中0<del>1毫秒区间50次，1</del>10毫秒800次，10<del>100毫秒100次，100</del>1000毫秒30次，1~10秒15次，10秒以上5次。通过耗时区间分布，能够非常清楚知道SQL的执行耗时情况；</p>
<p>c.  监控连接池的物理连接创建和销毁次数、逻辑连接的申请和关闭次数、非空等待次数、PSCache命中率等。</p>
</li>
<li><p>方便扩展。Druid提供了Filter-Chain模式的扩展API，可以自己编写Filter拦截JDBC中的任何方法，可以在上面做任何事情，比如说性能监控、SQL审计、用户名密码加密、日志等等。</p>
</li>
<li><p>Druid集合了开源和商业数据库连接池的优秀特性，并结合阿里巴巴大规模苛刻生产环境的使用经验进行优化。</p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>时至今日，虽然每个应用（需要RDBMS的）都离不开连接池，但在实际使用的时候，连接池已经可以做到“隐形”了。也就是说在通常情况下，连接池完成项目初始化配置之后，就再不需要再做任何改动了。不论你是选择Druid或是HikariCP，甚至是DBCP，它们都足够稳定且高效！之前讨论了很多关于连接池的性能的问题，但这些性能上的差异，是相较于其他连接池而言的，对整个系统应用来说，第二代连接池在使用过程中体会到的差别是微乎其微的，基本上不存在因为连接池的自身的配饰和使用导致系统性能下降的情况，除非是在单点应用的数据库负载足够高的时候（压力测试的时候），但即便是如此，通用的优化的方式也是单点改集群，而不是在单点的连接池上死扣。</p>
<p><strong>参考</strong></p>
<ul>
<li><a href="https://link.jianshu.com/?t=http://blog.csdn.net/hetaohappy/article/details/50462486"><em>数据库连接池性能比对</em></a></li>
<li><a href="https://www.jianshu.com/p/53de4b76f98c"><em>大话数据库连接池</em></a></li>
<li><a href="https://link.jianshu.com/?t=http://blog.csdn.net/whzhaochao/article/details/49559931"><em>c3p0,Druid,Tomcat Jdbc Pool,dbcp2,proxool数据源性能比较</em></a></li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>异地多活架构设计</title>
    <url>/%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="高可用三大核心原理"><a href="#高可用三大核心原理" class="headerlink" title="高可用三大核心原理"></a><a href="https://www.mubucm.com/doc/fOvMJ_H3fp">高可用三大核心原理</a></h1><h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><blockquote>
<p>分布式数据存储系统不可能同时满足一致性、可用性和分区容忍性。</p>
</blockquote>
<ul>
<li><strong>一致性 Consistency</strong></li>
<li><strong>可用性 Availability</strong></li>
<li><strong>分区容忍性 Partion Tolerance</strong></li>
</ul>
<h2 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h2><blockquote>
<p>核心思想是即使无法做到强一致性（CAP 的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性。</p>
</blockquote>
<ul>
<li><strong>基本可用 Basically Available</strong></li>
<li><strong>软状态 Soft State</strong></li>
<li><strong>最终一致性 Eventually Consistency</strong></li>
</ul>
<h2 id="FLP"><a href="#FLP" class="headerlink" title="FLP"></a>FLP</h2><blockquote>
<p>异步通信场景中，即使只允许一个节点失败，也没有任何确定性算法能够保证非失败进程达到一致性。</p>
</blockquote>
<ul>
<li><strong>Safety</strong></li>
<li><strong>Fault Tolerance</strong></li>
<li><strong>Liveness</strong></li>
</ul>
<div align=center><img src="../../../../images/2022/4-6/7.1_core_principles.png" algin="center"/></div>

<h1 id="FEMA"><a href="#FEMA" class="headerlink" title="FEMA"></a><a href="https://www.mubucm.com/doc/2hPswMhdL_p">FEMA</a></h1><h2 id="具体含义"><a href="#具体含义" class="headerlink" title="具体含义"></a>具体含义</h2><ol>
<li><strong>Failure</strong>：假设系统某些组件或者模块出现故障。 </li>
<li><strong>Mode</strong>： 故障发生的方式、可能性。</li>
<li><strong>Effect</strong> ：故障的影响。 </li>
<li><strong>Analysis</strong>：分析系统的可能反应，以及如何改进。</li>
</ol>
<h2 id="评估维度"><a href="#评估维度" class="headerlink" title="评估维度"></a>评估维度</h2><div align=center><img src="../../../../images/2022/4-6/7.2_FEMA_1.jpg" algin="center"/></div>

<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><div align=center><img src="../../../../images/2022/4-6/7.2_FEMA.png" algin="center"/></div>

<h1 id="业务及灾备架构"><a href="#业务及灾备架构" class="headerlink" title="业务及灾备架构"></a><a href="https://www.mubucm.com/doc/6jZ_a-ex9_p">业务及灾备架构</a></h1><h2 id="常用架构"><a href="#常用架构" class="headerlink" title="常用架构"></a>常用架构</h2><ol>
<li>同城双中心。</li>
<li>跨域紧邻双中心。</li>
<li>跨域远端双中心。</li>
<li>跨国数据中心。</li>
</ol>
<div align=center><img src="../../../../images/2022/4-6/7.3_arch_disaster_recovery.png" algin="center"/></div>

<h1 id="异地多活架构模式"><a href="#异地多活架构模式" class="headerlink" title="异地多活架构模式"></a><a href="https://www.mubucm.com/doc/LzoAl8Dz_p">异地多活架构模式</a></h1><h2 id="业务定制型"><a href="#业务定制型" class="headerlink" title="业务定制型"></a>业务定制型</h2><p>按照业务的优先级进行排序，优先保证核心业务异地多活 ；基于核心业务的流程和数据，设计定制化的异地多活架构。</p>
<h2 id="业务通用型"><a href="#业务通用型" class="headerlink" title="业务通用型"></a>业务通用型</h2><p>通过配套服务来支持异地多活，无需按照业务优先级排序来挑选某些业务实现异地多活，只需要判断业务是否能异地多活。</p>
<h2 id="存储通用型"><a href="#存储通用型" class="headerlink" title="存储通用型"></a>存储通用型</h2><p>采用本身已经支持分布式一致性的存储系统，架构天然支持异地多活。</p>
<div align=center><img src="../../../../images/2022/4-6/7.4_arch_disaster_recovery.png" algin="center"/></div>

<h1 id="异地多活"><a href="#异地多活" class="headerlink" title="异地多活"></a><a href="https://www.mubucm.com/doc/7qYWdkd0WLp">异地多活</a></h1><h2 id="1个原理"><a href="#1个原理" class="headerlink" title="1个原理"></a>1个原理</h2><ul>
<li>异地多活本质上都是AP方案</li>
</ul>
<h2 id="3大原则"><a href="#3大原则" class="headerlink" title="3大原则"></a>3大原则</h2><ul>
<li>只保证核心业务。</li>
<li>只能做到最终一致性。</li>
<li>只能保证绝大部分用户。</li>
</ul>
<h2 id="4个步骤"><a href="#4个步骤" class="headerlink" title="4个步骤"></a>4个步骤</h2><ol>
<li>业务分组。</li>
<li>数据分类。</li>
<li>数据同步。</li>
<li>异常梳理。</li>
</ol>
<h2 id="5大技巧"><a href="#5大技巧" class="headerlink" title="5大技巧"></a>5大技巧</h2><ol>
<li>消息队列同步。</li>
<li>库存拆分。</li>
<li>事务合并</li>
<li>实时改异步。</li>
<li>适当容忍。</li>
</ol>
<div align=center><img src="../../../../images/2022/4-6/7.5_arch_disaster_recovery.png" algin="center"/></div>
]]></content>
      <categories>
        <category>架构</category>
        <category>设计</category>
      </categories>
  </entry>
  <entry>
    <title>protostuff序列化</title>
    <url>/protostuff%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>HTTP通信离不开对象的序列化和反序列化。通过序列化技术，可以跨语言实现数据的传输，将对象转换为字节序列，然后在网络上传送；通过反序列化，可以将字节序列转换为对象。<span id="more"></span> 基本原理和网络通信是一致的，通过特殊的编码方式，写入数据将对象以及其内部数据编码，存在在数组或者文件里面然后发送到目的地后，在进行解码，读出数据。</p>
<div align=center><img width="250" height="220" src="../../../../images/2019/1-3/protostuff.png" algin="center"/>
</div>

<h1 id="protostuff"><a href="#protostuff" class="headerlink" title="protostuff"></a>protostuff</h1><p>protostuff是Google出品的一种轻量并且高效的结构化数据存储格式，性能比 <code>JSON</code>、<code>XML</code> 要高很多。</p>
<p>之所以性能如此好，主要得益于两个：<strong>第一</strong>，它使用 proto 编译器，自动进行序列化和反序列化，速度非常快，应该比 <code>XML</code> 和 <code>JSON</code> 快上了 <code>20~100</code> 倍；<strong>第二</strong>，它的数据压缩效果好，就是说它序列化后的数据量体积小。因为体积小，传输起来带宽和速度上会有优化。</p>
<p>详细效率对比可参考：<a href="https://www.cnblogs.com/xiaoMzjm/p/4555209.html">java序列化/反序列化之xstream、protobuf、protostuff 的比较与使用例子</a></p>
<h2 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.protostuff<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protostuff-runtime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.protostuff<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protostuff-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="继承父类方式"><a href="#继承父类方式" class="headerlink" title="继承父类方式"></a>继承父类方式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CanProto</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] toProto();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fromProto</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtoBase</span> <span class="keyword">implements</span> <span class="title">CanProto</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] toProto() &#123;</span><br><span class="line">        Schema schema = RuntimeSchema.getSchema(getClass());</span><br><span class="line">        <span class="keyword">return</span> ProtobufIOUtil.toByteArray(<span class="keyword">this</span>, schema, LinkedBuffer.allocate(<span class="number">256</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fromProto</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        Schema schema = RuntimeSchema.getSchema(getClass());</span><br><span class="line">        ProtobufIOUtil.mergeFrom(bytes, <span class="keyword">this</span>, schema);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方式可以使用Javabean继承ProtoBase类实现序列化。</p>
<h1 id="ProtostuffUtil工具类方式"><a href="#ProtostuffUtil工具类方式" class="headerlink" title="ProtostuffUtil工具类方式"></a>ProtostuffUtil工具类方式</h1><p>ProtostuffUtil.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.protostuff.LinkedBuffer;</span><br><span class="line"><span class="keyword">import</span> io.protostuff.ProtobufIOUtil;</span><br><span class="line"><span class="keyword">import</span> io.protostuff.ProtostuffIOUtil;</span><br><span class="line"><span class="keyword">import</span> io.protostuff.Schema;</span><br><span class="line"><span class="keyword">import</span> io.protostuff.runtime.RuntimeSchema;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtostuffUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtostuffUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">byte</span>[] serializer(T o) &#123;</span><br><span class="line">        Schema schema = RuntimeSchema.getSchema(o.getClass());</span><br><span class="line">        <span class="keyword">return</span> ProtobufIOUtil.toByteArray(o, schema, LinkedBuffer.allocate(<span class="number">256</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">deserializer</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        T obj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = clazz.newInstance();</span><br><span class="line">            Schema schema = RuntimeSchema.getSchema(obj.getClass());</span><br><span class="line">            ProtostuffIOUtil.mergeFrom(bytes, obj, schema);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试bean"><a href="#测试bean" class="headerlink" title="测试bean"></a>测试bean</h2><p>Student.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.protostuff.Tag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关于@Tag,要么所有属性都有@Tag注解,要么都没有,不能一个类中只有部分属性有@Tag注解</span></span><br><span class="line">    <span class="meta">@Tag(1)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Tag(2)</span></span><br><span class="line">    <span class="keyword">private</span> String studentNo;</span><br><span class="line">    <span class="meta">@Tag(3)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@Tag(4)</span></span><br><span class="line">    <span class="keyword">private</span> String schoolName;</span><br><span class="line">    <span class="meta">@Tag(5)</span></span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStudentNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> studentNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudentNo</span><span class="params">(String studentNo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.studentNo = studentNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSchoolName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> schoolName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSchoolName</span><span class="params">(String schoolName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.schoolName = schoolName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Gender <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(Gender gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, studentNo=&#x27;&quot;</span> + studentNo + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, schoolName=&#x27;&quot;</span> + schoolName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, gender=&quot;</span> + gender +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Gender</span> </span>&#123;</span><br><span class="line">    MAIL(<span class="number">1</span>, <span class="string">&quot;MAIL&quot;</span>),</span><br><span class="line">    FEMAIL(<span class="number">2</span>, <span class="string">&quot;FEMAIL&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> Integer order;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">    Gender(<span class="keyword">int</span> order, String gender) &#123;</span><br><span class="line">        <span class="keyword">this</span>.order = order;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Gender&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;order=&quot;</span> + order +</span><br><span class="line">                <span class="string">&quot;, gender=&#x27;&quot;</span> + gender + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="test类"><a href="#test类" class="headerlink" title="test类"></a>test类</h2><p>ProtostuffUtilTest.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtostuffUtilTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setName(<span class="string">&quot;rainbowhorse&quot;</span>);</span><br><span class="line">        student.setAge(<span class="number">24</span>);</span><br><span class="line">        student.setStudentNo(<span class="string">&quot;20112214010&quot;</span>);</span><br><span class="line">        student.setSchoolName(<span class="string">&quot;ZNMZDX&quot;</span>);</span><br><span class="line">        student.setGender(Gender.MAIL);</span><br><span class="line">        <span class="keyword">byte</span>[] serializerResult = ProtostuffUtil.serializer(student);</span><br><span class="line">        System.out.println(<span class="string">&quot;serializer result:&quot;</span> + Arrays.toString(serializerResult));</span><br><span class="line">        Student deSerializerResult = ProtostuffUtil.deserializer(serializerResult, Student.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;deSerializerResult:&quot;</span> + deSerializerResult.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serializer result:[<span class="number">10</span>, <span class="number">12</span>, <span class="number">114</span>, <span class="number">97</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">98</span>, <span class="number">111</span>, <span class="number">119</span>, <span class="number">104</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">115</span>, <span class="number">101</span>, <span class="number">18</span>, <span class="number">11</span>, <span class="number">50</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">49</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">49</span>, <span class="number">52</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">48</span>, <span class="number">24</span>, <span class="number">24</span>, <span class="number">34</span>, <span class="number">6</span>, <span class="number">90</span>, <span class="number">78</span>, <span class="number">77</span>, <span class="number">90</span>, <span class="number">68</span>, <span class="number">88</span>, <span class="number">40</span>, <span class="number">0</span>]</span><br><span class="line">deSerializerResult:Student&#123;name=<span class="string">&#x27;rainbowhorse&#x27;</span>, studentNo=<span class="string">&#x27;20112214010&#x27;</span>, age=<span class="number">24</span>, schoolName=<span class="string">&#x27;ZNMZDX&#x27;</span>, gender=Gender&#123;order=<span class="number">1</span>, gender=<span class="string">&#x27;MAIL&#x27;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>异步编程之ExecutorCompletionService</title>
    <url>/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B9%8BExecutorCompletionService/</url>
    <content><![CDATA[<p><a href="https://jdk6.net/util-concurrent/ExecutorCompletionService.html">ExecutorCompletionService</a>是JDK1. 6中新增的异步类，可获取异步执行的结果。有着相同功能的<code>ExcutorService</code>中<code>Future.get</code>方法是阻塞的直到返回结果，也就是顺序执行<code>get</code>方法，即使后续任务先执行完成也会阻塞在前面的任务的<code>get</code>方法。而<code>ExecutorCompletionService</code>执行结果无序且线程池中先执行完成的任务会先执行后续的逻辑，不会发生阻塞。<span id="more"></span></p>
<h2 id="异步任务获取结果方式"><a href="#异步任务获取结果方式" class="headerlink" title="异步任务获取结果方式"></a>异步任务获取结果方式</h2><p>多线程异步任务获取结果最常见的方式莫过于重写<code>Callable</code>接口，然后通过<code>future.get()</code>获取结果。但这种方法弊端很明显，<code>get</code>方法会产生阻塞，导致任务耗时增加。当前有三种方法可以实现异步任务获取结果：</p>
<ol>
<li>重写<code>Callable</code>，通过<code>future.get</code>获取结果。</li>
<li><code>CompletableFuture</code>异步通过<code>join</code>方法获取结果。</li>
<li>通过<code>ExecutorCompletionService</code>获取结果。</li>
</ol>
<h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化固定大小为3的线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ExecutorService EXECUTOR = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    method1();</span><br><span class="line">    <span class="comment">//method2();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Task&gt; tasks = getTasks();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (Future&lt;Integer&gt; future : EXECUTOR.invokeAll(tasks)) &#123;</span><br><span class="line">        Integer result = future.get();</span><br><span class="line">        <span class="comment">// 模拟其他业务逻辑</span></span><br><span class="line">        Uninterruptibles.sleepUninterruptibly(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        System.out.println(<span class="string">&quot;任务返回结果：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;共耗时：&quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    EXECUTOR.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Task&gt; tasks = getTasks();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    List&lt;Future&lt;Integer&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">        futures.add(EXECUTOR.submit(task));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历Future list，通过get()方法获取每个future结果</span></span><br><span class="line">    <span class="keyword">for</span> (Future&lt;Integer&gt; future : futures) &#123;</span><br><span class="line">        Integer result = future.get();</span><br><span class="line">        <span class="comment">// 模拟其他业务逻辑</span></span><br><span class="line">        Uninterruptibles.sleepUninterruptibly(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        System.out.println(<span class="string">&quot;任务返回结果：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;共耗时：&quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    EXECUTOR.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Task&gt; <span class="title">getTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Task&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    tasks.add(<span class="keyword">new</span> Task(<span class="number">5</span>));</span><br><span class="line">    tasks.add(<span class="keyword">new</span> Task(<span class="number">3</span>));</span><br><span class="line">    tasks.add(<span class="keyword">new</span> Task(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 秒级时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.time = time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Uninterruptibles.sleepUninterruptibly(time, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>method1</code>和<code>method2</code>执行结果相同，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">任务返回结果：5</span><br><span class="line">任务返回结果：3</span><br><span class="line">任务返回结果：1</span><br><span class="line">共耗时：8039</span><br></pre></td></tr></table></figure>

<p>为什么说<code>future.get()</code>阻塞获取结果，可以通过下图看出，只有等<strong>任务1</strong><code>get</code>到任务结果并执行完成后续所有业务逻辑后才会轮到下一个任务执行后续逻辑，且<code>get</code>方法按照提交顺序获取结果。总结为：<strong>先添加先处理</strong>。</p>
<div align=center><img width="600" height="400" src="../../../../images/2022/1-3/Callable.png" algin="center"/></div>

<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化固定大小为3的线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ExecutorService EXECUTOR = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    completableFuture();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">completableFuture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Task&gt; tasks = getTasks();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    tasks.parallelStream().map(task -&gt; CompletableFuture.supplyAsync(task::call, EXECUTOR))</span><br><span class="line">            .collect(Collectors.toList())</span><br><span class="line">            .parallelStream()</span><br><span class="line">            .map(CompletableFuture::join)</span><br><span class="line">            .forEach(result -&gt; &#123;</span><br><span class="line">                <span class="comment">// 模拟其他业务逻辑</span></span><br><span class="line">                Uninterruptibles.sleepUninterruptibly(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">                System.out.println(<span class="string">&quot;任务返回结果：&quot;</span> + result);</span><br><span class="line">            &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;共耗时：&quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    EXECUTOR.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Task&gt; <span class="title">getTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Task&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    tasks.add(<span class="keyword">new</span> Task(<span class="number">5</span>));</span><br><span class="line">    tasks.add(<span class="keyword">new</span> Task(<span class="number">3</span>));</span><br><span class="line">    tasks.add(<span class="keyword">new</span> Task(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 秒级时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.time = time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Uninterruptibles.sleepUninterruptibly(time, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">任务返回结果：1</span><br><span class="line">任务返回结果：3</span><br><span class="line">任务返回结果：5</span><br><span class="line">共耗时：6078</span><br></pre></td></tr></table></figure>

<p><code>CompletableFuture</code>把<code>Task.call</code>作为普通方法调用执行，将外层包装为<code>CompletableFuture.supplyAsync</code>获取结果。</p>
<h3 id="ExecutorCompletionService"><a href="#ExecutorCompletionService" class="headerlink" title="ExecutorCompletionService"></a>ExecutorCompletionService</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化固定大小为3的线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ExecutorService EXECUTOR = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    executorCompletionService();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executorCompletionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Task&gt; tasks = getTasks();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 以executor为构造器的参数，新建一个ExecutorCompletionService线程池</span></span><br><span class="line">    ExecutorCompletionService&lt;Integer&gt; completionService = <span class="keyword">new</span> ExecutorCompletionService&lt;&gt;(EXECUTOR);</span><br><span class="line">    <span class="comment">// 提交任务</span></span><br><span class="line">    <span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">        completionService.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">        Integer time = completionService.take().get();</span><br><span class="line">        <span class="comment">// 模拟其他业务逻辑</span></span><br><span class="line">        Uninterruptibles.sleepUninterruptibly(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        System.out.println(<span class="string">&quot;任务返回结果：&quot;</span> + time);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;共耗时：&quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    EXECUTOR.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Task&gt; <span class="title">getTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Task&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    tasks.add(<span class="keyword">new</span> Task(<span class="number">5</span>));</span><br><span class="line">    tasks.add(<span class="keyword">new</span> Task(<span class="number">3</span>));</span><br><span class="line">    tasks.add(<span class="keyword">new</span> Task(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 秒级时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.time = time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Uninterruptibles.sleepUninterruptibly(time, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">任务返回结果：<span class="number">1</span></span><br><span class="line">任务返回结果：<span class="number">3</span></span><br><span class="line">任务返回结果：<span class="number">5</span></span><br><span class="line">共耗时：<span class="number">6030</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>ExecutorCompletionService</code>比<code>Callable</code>在性能有一定提升。<code>ExecutorCompletionService</code>先执行完成线程会继续执行后续业务逻辑，并不会产生阻塞。总结为：<strong>谁快谁优先</strong>。</p>
<div align=center><img width="600" height="500" src="../../../../images/2022/1-3/ExecutorCompletionService.png" algin="center"/></div>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>获取异步线程执行结果性能排行</p>
<ol>
<li>ExecutorCompletionService</li>
<li>CompletableFuture</li>
<li>Callable</li>
</ol>
<h2 id="解析ExecutorCompletionService"><a href="#解析ExecutorCompletionService" class="headerlink" title="解析ExecutorCompletionService"></a>解析ExecutorCompletionService</h2><h3 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h3><p><code>ExecutorCompletionService</code>实现了<code>CompletionService</code>接口，且<code>CompletionService</code>只有<code>ExecutorCompletionService</code>一个实现类，<code>CompletionService</code>中只有5个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompletionService</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交一个Callable类型任务，并返回该任务执行结果关联的Future。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Future&lt;V&gt; <span class="title">submit</span><span class="params">(Callable&lt;V&gt; task)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交一个Runnable类型任务，并返回指定结果。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Future&lt;V&gt; <span class="title">submit</span><span class="params">(Runnable task, V result)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从内部阻塞队列中获取并移除第一个执行完成的任务，阻塞直到有任务完成。</span></span><br><span class="line"><span class="comment">     * 如果队列为空，那么调用take()方法的线程会被阻塞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Future&lt;V&gt; <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从内部阻塞队列中获取并移除第一个执行完成的任务，获取不到则返回null，不阻塞。</span></span><br><span class="line"><span class="comment">     * 如果队列为空，那么调用poll()方法的线程会返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Future&lt;V&gt; <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从内部阻塞队列中获取并移除第一个执行完成的任务，阻塞时间为timeout，获取不到则返回null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Future&lt;V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="三个私有属性"><a href="#三个私有属性" class="headerlink" title="三个私有属性"></a>三个私有属性</h4><div align=center><img src="../../../../images/2022/1-3/ecs.png" algin="center"/></div>

<h4 id="两个构造方法"><a href="#两个构造方法" class="headerlink" title="两个构造方法"></a>两个构造方法</h4><p>可通过<code>ExecutorCompletionService</code>的构造方法指定已完成队列的类型，默认为<code>LinkedBlockingQueue</code>。</p>
<div align=center><img src="../../../../images/2022/1-3/ecs2.png" algin="center"/></div>

<h4 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h4><p><code>QueueingFuture</code>继承了<code>FutureTask</code> ，<code>FutureTask</code>重写了<code>Runnable</code>的<code>run()</code>方法，无论是<code>set()</code>正常结果，还是<code>setException()</code>结果，都会调用 <code>finishCompletion()</code>方法。</p>
<div align=center><img src="../../../../images/2022/1-3/ecs3.png" algin="center"/></div>

<h4 id="任务执行流程"><a href="#任务执行流程" class="headerlink" title="任务执行流程"></a>任务执行流程</h4><div align=center><img src="../../../../images/2022/1-3/c1.png" algin="center"/></div>

<div align=center><img src="../../../../images/2022/1-3/c2.png" algin="center"/></div>

<div align=center><img src="../../../../images/2022/1-3/c3.png" algin="center"/></div>

<div align=center><img src="../../../../images/2022/1-3/c4.png" algin="center"/></div>

<div align=center><img src="../../../../images/2022/1-3/c5.png" algin="center"/></div>

<div align=center><img src="../../../../images/2022/1-3/c6.png" algin="center"/></div>

<div align=center><img src="../../../../images/2022/1-3/c7.png" algin="center"/></div>

<p>这里执行的<code>done</code>方法，实际执行的是<code>QueueingFuture</code>的<code>done</code>方法。至此，当一个任务执行完成或异常的时候，都会被添加到已完成阻塞队列中，进而被取出处理。</p>
<div align=center><img src="../../../../images/2022/1-3/c8.png" algin="center"/></div>

<h4 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h4><p><code>FutureTask</code>的任务完成后执行<code>QueueingFuture.done</code>将已完成的结果存储到队列中，可通过<code>take</code>、<code>poll</code>方法直接从已完成队列中获取结果。</p>
<div align=center><img src="../../../../images/2022/1-3/r1.png" algin="center"/></div>

<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>多线程执行有返回值的任务。</li>
<li>同类服务调用，优先获取先返回任务的结果(如调用不同厂商的定位服务，使用耗时最短、最先返回的结果)。</li>
<li>获取任务集合的第一个结果后取消其他任务(如多中心文件下载，下载完成后终止其他下载线程)。</li>
</ol>
<p><code>ExecutorCompletionService</code> doc中也给出了两个例子：</p>
<blockquote>
<p> 假设您有一组针对某个问题的求解器，每个求解器都返回某种Result类型的值，并希望同时运行它们，处理它们中每个返回非空值的结果，在某些方法中use(Result r) 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(Executor e,</span></span></span><br><span class="line"><span class="params"><span class="function">           Collection&lt;Callable&lt;Result&gt;&gt; solvers)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    CompletionService&lt;Result&gt; ecs</span><br><span class="line">        = <span class="keyword">new</span> ExecutorCompletionService&lt;Result&gt;(e);</span><br><span class="line">    <span class="keyword">for</span> (Callable&lt;Result&gt; s : solvers)</span><br><span class="line">        ecs.submit(s);</span><br><span class="line">    <span class="keyword">int</span> n = solvers.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        Result r = ecs.take().get();</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">            use(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>假设您想使用任务集的第一个非空结果，忽略任何遇到异常的结果，并在第一个任务准备好时取消所有其他任务。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(Executor e,</span></span></span><br><span class="line"><span class="params"><span class="function">            Collection&lt;Callable&lt;Result&gt;&gt; solvers)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     CompletionService&lt;Result&gt; ecs</span><br><span class="line">         = <span class="keyword">new</span> ExecutorCompletionService&lt;Result&gt;(e);</span><br><span class="line">     <span class="keyword">int</span> n = solvers.size();</span><br><span class="line">     List&lt;Future&lt;Result&gt;&gt; futures</span><br><span class="line">         = <span class="keyword">new</span> ArrayList&lt;Future&lt;Result&gt;&gt;(n);</span><br><span class="line">     Result result = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (Callable&lt;Result&gt; s : solvers)</span><br><span class="line">             futures.add(ecs.submit(s));</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 Result r = ecs.take().get();</span><br><span class="line">                 <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     result = r;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;&#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (Future&lt;Result&gt; f : futures)</span><br><span class="line">             f.cancel(<span class="keyword">true</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (result != <span class="keyword">null</span>)</span><br><span class="line">         use(result);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>微信公众号网页开发</title>
    <url>/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近一直参与公司开发公众号，关于项目实施平台PC端简化为微信公众号，主要架构为前台H5，使用时的微信的WeUI的SDK，后台就是现在流行的SpringMVC+Mybaties，参与了全程开发，开发过程中也遇到了不少的问题，现在记录下来，希望以后能够用得到。<div align=center><img width="700" height="300" src="../../../../images/2017-6-1/%E5%BE%AE%E4%BF%A1.jpg" algin="center"/></div><span id="more"></span></p>
<h1 id="HTML页面之间传值"><a href="#HTML页面之间传值" class="headerlink" title="HTML页面之间传值"></a>HTML页面之间传值</h1><p>JSP之间传值已经很熟悉，HTML之间传值是通过<code>解析URL</code>获取所需参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//URL传值</span></span><br><span class="line">URL + <span class="string">&quot;?logId=&quot;</span> + logId;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取所需参数</span></span><br><span class="line"><span class="keyword">var</span> hrefInfo = getUrlVars(<span class="built_in">window</span>.location.href);</span><br><span class="line">	<span class="keyword">if</span> (hrefInfo.logId &amp;&amp; hrefInfo.logId != <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">		fillData(hrefInfo.logId);</span><br><span class="line">		logId = hrefInfo.logId;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到url中的参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrlVars</span>(<span class="params">hrf</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> vars = [], hash;</span><br><span class="line">	<span class="keyword">var</span> locationHref = !hrf ? <span class="built_in">window</span>.location.href : hrf;</span><br><span class="line">	locationHref = locationHref.replace(<span class="regexp">/#/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (locationHref.indexOf(<span class="string">&#x27;%&#x27;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		locationHref = <span class="built_in">unescape</span>(locationHref);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> hashes = locationHref.slice(locationHref.indexOf(<span class="string">&#x27;?&#x27;</span>) + <span class="number">1</span>).split(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; hashes.length; i++) &#123;</span><br><span class="line">		hash = hashes[i].split(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">		vars.push(hash[<span class="number">0</span>]);</span><br><span class="line">		vars[hash[<span class="number">0</span>]] = hash[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> vars;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JS、JQuery获取各种屏幕的高度和宽度"><a href="#JS、JQuery获取各种屏幕的高度和宽度" class="headerlink" title="JS、JQuery获取各种屏幕的高度和宽度"></a>JS、JQuery获取各种屏幕的高度和宽度</h1><p>在移动端经常会用到获取屏幕的高度和宽度，在这里总结一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Javascript:</span><br><span class="line"><span class="built_in">document</span>.body.clientWidth				<span class="comment">//网页可见区域宽</span></span><br><span class="line"><span class="built_in">document</span>.body.clientHeight				<span class="comment">//网页可见区域高</span></span><br><span class="line"><span class="built_in">document</span>.body.offsetWidth (包括边线的宽)	<span class="comment">//网页可见区域宽</span></span><br><span class="line"><span class="built_in">document</span>.body.offsetHeight (包括边线的高)	<span class="comment">//网页可见区域高</span></span><br><span class="line"><span class="built_in">document</span>.body.scrollWidth				<span class="comment">//网页正文全文宽</span></span><br><span class="line"><span class="built_in">document</span>.body.scrollHeight				<span class="comment">//网页正文全文高</span></span><br><span class="line"><span class="built_in">document</span>.body.scrollTop					<span class="comment">//网页被卷去的高</span></span><br><span class="line"><span class="built_in">document</span>.body.scrollLeft				<span class="comment">//网页被卷去的左</span></span><br><span class="line"><span class="built_in">window</span>.screenTop					    <span class="comment">//网页正文部分上</span></span><br><span class="line"><span class="built_in">window</span>.screen.width						<span class="comment">//屏幕分辨率的宽</span></span><br><span class="line"><span class="built_in">window</span>.screen.availHeight				<span class="comment">//屏幕可用工作区高度</span></span><br><span class="line"><span class="built_in">window</span>.screen.availWidth				<span class="comment">//屏幕可用工作区宽度</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">JQuery:</span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert($(<span class="built_in">window</span>).height());				 <span class="comment">//浏览器当前窗口可视区域高度</span></span><br><span class="line">alert($(<span class="built_in">document</span>).height()); 			 <span class="comment">//浏览器当前窗口文档的高度</span></span><br><span class="line">alert($(<span class="built_in">document</span>.body).height());		 <span class="comment">//浏览器当前窗口文档body的高度</span></span><br><span class="line">alert($(<span class="built_in">document</span>.body).outerHeight(<span class="literal">true</span>));<span class="comment">//浏览器当前窗口文档body的总高度 包括border padding margin</span></span><br><span class="line"></span><br><span class="line">alert($(<span class="built_in">window</span>).width()); 				<span class="comment">//浏览器当前窗口可视区域宽度</span></span><br><span class="line">alert($(<span class="built_in">document</span>).width());				<span class="comment">//浏览器当前窗口文档对象宽度</span></span><br><span class="line">alert($(<span class="built_in">document</span>.body).width());		<span class="comment">//浏览器当前窗口文档body的宽度</span></span><br><span class="line">alert($(<span class="built_in">document</span>.body).outerWidth(<span class="literal">true</span>));<span class="comment">//浏览器当前窗口文档body的总宽度 包括border padding margin</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="微信浏览器缓存清理"><a href="#微信浏览器缓存清理" class="headerlink" title="微信浏览器缓存清理"></a>微信浏览器缓存清理</h1><p>微信浏览器缓存一直都是相当恶心的存在，只要页面加载，那么静态页面就会被缓存，通过Google和百度找到了以下两种方法：</p>
<h2 id="设置HTTP头部"><a href="#设置HTTP头部" class="headerlink" title="设置HTTP头部"></a>设置HTTP头部</h2><p>通过这只HTTP头部禁止浏览器缓存，效果没有达到要求，不建议使用</p>
<blockquote>
<p>Android下可在微信中打开<a href="http://debugx5.qq.com清除微信缓存./">http://debugx5.qq.com清除微信缓存。</a></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">&quot;IGNORE.manifest&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;pragma&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;cache-control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, user-scalable=no&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;shortcut icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../../view/images/favicon.ico&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">type</span>=<span class="string">&quot;image/x-icon&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="更新版本号"><a href="#更新版本号" class="headerlink" title="更新版本号"></a>更新版本号</h2><p>HTTP头部禁止缓存不能用，就只能每次都更新版本号(加随机数)来达到自己的要求了。</p>
<blockquote>
<p>使用<a href="http://yslove.net/seajs/"><code>SeaJs</code></a>拦截所有<code>.js</code>和<code>.css</code>并在尾部加上随机数。</p>
</blockquote>
<h3 id="引入SeaJs"><a href="#引入SeaJs" class="headerlink" title="引入SeaJs"></a>引入SeaJs</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../../util/sea.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置seajs-config-js"><a href="#配置seajs-config-js" class="headerlink" title="配置seajs_config.js"></a>配置seajs_config.js</h3><blockquote>
<p>需要配置seajs_config.js全局变量，每一个HTML页面都要引入，关于更多SeaJs配置<a href="http://yslove.net/seajs/">http://yslove.net/seajs/</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">var</span> sea_config = &#123;</span><br><span class="line">	<span class="string">&quot;base&quot;</span>:<span class="string">&quot;/&quot;</span>,				<span class="comment">//web发布路径</span></span><br><span class="line">	<span class="string">&quot;debug&quot;</span>:<span class="string">&quot;true&quot;</span>,				<span class="comment">//2:每次从后台获取新的js,true:console出bug,false:默认</span></span><br><span class="line">	<span class="string">&quot;charset&quot;</span>:<span class="string">&quot;utf-8&quot;</span>,								<span class="comment">//字符集</span></span><br><span class="line">	<span class="attr">preload</span>: [<span class="string">&quot;util/jquery-1.8.0.min.js&quot;</span>],	<span class="comment">//预加载jquery</span></span><br><span class="line">	<span class="attr">map</span>: [                                           <span class="comment">//配置映射，用来版本更新强制浏览器刷新</span></span><br><span class="line">        [<span class="string">&#x27;.js&#x27;</span>,<span class="string">&#x27;.js?version=&#x27;</span> + time],</span><br><span class="line">        [<span class="string">&#x27;.css&#x27;</span>,<span class="string">&#x27;.css?version=&#x27;</span> + time]</span><br><span class="line">	]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//HTML页面引入</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../../config/seaConfig/seajs_config.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">	seajs.config(sea_config);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Ajax请求缓存"><a href="#Ajax请求缓存" class="headerlink" title="Ajax请求缓存"></a>Ajax请求缓存</h2><blockquote>
<p>在编码期间，因为有个角色是查看所有项目且数据量也比较大，所以把Ajax请求方式从POST改为了GET，结果就发现Ajax请求被缓存，只有第一次查询有效，其后全部是从缓存中取，查询资料后才发现是POST改为GET引起的</p>
</blockquote>
<h4 id="解决方法一"><a href="#解决方法一" class="headerlink" title="解决方法一"></a>解决方法一</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ajax get请求时比较简单 只需将cache设置为false就好</span></span><br><span class="line">	$.ajax(&#123;  </span><br><span class="line">           <span class="attr">type</span>: <span class="string">&#x27;get&#x27;</span>,<span class="comment">//get请求时  </span></span><br><span class="line">           <span class="attr">url</span>: <span class="string">&#x27;........&#x27;</span>,  </span><br><span class="line">           <span class="attr">cache</span>: <span class="literal">false</span>,<span class="comment">//不缓存  </span></span><br><span class="line">           <span class="attr">data</span>: &#123; &#125;,  </span><br><span class="line">           <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;  </span><br><span class="line">                   </span><br><span class="line">            &#125;  </span><br><span class="line">	 &#125;);  </span><br></pre></td></tr></table></figure>

<h4 id="解决方法二"><a href="#解决方法二" class="headerlink" title="解决方法二"></a>解决方法二</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">访问就在URL后面加上[总之就是使每次访问的URL字符串不一样的]</span><br><span class="line">URL?+<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">设计WEB页面的时候 也应该遵守这个原则</span><br><span class="line">因为请求同一个地址会直接读取缓存，所以可以在参数中加一个随机数数 让每次参数不一样就好</span><br></pre></td></tr></table></figure>

<h1 id="IOS下Iframe滚动问题"><a href="#IOS下Iframe滚动问题" class="headerlink" title="IOS下Iframe滚动问题"></a>IOS下Iframe滚动问题</h1><blockquote>
<p>移动端在IOS下的问题居多，后来测试组测出的bug多数属于在IOS下属性不兼容问题，其中就有IOS下Iframe里面页面无法滚动，解决方法如下</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-cn&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>IOS frame 滚动条 demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-id">#wrapper</span>&#123;<span class="attribute">height</span>:<span class="number">500px</span>;-webkit-<span class="attribute">overflow</span>-scrolling:touch;<span class="attribute">overflow</span>:auto;&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">   	 我是一堆很长。很长，很高，很高的内容。</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> UA = navigator.userAgent;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> forIOS = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(!UA.match(<span class="regexp">/iPad/</span>) &amp;&amp; !UA.match(<span class="regexp">/iPhone/</span>) &amp;&amp; !UA.match(<span class="regexp">/iPod/</span>))&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>($(<span class="string">&#x27;#wrapper&#x27;</span>).length)&#123;<span class="keyword">return</span>;&#125;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">&#x27;body&#x27;</span>).children().not(<span class="string">&#x27;script&#x27;</span>).wrapAll(<span class="string">&#x27;&lt;div id=&quot;wrapper&quot;&gt;&lt;/div&gt;&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次是我第一次开发微信端，从前端的不熟悉到熟练，自己成长了许多。同时遇到了很多问题，尤其是在IOS下的兼容问题，比如还有像IOS下fixed属性不能用等问题。很多东西只有自己摸索才知道，这次也算是让自己在全栈工程师的道路上又进了一步。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务架构设计</title>
    <url>/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="微服务架构详解"><a href="#微服务架构详解" class="headerlink" title="微服务架构详解"></a><a href="https://www.mubucm.com/doc/sUZSGEXM8p">微服务架构详解</a></h1><h2 id="微服务VS-SOA"><a href="#微服务VS-SOA" class="headerlink" title="微服务VS SOA"></a>微服务VS SOA</h2><div align=center><img src="../../../../images/2022/1-3/6.1_compare.jpg" algin="center"/></div>

<div align=center><img src="../../../../images/2022/1-3/6.1_microservices_explain.png" algin="center"/></div>

<h1 id="微服务架构陷阱与挑战"><a href="#微服务架构陷阱与挑战" class="headerlink" title="微服务架构陷阱与挑战"></a><a href="https://www.mubucm.com/doc/6vSvOzAm8p">微服务架构陷阱与挑战</a></h1><h2 id="六大陷阱"><a href="#六大陷阱" class="headerlink" title="六大陷阱"></a>六大陷阱</h2><h3 id="拆分颗粒度太细"><a href="#拆分颗粒度太细" class="headerlink" title="拆分颗粒度太细"></a>拆分颗粒度太细</h3><ul>
<li>服务关系复杂</li>
<li>团队效率下降</li>
<li>问题定位困难</li>
<li>系统性能下降</li>
</ul>
<h3 id="基础设施不完善"><a href="#基础设施不完善" class="headerlink" title="基础设施不完善"></a>基础设施不完善</h3><ul>
<li>无法快速交付</li>
<li>服务管理混乱</li>
</ul>
<h2 id="四大挑战"><a href="#四大挑战" class="headerlink" title="四大挑战"></a>四大挑战</h2><ul>
<li>分布式事务</li>
<li>全局幂等</li>
<li>接口兼容</li>
<li>接口循环调用</li>
</ul>
<div align=center><img src="../../../../images/2022/1-3/6.2_microservices_trap.png" algin="center"/></div>

<h1 id="微服务基础设施选型"><a href="#微服务基础设施选型" class="headerlink" title="微服务基础设施选型"></a><a href="https://www.mubucm.com/doc/3e_BIoLJb8p">微服务基础设施选型</a></h1><blockquote>
<p>核心为服务运行层：服务注册、服务发现、服务路由</p>
</blockquote>
<ol>
<li>嵌入SDK式</li>
<li>反向代理式</li>
<li>网络代理式</li>
</ol>
<div align=center><img src="../../../../images/2022/1-3/6.3_microservices_infrastructure.png" algin="center"/></div>

<h1 id="微服务拆分技巧"><a href="#微服务拆分技巧" class="headerlink" title="微服务拆分技巧"></a><a href="https://www.mubucm.com/doc/6ZUT_H_mgsp">微服务拆分技巧</a></h1><h2 id="按业务拆分"><a href="#按业务拆分" class="headerlink" title="按业务拆分"></a>按业务拆分</h2><ul>
<li>业务边界划分</li>
<li>三个火枪手原则</li>
</ul>
<blockquote>
<p>【定义】 平均3个开发人员负责一个微服务。 </p>
<p>【剖析】</p>
<ol>
<li><p>为什么不是1个？ </p>
<ul>
<li>因为没有备份，且一个人思维有局限。 </li>
</ul>
</li>
<li><p>为什么不是2个？ </p>
<ul>
<li>因为异常情况下剩余1个，压力会很大；</li>
<li>2个人负责维护一个微服务，微服务复杂度偏低。 </li>
</ul>
</li>
<li><p>为什么不是4个或者5个？ 如果4个或4个以上，每个人不一定能掌握单个服务所有细节。 </p>
</li>
</ol>
<p>【技巧】 </p>
<ol>
<li> 微服务数量 = 服务端开发人数 /3 ； </li>
<li>3 = 1 +2，1个有经验的(P7/P6+)，2个普通的(P5/P6)； </li>
<li>处于维护期的服务，维护人员为2人。</li>
</ol>
</blockquote>
<h2 id="按质量拆分"><a href="#按质量拆分" class="headerlink" title="按质量拆分"></a>按质量拆分</h2><ol>
<li>按性能拆分</li>
<li>按业务重要程度拆分</li>
<li>按可用性拆分</li>
<li>按稳定性拆分</li>
</ol>
<div align=center><img src="../../../../images/2022/1-3/6.4_microservices_split_skill.png" algin="center"/></div>

<h1 id="中台深入剖析和实现技巧"><a href="#中台深入剖析和实现技巧" class="headerlink" title="中台深入剖析和实现技巧"></a><a href="https://www.mubucm.com/doc/23SU0UiPksp">中台深入剖析和实现技巧</a></h1><h2 id="共享类别"><a href="#共享类别" class="headerlink" title="共享类别"></a>共享类别</h2><ol>
<li>无共享，烟囱模型</li>
<li>Iaas，共享基础设施</li>
<li>PaaS，共享平台能力</li>
<li>SaaS，共享软件能力</li>
<li>中台，共享业务能力</li>
</ol>
<div align=center><img src="../../../../images/2022/1-3/6.5_middle_stage.png" algin="center"/></div>
]]></content>
      <categories>
        <category>架构</category>
        <category>设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库主从不一致</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E4%BB%8E%E4%B8%8D%E4%B8%80%E8%87%B4/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在开发过程中，进场遇到数据库主从分离来降低读写的压力，但是数据库主从同步是有延时的，这里聊一聊数据库主库与从库的一致性问题。<div align=center><img width="700" height="300" src="../../../../images/2018-7/%E4%B8%BB%E4%BB%8E%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/index.png" algin="center"/></p>
</div><span id="more"></span>

<h1 id="常见的数据库集群架构"><a href="#常见的数据库集群架构" class="headerlink" title="常见的数据库集群架构"></a>常见的数据库集群架构</h1><p><strong>一主多从，主从同步，读写分离</strong></p>
<div align=center><img width="1000" height="300" src="../../../../images/2018-7/%E4%B8%BB%E4%BB%8E%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/1.png" algin="center"/></div>

<p>如上图所示</p>
<ul>
<li>一个主库提供写服务</li>
<li>多个从库提供读服务，可以增加从库提升读性能</li>
<li>主从之间同步</li>
</ul>
<blockquote>
<p>任何方案不要忘了本心，增加从库的本心是提升读性能</p>
</blockquote>
<h1 id="为什么会出现不一致"><a href="#为什么会出现不一致" class="headerlink" title="为什么会出现不一致"></a>为什么会出现不一致</h1><p><strong>主从同步有时延</strong>，这个时延期间读从库，可能读到不一致的数据。</p>
<div align=center><img width="1000" height="300" src="../../../../images/2018-7/%E4%B8%BB%E4%BB%8E%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/2.png" algin="center"/></div>

<p>如上图</p>
<ol>
<li>服务发齐了一个写请求</li>
<li>服务又发起了一个读请求，此时同步未完成，读到一个不一致的脏数据</li>
<li>数据库主从同步最后才完成</li>
</ol>
<blockquote>
<p>任何数据冗余，必将引发一致性问题。</p>
</blockquote>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="忽略"><a href="#忽略" class="headerlink" title="忽略"></a>忽略</h2><p>任何脱离业务的架构设计都是耍流氓，绝大部分业务，例如：百度搜索，淘宝订单，QQ消息，58帖子都允许短时间不一致。</p>
<blockquote>
<p>如果业务能接受，最推崇此法。</p>
</blockquote>
<p><strong>如果业务能够接受，别把系统架构搞得太复杂。</strong></p>
<h2 id="强制读主"><a href="#强制读主" class="headerlink" title="强制读主"></a>强制读主</h2><div align=center><img width="1000" height="300" src="../../../../images/2018-7/%E4%B8%BB%E4%BB%8E%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/3.png" algin="center"/></div>

<p>如上图</p>
<ol>
<li>使用一个<strong>高可用主库</strong>提供数据库服务</li>
<li>读和写都落到主库上</li>
<li>采用<strong>缓存来提升系统读性能</strong></li>
</ol>
<p>这是很常见的微服务架构，可以避免数据库主从一致性问题。</p>
<h2 id="选择性读主"><a href="#选择性读主" class="headerlink" title="选择性读主"></a>选择性读主</h2><p>强制读主过于粗暴，毕竟只有少量写请求，很短时间，可能读取到脏数据。</p>
<p>有没有可能实现，<strong>只有这一段时间，可能读到从库脏数据的读请求读主</strong>，平时读从呢？</p>
<p>可以利用一个缓存记录必须读主的数据。</p>
<div align=center><img width="1000" height="300" src="../../../../images/2018-7/%E4%B8%BB%E4%BB%8E%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/4.png" algin="center"/></div>

<p>如上图，当写请求发生时：</p>
<ol>
<li>写主库</li>
<li>将哪个库，哪个表，哪个主键三个信息拼装一个key设置到cache里，这条记录的超时时间，设置为“主从同步时延”</li>
</ol>
<blockquote>
<p>key的格式为“db:table:PK”，假设主从延时为1s，这个key的cache超时时间也为1s。</p>
</blockquote>
<div align=center><img width="1000" height="300" src="../../../../images/2018-7/%E4%B8%BB%E4%BB%8E%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/5.png" algin="center"/></div>

<p>如上图，当读请求发生时：</p>
<p>这是要读哪个库，哪个表，哪个主键的数据呢，也将这三个信息拼装一个key，到cache里去查询，如果：</p>
<ol>
<li><strong>cache里有这个key</strong>，说明1s内刚发生过写请求，数据库主从同步可能还没有完成，此时就应该<strong>去主库查询</strong>。</li>
<li><strong>cache里没有这个key</strong>，说明最近没有发生过写请求，此时就可以<strong>去从库查询</strong>。</li>
</ol>
<p>以此，保证读到的一定不是不一致的脏数据。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>数据库主库和从库不一致，常见有这么几种优化方案：</p>
<ol>
<li>业务可以接受，系统不优化；</li>
<li>强制读主，高可用主库，用缓存提高读性能；</li>
<li>在cache里记录哪些记录发生过写请求，来路由读主还是读从。</li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库存储架构</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a><a href="https://www.mubucm.com/doc/7AIBq2zliyp">数据库读写分离</a></h1><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><h3 id="复制延迟"><a href="#复制延迟" class="headerlink" title="复制延迟"></a>复制延迟</h3><ul>
<li>业务分级(常用)</li>
<li>读写绑定</li>
<li>二次读取</li>
</ul>
<h3 id="任务分解"><a href="#任务分解" class="headerlink" title="任务分解"></a>任务分解</h3><ul>
<li>代码封装</li>
<li>中间件封装</li>
</ul>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="垂直拆分-提升单机处理性能"><a href="#垂直拆分-提升单机处理性能" class="headerlink" title="垂直拆分-提升单机处理性能"></a>垂直拆分-提升单机处理性能</h3><p>按照业务将表进行分类，分布到不同的数据库上面。</p>
<h3 id="水平拆分-提升集群处理性能"><a href="#水平拆分-提升集群处理性能" class="headerlink" title="水平拆分-提升集群处理性能"></a>水平拆分-提升集群处理性能</h3><p>按行切分。</p>
<div align=center><img src="../../../../images/2022/1-3/5.1_read_write_separation.png" algin="center"/></div>

<h1 id="复制架构"><a href="#复制架构" class="headerlink" title="复制架构"></a><a href="https://www.mubucm.com/doc/1aWx1Mz0kyp">复制架构</a></h1><div align=center><img src="../../../../images/2022/1-3/5.2_replication_architecture.png" algin="center"/></div>

<h1 id="设计存储架构"><a href="#设计存储架构" class="headerlink" title="设计存储架构"></a><a href="https://www.mubucm.com/doc/6UM1pxcB0yp">设计存储架构</a></h1><div align=center><img src="../../../../images/2022/1-3/4.3_storage_architecture.png" algin="center"/></div>

<h1 id="分片架构与分区架构"><a href="#分片架构与分区架构" class="headerlink" title="分片架构与分区架构"></a><a href="https://www.mubucm.com/doc/6WWOoWYW1Op">分片架构与分区架构</a></h1><h2 id="分片架构"><a href="#分片架构" class="headerlink" title="分片架构"></a>分片架构</h2><p>通过叠加服务器来提升写性能和存储性能。</p>
<h2 id="分区架构"><a href="#分区架构" class="headerlink" title="分区架构"></a>分区架构</h2><p>通过冗余IDC来避免城市级别的灾难，并提供就近访问。</p>
<div align=center><img src="../../../../images/2022/1-3/4.4_arch_partition.png" algin="center"/></div>

<h1 id="常见存储系统剖析"><a href="#常见存储系统剖析" class="headerlink" title="常见存储系统剖析"></a><a href="https://www.mubucm.com/doc/DA7rkshVOp">常见存储系统剖析</a></h1><h2 id="存储系统学习方法"><a href="#存储系统学习方法" class="headerlink" title="存储系统学习方法"></a>存储系统学习方法</h2><ul>
<li>理解技术本质</li>
<li>明确部署架构</li>
<li>研究数据模型</li>
<li>模拟业务场景</li>
</ul>
<div align=center><img src="../../../../images/2022/1-3/5.5_common_storage_systems.png" algin="center"/></div>
]]></content>
      <categories>
        <category>架构</category>
        <category>设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>架构设计关键点</title>
    <url>/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%85%B3%E9%94%AE%E7%82%B9/</url>
    <content><![CDATA[<h1 id="可扩展架构设计"><a href="#可扩展架构设计" class="headerlink" title="可扩展架构设计"></a><a href="https://www.mubucm.com/doc/20UOciBOxQp">可扩展架构设计</a></h1><h2 id="鸡蛋篮子第一法则"><a href="#鸡蛋篮子第一法则" class="headerlink" title="鸡蛋篮子第一法则"></a>鸡蛋篮子第一法则</h2><mark class="hl-label red">拆分法则</mark> 

<h2 id="拆分颗粒度"><a href="#拆分颗粒度" class="headerlink" title="拆分颗粒度"></a>拆分颗粒度</h2><h3 id="内部复杂度"><a href="#内部复杂度" class="headerlink" title="内部复杂度"></a>内部复杂度</h3><p>可以用参与的开发人数来衡量单个拆分对象的复杂度。三个火枪手原则。</p>
<h3 id="外部复杂度"><a href="#外部复杂度" class="headerlink" title="外部复杂度"></a>外部复杂度</h3><p>可以用业务流程涉及对象数量来衡量外部复杂度。</p>
<div align=center><img src="../../../../images/2022/1-3/2.1_arch_extensible.png" algin="center"/></div>

<h1 id="高性能架构设计"><a href="#高性能架构设计" class="headerlink" title="高性能架构设计"></a><a href="https://www.mubucm.com/doc/1DQPj3hYUQp">高性能架构设计</a></h1><h2 id="鸡蛋篮子第二法则"><a href="#鸡蛋篮子第二法则" class="headerlink" title="鸡蛋篮子第二法则"></a>鸡蛋篮子第二法则</h2><mark class="hl-label red">叠加法则</mark> 

<div align=center><img src="../../../../images/2022/1-3/2.2_arch_performance.png" algin="center"/></div>

<h1 id="高可用架构设计"><a href="#高可用架构设计" class="headerlink" title="高可用架构设计"></a><a href="https://www.mubucm.com/doc/5Sp9csIFdQp">高可用架构设计</a></h1><h2 id="鸡蛋篮子第三法则"><a href="#鸡蛋篮子第三法则" class="headerlink" title="鸡蛋篮子第三法则"></a>鸡蛋篮子第三法则</h2><mark class="hl-label red">冗余法则</mark> 

<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li><p>计算高可用</p>
</li>
<li><p>存储高可用</p>
</li>
</ul>
<div align=center><img src="../../../../images/2022/1-3/2.3_arch_available.png" algin="center"/></div>



<h1 id="架构质量"><a href="#架构质量" class="headerlink" title="架构质量"></a><a href="https://www.mubucm.com/doc/1NkA7lrKl4p">架构质量</a></h1><h2 id="可测试性"><a href="#可测试性" class="headerlink" title="可测试性"></a>可测试性</h2><p>软件系统在测试环境下能否方便的支持测试各种场景的能力。</p>
<h2 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h2><p>软件系统支持定位问题、修复问题的能力。</p>
<h2 id="可观测性"><a href="#可观测性" class="headerlink" title="可观测性"></a>可观测性</h2><p>软件系统对外展现内部状态的能力 <strong>可观测性是可测试性、可维护性的基础</strong>。</p>
<div align=center><img src="../../../../images/2022/1-3/2.4_arch_quality.png" algin="center"/></div>
]]></content>
      <categories>
        <category>架构</category>
        <category>设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>架构设计及概念</title>
    <url>/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8F%8A%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="架构定义"><a href="#架构定义" class="headerlink" title="架构定义"></a><a href="https://www.mubucm.com/doc/Kh30n3bevp">架构定义</a></h1><h2 id="系统拆分"><a href="#系统拆分" class="headerlink" title="系统拆分"></a>系统拆分</h2><ul>
<li>按<strong>逻辑</strong>拆分：模块</li>
<li>按<strong>物理</strong>拆分：组件</li>
</ul>
<h2 id="4R架构定义"><a href="#4R架构定义" class="headerlink" title="4R架构定义"></a>4R架构定义</h2><ul>
<li><strong>Rank</strong>：顶层架构</li>
<li><strong>Role</strong>：角色组成</li>
<li><strong>Relation</strong>：角色关系</li>
<li><strong>Rule</strong>：运作规则</li>
</ul>
<div align=center><img src="../../../../images/2022/1-3/1.1_arch_definition.png" algin="center"/></div>

<h1 id="架构分类"><a href="#架构分类" class="headerlink" title="架构分类"></a><a href="https://www.mubucm.com/doc/6mSpcn-gt7p">架构分类</a></h1><h2 id="按业务划分"><a href="#按业务划分" class="headerlink" title="按业务划分"></a>按业务划分</h2><ul>
<li>业务架构图</li>
</ul>
<h2 id="按领域划分"><a href="#按领域划分" class="headerlink" title="按领域划分"></a>按领域划分</h2><ul>
<li>客户端架构图</li>
<li>前端架构图</li>
<li>后端架构图</li>
</ul>
<div align=center><img src="../../../../images/2022/1-3/1.2_arch_classify.png" algin="center"/></div>

<h1 id="面向复杂度的架构分析"><a href="#面向复杂度的架构分析" class="headerlink" title="面向复杂度的架构分析"></a><a href="https://www.mubucm.com/doc/3iP82kZ-tnp">面向复杂度的架构分析</a></h1><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>架构设计是为了降低软件系统的复杂度。</p>
<div align=center><img src="../../../../images/2022/1-3/1.3_arch_complexity.png" algin="center"/></div>

<h1 id="架构设计三原则"><a href="#架构设计三原则" class="headerlink" title="架构设计三原则"></a><a href="https://www.mubucm.com/doc/2sOoT5Jcknp">架构设计三原则</a></h1><h2 id="合适原则"><a href="#合适原则" class="headerlink" title="合适原则"></a>合适原则</h2><p>合适优于业界领先。</p>
<h2 id="简单原则"><a href="#简单原则" class="headerlink" title="简单原则"></a>简单原则</h2><p>简单优于复杂。</p>
<h2 id="演进原则"><a href="#演进原则" class="headerlink" title="演进原则"></a>演进原则</h2><p>演化优于一步到位。</p>
<div align=center><img src="../../../../images/2022/1-3/1.4_arch_principle.png" algin="center"/></div>

]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈共享单车</title>
    <url>/%E6%B5%85%E8%B0%88%E5%85%B1%E4%BA%AB%E5%8D%95%E8%BD%A6/</url>
    <content><![CDATA[<p>​    要说目前最火爆的互联网现象，当属<code>共享单车</code>。这里所谓的共享，本质上指的是需求共享。就骑车的需求，从一个地方骑到另一个地方，就是用户触点（产品投放）、产品操作（骑行过程）、付费模式（支付）的流程，从个体上来讲，这个流程是单向的。但在“共享”的模式下，扫码骑走，停车即走，把不同的人，在不同的时间和地点，相同的骑行需求，通过产品操作节点，形成需求闭环，停车点同时又是骑行出发点，这就是需求共享。</p>
<div align=center><img width="600" height="280" src="../../../../images/2017-3-24/cover.jpg" algin="center"/></div>

<span id="more"></span>

<blockquote>
<p>共享单车是指企业与政府合作，在地铁、学校、公交站点、居民区、商业区、公共服务区等提供自行车单车共享服务，是共享经济的一种新形态。</p>
</blockquote>
<p>​    2016年底以来，国内共享单车突然就火爆了起来，而在街头，仿佛一夜之间，共享单车已经到了“泛滥”的地步，各大城市路边排满各种颜色的共享单车。</p>
<h2 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h2><p>​    我们站在用户角度，无非就是找车，然后骑车，交钱。</p>
<p><img src="../../../../images/2017-3-24/%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90.jpg" alt="场景分析"></p>
<p>在“<code>寻车-用车-骑车-还车</code>”的场景闭环中，需要考虑的问题有很多，列举以下若干种：</p>
<ul>
<li>什么样的寻车方式更符合大众的日常行为？</li>
</ul>
<ul>
<li>用户与单车之间如何建立一一对应的联系？</li>
</ul>
<ul>
<li>使用何种开锁构件实现远程开锁和上锁？</li>
</ul>
<ul>
<li>计费方式及费用节点、价格、操作流程分别采取什么方案？</li>
</ul>
<ul>
<li>如何对车辆进行远程管理？</li>
</ul>
<ul>
<li>如何防止逃费、盗窃、破坏等衍生问题？</li>
</ul>
<p>场景分析的过程，就是解决以上若干问题的过程，针对这些问题，分别提出不同的业务流程和技术方案。</p>
<h2 id="业务逻辑分析"><a href="#业务逻辑分析" class="headerlink" title="业务逻辑分析"></a>业务逻辑分析</h2><p>以<code>摩拜单车</code>为例，用户-管理平台-单车 之间的关系如下图:</p>
<p><img src="../../../../images/2017-3-24/%E6%B5%81%E7%A8%8B.jpg" alt="流程"></p>
<h2 id="技术实现方案"><a href="#技术实现方案" class="headerlink" title="技术实现方案"></a>技术实现方案</h2><p>​    现在共享单车最火的要数*<a href="http://mobike.com/cn/">摩拜单车</a><em>和</em><a href="http://www.ofo.so/?utm_source=baidu&utm_medium=pz">OFO小黄车</a>*了，摩拜采用<strong>智能锁</strong>而ofo采用的是<strong>机械锁</strong>。</p>
<h3 id="1-机械锁"><a href="#1-机械锁" class="headerlink" title="1  机械锁"></a>1  机械锁</h3><p>​    原理：机械锁的原理很简单，只需要打开软件，输入对应的车牌号就可以了，其实就是后台查询数据库，判断单车是否处于正常状态，返回给用户开锁密码，用户拿着开锁密码开锁。</p>
<p><img src="../../../../images/2017-3-24/ofo%E5%8E%9F%E7%90%86.jpg" alt="机械锁"></p>
<h3 id="2-智能锁"><a href="#2-智能锁" class="headerlink" title="2  智能锁"></a>2  智能锁</h3><p>​    原理：对于单车的远程开锁机制，采用远程通信控制机械构件的电磁运动来实现。远程通信可采用传统的SIM卡通信的方式。</p>
<p>一、手机扫描自行车，获得自行车唯一的ID标志，手机接着会像服务器提交一个请求（提交信息里包含：用户信息，请求动作，车辆ID）；<br>二、服务器收到用户开锁请求，此时会根据请求信息，接着向指定ID的自行车发出开锁指令;<br>三、自行车收到服务器请求，会执行相应的开锁动作。</p>
<p><em>智能锁是耗费电能的，所以摩拜单车车篮中装有太阳能电池板，减少人力物力维护的成本、简单、高效。</em></p>
<p><img src="../../../../images/2017-3-24/mobike%E5%8E%9F%E7%90%86.png" alt="mobike原理"></p>
<p>​    这是一个典型的大容量互联网O2O场景，连结用户、车辆，管理平台进行实时处理效率要求非常高，需制定可靠、高效的网络方案。根据业务流程，我们梳理出网络节点的职能，并从成本考虑使用最优方案：<img src="../../../../images/2017-3-24/%E6%96%B9%E6%A1%88.jpg" alt="方案"></p>
<p>​    明确流程，界面，那么接下来的任务就是通过用户语言去实现产品流程了，即界面设计与开发实现，这里我们就不阐述了。</p>
<h2 id="一点感想"><a href="#一点感想" class="headerlink" title="一点感想"></a>一点感想</h2><p>​    从2016年到现在已有近半年时间，共享单车的竞争也愈演愈烈，近几天，共享单车从免费到红包“撒钱” 导致竞争升级，共享单车方便了我们的出行，但是带来的问题也很多，政府也在不断的规范使用。现在都在处于资本投入和烧钱大战中，希望共享单车一直存活下去，同时希望大家能合理、合法使用。</p>
<blockquote>
<p>之前有听说过摩拜的扫一扫可以远程使用，假如我需要车又没有注册，我可以拍照给有车的朋友，让他们帮我远程扫就可以开启，<strong>亲测</strong>：不行！还是自己乖乖注册一个吧。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈设计文档</title>
    <url>/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>经常听到调侃程序员的一句话”程序员最烦写文档，也最烦别人不写文档”。文档在项目开发中非常重要，首先是自己对产品和设计要非常熟悉才能写出一篇好的设计文档，其次文档可以让别人快速理解技术架构，快速上手。这里总结下自己这几年写<strong>概要设计文档</strong>的经验。<div align=center><img src="../../../../images/2019/4-6/design-0.jpg" algin="center"/></div><span id="more"></span></p>
<h1 id="产品文档"><a href="#产品文档" class="headerlink" title="产品文档"></a>产品文档</h1><p>产品文档虽然是产品经理编写，但是我们还是要去了解其中详细的信息，尤其是开发背景和整体原型。这样才能开发出符合产品设计的产品。</p>
<h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><p>记录开发及测试环境的数据库用户名/密码，部署的服务信息及服务部署的主机信息。生产环境的主机信息等。</p>
<h1 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h1><p>技术架构也可设计为整理模型，说明的是后台技术大的框架。</p>
<blockquote>
<p>模块设计，可以写以下内容：    </p>
<p>1、模块描述：说明哪些模块实现了哪些功能；    </p>
<p>2、模块层次结构：可以使用某个视角的软件框架图来表达；    </p>
<p>3、模块间的关系：模块间依赖关系的描述，通信机制描述；</p>
<p> 4、模块的核心接口：说明模块传递的信息、信息的结构；</p>
<p>5、处理方式设计：说一些满足功能和性能的算法。</p>
</blockquote>
<p>下面是个简单的例子：</p>
<div align=center><img src="../../../../images/2019/4-6/design-3.jpg" algin="center"/></div>

<h1 id="整体流程图"><a href="#整体流程图" class="headerlink" title="整体流程图"></a>整体流程图</h1><p> 描述的是整个流程时序图，当然可附带些描述性文字</p>
<div align=center><img src="../../../../images/2019/4-6/design-2.png" algin="center"/></div>

<h1 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h1><p>实体-联系图，描述实体类型、属性和联系的方法。在表设计中也有体现。</p>
<h1 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h1><p>描述请求详细流程的时序图。</p>
<h1 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h1><p>将设计的数据库文档及语句记录下来。描述每个字段的含义，可包含<em>字段、类型、Enum、描述、备注</em>列，将设计的SQL文件上传，有更新时需及时更新。</p>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>将用到的缓存设计记录下来，无论是jvmCache还是中间件。</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>前后端的接口文档，可链接到接口文档页面。</p>
<h1 id="压测报告"><a href="#压测报告" class="headerlink" title="压测报告"></a>压测报告</h1><p>针对该功能的压测报告。</p>
<h1 id="特殊点及疑问点"><a href="#特殊点及疑问点" class="headerlink" title="特殊点及疑问点"></a>特殊点及疑问点</h1><p> 将有问题的点记录，后续解决。</p>
<h1 id="迭代记录"><a href="#迭代记录" class="headerlink" title="迭代记录"></a>迭代记录</h1><p>记录每次迭代的新增功能或修改记录。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>离线安装docker与docker-compose</title>
    <url>/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker%E4%B8%8Edocker-compose/</url>
    <content><![CDATA[<p>在线安装<code>docker</code>官方详细教程：<a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p>
<p>在线安装<code>docker-compose</code>官方详细教程：<a href="https://docs.docker.com/compose/install/#install-compose">https://docs.docker.com/compose/install/#install-compose</a> <span id="more"></span></p>
<h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><p>官方离线安装包下载地址：<a href="https://download.docker.com/linux/static/stable/x86_64/">https://download.docker.com/linux/static/stable/x86_64/</a></p>
<p>目前最新版本为：<code>docker-18.06.3-ce.tgz</code> </p>
<h2 id="脚本准备"><a href="#脚本准备" class="headerlink" title="脚本准备"></a>脚本准备</h2><h3 id="docker-service"><a href="#docker-service" class="headerlink" title="docker.service"></a>docker.service</h3><blockquote>
<p>作用：安装和卸载docker脚本需要用到此脚本</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">Documentation=https://docs.docker.com</span><br><span class="line">After=network-online.target firewalld.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line"># the default is not to use systemd for cgroups because the delegate issues still</span><br><span class="line"># exists and systemd currently does not support the cgroup feature set required</span><br><span class="line"># for containers run by docker</span><br><span class="line">ExecStart=/usr/bin/dockerd</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line"># Having non-zero Limit*s causes performance problems due to accounting overhead</span><br><span class="line"># in the kernel. We recommend using cgroups to do container-local accounting.</span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line"># Uncomment TasksMax if your systemd version supports it.</span><br><span class="line"># Only systemd 226 and above support this version.</span><br><span class="line">#TasksMax=infinity</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line"># set delegate yes so that systemd does not reset the cgroups of docker containers</span><br><span class="line">Delegate=yes</span><br><span class="line"># kill only the docker process, not all processes in the cgroup</span><br><span class="line">KillMode=process</span><br><span class="line"># restart the docker process if it exits prematurely</span><br><span class="line">Restart=on-failure</span><br><span class="line">StartLimitBurst=3</span><br><span class="line">StartLimitInterval=60s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<h3 id="安装脚本-install-sh"><a href="#安装脚本-install-sh" class="headerlink" title="安装脚本 install.sh"></a>安装脚本 <code>install.sh</code></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">echo &#x27;解压tar包...&#x27;</span><br><span class="line">tar -xvf $1</span><br><span class="line"></span><br><span class="line">echo &#x27;将docker目录移到/usr/bin目录下...&#x27;</span><br><span class="line">cp docker/* /usr/bin/</span><br><span class="line"></span><br><span class="line">echo &#x27;将docker.service 移到/etc/systemd/system/ 目录...&#x27;</span><br><span class="line">cp docker.service /etc/systemd/system/</span><br><span class="line"></span><br><span class="line">echo &#x27;添加文件权限...&#x27;</span><br><span class="line">chmod +x /etc/systemd/system/docker.service</span><br><span class="line"></span><br><span class="line">echo &#x27;重新加载配置文件...&#x27;</span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">echo &#x27;启动docker...&#x27;</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">echo &#x27;设置开机自启...&#x27;</span><br><span class="line">systemctl enable docker.service</span><br><span class="line"></span><br><span class="line">echo &#x27;docker安装成功...&#x27;</span><br><span class="line">docker -v</span><br></pre></td></tr></table></figure>

<h3 id="卸载脚本-uninstall-sh"><a href="#卸载脚本-uninstall-sh" class="headerlink" title="卸载脚本 uninstall.sh"></a>卸载脚本 <code>uninstall.sh</code></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">echo &#x27;删除docker.service...&#x27;</span><br><span class="line">rm -f /etc/systemd/system/docker.service</span><br><span class="line"></span><br><span class="line">echo &#x27;删除docker文件...&#x27;</span><br><span class="line">rm -rf /usr/bin/docker*</span><br><span class="line"></span><br><span class="line">echo &#x27;重新加载配置文件&#x27;</span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">echo &#x27;卸载成功...&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>目录中至少包含<code>docker-18.06.3-ce.tgz</code>、<code>docker.service</code>、<code>install.sh</code>、<code>uninstall.sh</code>文件</p>
<div align=center><img src="../../../../images/2021/10-12/docker-install_1.png" algin="center"/></div>

<h3 id="执行安装脚本"><a href="#执行安装脚本" class="headerlink" title="执行安装脚本"></a>执行安装脚本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装docker</span></span><br><span class="line">sh install.sh docker-18.06.3-ce.tgz</span><br></pre></td></tr></table></figure>

<div align=center><img src="../../../../images/2021/10-12/docker-install_2.png" algin="center"/></div>

<h3 id="查看docker版本"><a href="#查看docker版本" class="headerlink" title="查看docker版本"></a>查看docker版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看docker版本</span></span><br><span class="line">docker -v</span><br></pre></td></tr></table></figure>

<div align=center><img src="../../../../images/2021/10-12/docker-install_3.png" algin="center"/></div>

<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 卸载docker</span></span><br><span class="line">sh uninstall.sh</span><br></pre></td></tr></table></figure>

<div align=center><img src="../../../../images/2021/10-12/docker-install_4.png" algin="center"/></div>

<h1 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h1><h2 id="下载安装包-1"><a href="#下载安装包-1" class="headerlink" title="下载安装包"></a>下载安装包</h2><p>官方离线安装包下载地址：<a href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases</a></p>
<p>目前最新版本为<code>v2.0.1</code>：<code>docker-compose-linux-x86_64</code></p>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>进入到<code>docker-compose-linux-x86_64</code>所在文件目录</p>
<h3 id="安装脚本-install-compose-sh"><a href="#安装脚本-install-compose-sh" class="headerlink" title="安装脚本 install-compose.sh"></a>安装脚本 <code>install-compose.sh</code></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">echo &#x27;拷贝文件到/usr/local/bin目录...&#x27;</span><br><span class="line">cp docker-compose-Linux-x86_64 /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">cd /usr/local/bin</span><br><span class="line"></span><br><span class="line">echo &#x27;授权docker-compose...&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行授权</span></span><br><span class="line">sudo chmod +x docker-compose</span><br><span class="line"></span><br><span class="line">echo &#x27;安装成功&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装docker-compose</span></span><br><span class="line">sh install-compose.sh</span><br></pre></td></tr></table></figure>

<div align=center><img src="../../../../images/2021/10-12/docker-compose-install_1.png" algin="center"/></div>

<h3 id="查看docker-compose版本"><a href="#查看docker-compose版本" class="headerlink" title="查看docker-compose版本"></a>查看docker-compose版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>

<div align=center><img src="../../../../images/2021/10-12/docker-compose-install_2.png" algin="center"/></div>

]]></content>
      <categories>
        <category>工具</category>
        <category>Linux</category>
        <category>安装</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>系统中功能点的版本控制</title>
    <url>/%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%8A%9F%E8%83%BD%E7%82%B9%E7%9A%84%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>​    开发过程中我们会使用<code>版本控制工具</code>，如SVN、Git等。但是我们一样会遇到一种情形：在一套试题系统中，有新建题目、编辑题目、删除题目等功能，且题目可以被多个人修改，每人修改一次即是一个版本。现在的需求就是需要<code>记录每一次修改的详细信息</code>，<code>每次版本之间的差异</code>，甚至还可以<code>版本回滚</code>。</p>
<p>​    例如题目编号为<em>20170919170800000061</em>的题目被<em>A</em>创建，依次被<em>B</em>、<em>C</em>、<em>D</em>各修改了一次，此时需要比较<em>B</em>和<em>A</em>间的差异、<em>C</em>和<em>B</em>间的差异、<em>D</em>和<em>C</em>间的差异，到最后审核阶段如果<em>B</em> 的版本比较符合，则需要把试题版本内容回滚到<em>B</em>版本作为最后的版本。<div align=center><img width="700" height="300" src="../../../../images/2017-9-21/versionControl/v1.jpg" algin="center"/></div><span id="more"></span></p>
<p>仔细分析一下题干，我们的需求是<em>1.比较版本的差异，2.版本的回滚</em>。之前有考虑过两种方案：</p>
<ol>
<li>修改时在前端进行比较，只记录版本的差异，后台只需要进行存取即可。</li>
<li>把所有版本信息全部存储在数据库，在请求时后台进行比较差异。</li>
</ol>
<p>第一种方案带来的问题是没法进行版本回滚，只记录下来了差异，回滚时将会是灾难，那么第二种方案才是较合适的选择。</p>
<p>下图是数据库中的版本修改记录</p>
<div align=center><img width="700" height="300" src="../../../../images/2017-9-21/versionControlitem_mysql.png" algin="center"/>

</div>

<p>题目的所有信息全部存储在<strong>itemJson</strong>中，比较版本间的差异即是比较版本间的itemJson，现在的目标就是要提取两个版本中itemJson中的差异。</p>
<p>通过从网上查找资料找到了两种比较合适的方法，值得借鉴一下。</p>
<h1 id="版本差异（比较Json的方法）"><a href="#版本差异（比较Json的方法）" class="headerlink" title="版本差异（比较Json的方法）"></a>版本差异（比较Json的方法）</h1><p>计较两个Json(X，Y)，其中可能情况：</p>
<ol>
<li>X和Y中均有相同字段</li>
<li>X中存在Y中不存在的字段</li>
<li>Y中存在X中不存在的字段</li>
</ol>
<p>需要掌握：</p>
<ol>
<li><strong>各个字段的用处和意义</strong></li>
<li><strong>字段在Map、Json、JavaBean、List、JsonString形态之间的转换</strong></li>
</ol>
<h2 id="通过Map间接比较"><a href="#通过Map间接比较" class="headerlink" title="通过Map间接比较"></a>通过Map间接比较</h2><h3 id="引入Maven依赖"><a href="#引入Maven依赖" class="headerlink" title="引入Maven依赖"></a>引入Maven依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>23.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="定义静态工具类"><a href="#定义静态工具类" class="headerlink" title="定义静态工具类"></a>定义静态工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理json字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readJsonToObject</span><span class="params">(String jsonString, TypeReference&lt;T&gt; tr)</span> </span>&#123;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    <span class="keyword">if</span> (jsonString == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(jsonString)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) objectMapper.readValue(jsonString, tr);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            logger.debug(<span class="string">&quot;json error:&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义Map比较的工具类"><a href="#定义Map比较的工具类" class="headerlink" title="定义Map比较的工具类"></a>定义Map比较的工具类</h3><p>​    通过google的<code>guava</code>表达式中的 *Maps.difference(map1,map2)*方法进行比较，单此方法可比较正常的Map和String内容，对于List方式的比较，同时进行了数值和list内容顺序的比较，显然不符合我们的匹配规则，所以我们要对这个方法配合List的containAll方法进一步做封装。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Map&lt;String, String&gt;&gt; compareMap(Map&lt;String, Object&gt; oldVersion, Map&lt;String, Object&gt; newVersion) &#123;</span><br><span class="line">        MapDifference&lt;String, Object&gt; difference = Maps.difference(oldVersion, newVersion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有不同点</span></span><br><span class="line">        Map&lt;String, MapDifference.ValueDifference&lt;Object&gt;&gt; differenceMap = difference.entriesDiffering();</span><br><span class="line">        List&lt;Map&lt;String, String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Iterator diffIterator = differenceMap.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (diffIterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry entry = (java.util.Map.Entry) diffIterator.next();</span><br><span class="line"></span><br><span class="line">            MapDifference.ValueDifference&lt;Object&gt; valueDifference = (MapDifference.ValueDifference&lt;Object&gt;) entry</span><br><span class="line">                    .getValue();</span><br><span class="line">            <span class="keyword">boolean</span> isList = valueDifference.leftValue() <span class="keyword">instanceof</span> List</span><br><span class="line">                    &amp;&amp; valueDifference.rightValue() <span class="keyword">instanceof</span> List;</span><br><span class="line">            <span class="keyword">boolean</span> isMap = valueDifference.leftValue() <span class="keyword">instanceof</span> Map &amp;&amp; valueDifference.rightValue() <span class="keyword">instanceof</span> Map;</span><br><span class="line">            <span class="keyword">if</span> (!isList &amp;&amp; !isMap) &#123;</span><br><span class="line">                Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                String fieldKey = String.valueOf(entry.getKey());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 选择题中选项内容改变</span></span><br><span class="line">                <span class="keyword">if</span> (oldVersion.get(<span class="string">&quot;content&quot;</span>) != <span class="keyword">null</span> &amp;&amp; oldVersion.get(<span class="string">&quot;name&quot;</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    map.put(<span class="string">&quot;fieldName&quot;</span>, judgeOption(oldVersion.get(<span class="string">&quot;name&quot;</span>).toString()));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(<span class="string">&quot;fieldName&quot;</span>, judgeFiledName(fieldKey));</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(<span class="string">&quot;fieldKey&quot;</span>, fieldKey);</span><br><span class="line">                map.put(<span class="string">&quot;oldValue&quot;</span>, judgeFiledKey(fieldKey, valueDifference.leftValue().toString()));</span><br><span class="line">                map.put(<span class="string">&quot;newValue&quot;</span>, judgeFiledKey(fieldKey, valueDifference.rightValue().toString()));</span><br><span class="line">                result.add(map);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理结果是否为List,则递归执行比较规则</span></span><br><span class="line">            <span class="keyword">if</span> (valueDifference.leftValue() <span class="keyword">instanceof</span> List &amp;&amp; valueDifference.rightValue() <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">                JSONArray j = JSONArray.parseArray(JSON.toJSONString(valueDifference.leftValue()));</span><br><span class="line">                JSONArray p = JSONArray.parseArray(JSON.toJSONString(valueDifference.rightValue()));</span><br><span class="line">                JSONObject js = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                JSONObject js1 = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j.size(); i++) &#123;</span><br><span class="line">                    js.put(i + <span class="string">&quot;&quot;</span>, j.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.size(); i++) &#123;</span><br><span class="line">                    js1.put(i + <span class="string">&quot;&quot;</span>, p.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                Map&lt;String, Object&gt; requestMap = JsonUtils.readJsonToObject(js.toString(),</span><br><span class="line">                        <span class="keyword">new</span> TypeReference&lt;Map&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">                        &#125;);</span><br><span class="line">                Map&lt;String, Object&gt; requestMap1 = JsonUtils.readJsonToObject(js1.toString(),</span><br><span class="line">                        <span class="keyword">new</span> TypeReference&lt;Map&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">                        &#125;);</span><br><span class="line">                List&lt;Map&lt;String, String&gt;&gt; m = compareMap(requestMap, requestMap1);  <span class="comment">//当修改多个选项</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m.size(); i++) &#123;</span><br><span class="line">                    result.add(compareMap(requestMap, requestMap1).get(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理结果是否为Map,则递归执行比较规则</span></span><br><span class="line">            <span class="keyword">if</span> (valueDifference.leftValue() <span class="keyword">instanceof</span> Map &amp;&amp; valueDifference.rightValue() <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">                result.add(compareMap((Map&lt;String, Object&gt;) valueDifference.leftValue(),</span><br><span class="line">                        (Map&lt;String, Object&gt;) valueDifference.rightValue()).get(<span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若A中有B中不存在的值</span></span><br><span class="line">        Map&lt;String, Object&gt; entriesOnlyOnLeft = difference.entriesOnlyOnLeft();</span><br><span class="line">        <span class="keyword">if</span> (entriesOnlyOnLeft != <span class="keyword">null</span> &amp;&amp; !entriesOnlyOnLeft.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            Iterator it = entriesOnlyOnLeft.entrySet().iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                Map.Entry&lt;String, String&gt; entry = (java.util.Map.Entry) it.next();</span><br><span class="line">                Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                String fieldKey = entry.getKey();</span><br><span class="line">                map.put(<span class="string">&quot;fieldKey&quot;</span>, fieldKey);</span><br><span class="line">                map.put(<span class="string">&quot;fieldName&quot;</span>, judgeFiledName(fieldKey));</span><br><span class="line">                map.put(<span class="string">&quot;oldValue&quot;</span>, judgeFiledKey(fieldKey, String.valueOf(entry.getValue())));</span><br><span class="line">                map.put(<span class="string">&quot;newValue&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                result.add(map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若B中有A中不存在的值</span></span><br><span class="line">        Map&lt;String, Object&gt; onlyOnRightMap = difference.entriesOnlyOnRight();</span><br><span class="line">        <span class="keyword">if</span> (onlyOnRightMap != <span class="keyword">null</span> &amp;&amp; !onlyOnRightMap.isEmpty()) &#123;</span><br><span class="line">            Iterator it = onlyOnRightMap.entrySet().iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                Map.Entry&lt;String, String&gt; entry = (java.util.Map.Entry) it.next();</span><br><span class="line">                Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                String fieldKey = String.valueOf(entry.getKey());</span><br><span class="line">                map.put(<span class="string">&quot;fieldKey&quot;</span>, fieldKey);</span><br><span class="line">                map.put(<span class="string">&quot;fieldName&quot;</span>, judgeFiledName(fieldKey));</span><br><span class="line">                map.put(<span class="string">&quot;oldValue&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                map.put(<span class="string">&quot;newValue&quot;</span>, judgeFiledKey(fieldKey, String.valueOf(entry.getValue())));</span><br><span class="line">                result.add(map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义静态调用方法"><a href="#定义静态调用方法" class="headerlink" title="定义静态调用方法"></a>定义静态调用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Map&lt;String, String&gt;&gt; compareJSON(String jsonOld, String jsonNew) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; oldVersion = JsonUtils.readJsonToObject(jsonOld, <span class="keyword">new</span> TypeReference&lt;Map&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">        Map&lt;String, Object&gt; newVersion = JsonUtils.readJsonToObject(jsonNew, <span class="keyword">new</span> TypeReference&lt;Map&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> compareMap(oldVersion, newVersion);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h3><p>经过处理后的返回结果</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;newValue&quot;</span>: <span class="string">&quot;10&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;fieldName&quot;</span>: <span class="string">&quot;分数&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;fieldKey&quot;</span>: <span class="string">&quot;score&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;oldValue&quot;</span>: <span class="string">&quot;8&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;newValue&quot;</span>: <span class="string">&quot;10&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;fieldName&quot;</span>: <span class="string">&quot;教材依据&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;fieldKey&quot;</span>: <span class="string">&quot;teachingMaterialBasis&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;oldValue&quot;</span>: <span class="string">&quot;2&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;newValue&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;fieldName&quot;</span>: <span class="string">&quot;大纲依据&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;fieldKey&quot;</span>: <span class="string">&quot;syllabusBasis&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;oldValue&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;newValue&quot;</span>: <span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;fieldName&quot;</span>: <span class="string">&quot;难度系数&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;fieldKey&quot;</span>: <span class="string">&quot;difficult&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;oldValue&quot;</span>: <span class="string">&quot;0.4&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;newValue&quot;</span>: <span class="string">&quot;掌握&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;fieldName&quot;</span>: <span class="string">&quot;能力层次&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;fieldKey&quot;</span>: <span class="string">&quot;abilityLevel&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;oldValue&quot;</span>: <span class="string">&quot;熟悉&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;newValue&quot;</span>: <span class="string">&quot;测试关键词&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;fieldName&quot;</span>: <span class="string">&quot;关键字&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;fieldKey&quot;</span>: <span class="string">&quot;keyWord&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;oldValue&quot;</span>: <span class="string">&quot;个&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br></pre></td></tr></table></figure>

<p>查看所有源码点击：<a href="../../../../images/2017-9-21/versionControl/2017-09-21-code.zip"><em>下载</em></a></p>
<h2 id="转为JavaBean比较"><a href="#转为JavaBean比较" class="headerlink" title="转为JavaBean比较"></a>转为JavaBean比较</h2><p>将itemJson字符串转化为JavaBean，比较JavaBean之前的差异。比较JavaBean间的差异可以用Javers。</p>
<h3 id="引入Javers的Maven依赖"><a href="#引入Javers的Maven依赖" class="headerlink" title="引入Javers的Maven依赖"></a>引入Javers的Maven依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.javers<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javers-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="将itemJson转为JavaBean"><a href="#将itemJson转为JavaBean" class="headerlink" title="将itemJson转为JavaBean"></a>将itemJson转为JavaBean</h3><h4 id="方式一：利用Jackson"><a href="#方式一：利用Jackson" class="headerlink" title="方式一：利用Jackson"></a>方式一：利用Jackson</h4><h5 id="工具类JsonUtils"><a href="#工具类JsonUtils" class="headerlink" title="工具类JsonUtils"></a>工具类JsonUtils</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义jackson对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper MAPPER = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将对象转换成json字符串。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Title: pojoToJson&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Description: &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">objectToJson</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">			String string = MAPPER.writeValueAsString(data);</span><br><span class="line">			<span class="keyword">return</span> string;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将json结果集转化为对象</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jsonData json数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 对象中的object类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">jsonToPojo</span><span class="params">(String jsonData, Class&lt;T&gt; beanType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T t = MAPPER.readValue(jsonData, beanType);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        	e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将json数据转换成pojo对象list</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Title: jsonToList&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Description: &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jsonData</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;<span class="function">List&lt;T&gt; <span class="title">jsonToList</span><span class="params">(String jsonData, Class&lt;T&gt; beanType)</span> </span>&#123;</span><br><span class="line">    	JavaType javaType = MAPPER.getTypeFactory().constructParametricType(List.class, beanType);</span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">    		List&lt;T&gt; list = MAPPER.readValue(jsonData, javaType);</span><br><span class="line">    		<span class="keyword">return</span> list;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Json转Pojo"><a href="#Json转Pojo" class="headerlink" title="Json转Pojo"></a>Json转Pojo</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Item item1 = JsonUtils.jsonToPojo(itemJsonOld, Item.class);</span><br><span class="line">Item item2 = JsonUtils.jsonToPojo(itemJsonNew, Item.class);</span><br></pre></td></tr></table></figure>

<h4 id="方式二：利用fastJson"><a href="#方式二：利用fastJson" class="headerlink" title="方式二：利用fastJson"></a>方式二：利用fastJson</h4><h5 id="引入Maven依赖-1"><a href="#引入Maven依赖-1" class="headerlink" title="引入Maven依赖"></a>引入Maven依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="Json转Pojo-1"><a href="#Json转Pojo-1" class="headerlink" title="Json转Pojo"></a>Json转Pojo</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Item item1 = JSONObject.parseObject(json3, Item.class);</span><br><span class="line">Item item2 = JSONObject.parseObject(json4, Item.class);</span><br></pre></td></tr></table></figure>

<h3 id="利用Javers比较JavaBean"><a href="#利用Javers比较JavaBean" class="headerlink" title="利用Javers比较JavaBean"></a>利用Javers比较JavaBean</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Javers j = JaversBuilder.javers().build();</span><br><span class="line">        Diff diff = j.compare(item1, item2);</span><br><span class="line">        <span class="keyword">if</span> (diff.hasChanges()) &#123;</span><br><span class="line">            List&lt;Change&gt; changes = diff.getChanges();</span><br><span class="line">            <span class="keyword">for</span> (Change change : changes) &#123;</span><br><span class="line">                <span class="keyword">if</span> (change <span class="keyword">instanceof</span> ValueChange) &#123;</span><br><span class="line">                    ValueChange valChange = (ValueChange) change;</span><br><span class="line">                    System.out.println(valChange.getPropertyName() + <span class="string">&quot; -- &quot;</span> + valChange.getLeft() + <span class="string">&quot;--&quot;</span> + valChange.getRight());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h1 id="版本回滚"><a href="#版本回滚" class="headerlink" title="版本回滚"></a>版本回滚</h1><p>​    其实版本回滚在上面的比较中已经说了，就是把<strong>需要回滚的版本itemJson转化为JavaBean传给前台，同时生成一份最新的版本为当前版本，记录操作人、操作时间等等记录</strong>即可。需要了解及使用Gson、fastJson、Jackson的使用，及使用工具将Map、Json、JavaBean、List、JsonString对象之间状态的转换。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>熟悉业务。</li>
<li>掌握Map、Json、JavaBean、List、JsonString对象之间状态的转换。</li>
<li>版本需要存储所有信息便于回滚。</li>
<li>个人倾向使用Javers比较JavaBean进行比较版本差异。</li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池之ThreadPoolExecutor</title>
    <url>/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BThreadPoolExecutor/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>JAVA对于多线程的封装非常丰富，提供了多种适用于不同场景的多并发实现。但如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。这里就引入了线程池来管理线程，其中最基础、最核心的线程池要属ThreadPoolExecutor类了。<div align=center><img src="../../../../images//2018-3/threadpoolexcetor/threadpoolexecutor.png" algin="center"/></div></p>
<h1 id="Java中的ThreadPoolExecutor类"><a href="#Java中的ThreadPoolExecutor类" class="headerlink" title="Java中的ThreadPoolExecutor类"></a>Java中的ThreadPoolExecutor类</h1><p>java.uitl.concurrent.ThreadPoolExecutor类是线程池中最核心的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类。下面我们来看一下ThreadPoolExecutor类的具体实现源码。</p>
<p>在ThreadPoolExecutor类中提供了四个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">   .....</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">           BlockingQueue&lt;Runnable&gt; workQueue)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">           BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">           BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">       BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//corePoolSize： 线程池维护线程的最少数量  </span></span><br><span class="line"><span class="comment">//maximumPoolSize：线程池维护线程的最大数量  </span></span><br><span class="line"><span class="comment">//keepAliveTime： 线程池维护线程所允许的空闲时间  </span></span><br><span class="line"><span class="comment">//unit： 线程池维护线程所允许的空闲时间的单位  </span></span><br><span class="line"><span class="comment">//workQueue： 线程池所使用的缓冲队列  </span></span><br><span class="line"><span class="comment">//handler： 线程池对拒绝任务的处理策略 </span></span><br></pre></td></tr></table></figure>

<p>从上面的代码可以得知，ThreadPoolExecutor继承了AbstractExecutorService类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。</p>
<ul>
<li><p><strong>corePoolSize</strong>：核心池的大小。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</p>
</li>
<li><p><strong>maximumPoolSize</strong>：线程池最大线程数，它表示在线程池中最多能创建多少个线程；</p>
</li>
<li><p><strong>keepAliveTime</strong>：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</p>
</li>
<li><p><strong>unit</strong>：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TimeUnit.DAYS;              <span class="comment">//天</span></span><br><span class="line">TimeUnit.HOURS;             <span class="comment">//小时</span></span><br><span class="line">TimeUnit.MINUTES;           <span class="comment">//分钟</span></span><br><span class="line">TimeUnit.SECONDS;           <span class="comment">//秒</span></span><br><span class="line">TimeUnit.MILLISECONDS;      <span class="comment">//毫秒</span></span><br><span class="line">TimeUnit.MICROSECONDS;      <span class="comment">//微妙</span></span><br><span class="line">TimeUnit.NANOSECONDS;       <span class="comment">//纳秒</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>workQueue</strong>：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayBlockingQueue;</span><br><span class="line">LinkedBlockingQueue;</span><br><span class="line">SynchronousQueue;</span><br></pre></td></tr></table></figure>

<p>ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。</p>
</li>
<li><p><strong>threadFactory</strong>：线程工厂，主要用来创建线程；</p>
</li>
<li><p><strong>handler</strong>：表示当拒绝处理任务时的策略，有以下四种取值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy: 缺省。丢弃任务并抛出RejectedExecutionException异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃任务队列中最旧任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 </span><br></pre></td></tr></table></figure></li>
</ul>
<div align=center><img src="../../../../images//2018-3/threadpoolexcetor/inherit.png" algin="center"/></div>

<p>由图中我们可得知ThreadPoolExecutor继承了AbstractExecutorService，AbstractExecutorService是一个抽象类，它实现了ExecutorService接口，而ExecutorService又是继承了Executor接口。</p>
<h1 id="线程池实现原理"><a href="#线程池实现原理" class="headerlink" title="线程池实现原理"></a>线程池实现原理</h1><h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><p>在ThreadPoolExecutor中定义了几个static final变量表示线程池的各个状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> * RUNNING -&gt; SHUTDOWN</span><br><span class="line">     *    <span class="function">On invocation of <span class="title">shutdown</span><span class="params">()</span>, perhaps implicitly in <span class="title">finalize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     * <span class="params">(RUNNING or SHUTDOWN)</span> -&gt; STOP</span></span><br><span class="line"><span class="function">     *    On invocation of <span class="title">shutdownNow</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     * SHUTDOWN -&gt; TIDYING</span></span><br><span class="line"><span class="function">     *    When both queue and pool are empty</span></span><br><span class="line"><span class="function">     * STOP -&gt; TIDYING</span></span><br><span class="line"><span class="function">     *    When pool is empty</span></span><br><span class="line"><span class="function">     * TIDYING -&gt; TERMINATED</span></span><br><span class="line"><span class="function">     *    When the <span class="title">terminated</span><span class="params">()</span> hook method has completed</span></span><br><span class="line"><span class="function">     **/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    </span>= -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<p>下面的几个static final变量表示runState可能的几个取值。</p>
<ol>
<li><strong>RUNNING</strong>：允许接收新任务并且处理队列中的任务。</li>
<li><strong>SHUTDOWN</strong>：不再接收新的任务，仅消化完队列中的任务。</li>
<li><strong>STOP</strong>：不仅不再接收新的任务，连队列中的任务都不再消化处理了，并且尝试中断正在执行任务的线程。</li>
<li><strong>TIDYING</strong>：所有任务被终止了，工作线程数<code>workCount</code>也被设为0，线程的状态也被设为<strong>TIDYING</strong>，并开始调用钩子函数terminated()。</li>
<li><strong>TERMINATED</strong>：钩子函数<code>terminated()</code>执行完毕。</li>
</ol>
<div align=center><img src="../../../../images/2018-3/threadpoolexcetor/status.png" algin="center"/></div>

<h2 id="任务的执行"><a href="#任务的执行" class="headerlink" title="任务的执行"></a>任务的执行</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;              <span class="comment">//任务缓存队列，用来存放等待执行的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();   <span class="comment">//线程池的主要状态锁，对线程池状态（比如线程池大小/runState等）的改变都要使用这个锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();  <span class="comment">//用来存放工作集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;    <span class="comment">//线程存活时间   </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;   <span class="comment">//是否允许为核心线程设置存活时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;     <span class="comment">//核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;   <span class="comment">//线程池最大能容忍的线程数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> poolSize;       <span class="comment">//线程池中当前的线程数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler; <span class="comment">//任务拒绝策略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;   <span class="comment">//线程工厂，用来创建线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;   <span class="comment">//用来记录线程池中曾经出现过的最大线程数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;   <span class="comment">//用来记录已经执行完毕的任务个数</span></span><br></pre></td></tr></table></figure>

<p>每个变量的作用都已经标明出来了，这里要重点解释一下<em>corePoolSize</em>、<em>maximumPoolSize</em>、<em>largestPoolSize</em>三个变量。</p>
<ol>
<li>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；</li>
<li>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；</li>
<li>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；</li>
<li>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</li>
</ol>
<h2 id="任务缓存及排队策略"><a href="#任务缓存及排队策略" class="headerlink" title="任务缓存及排队策略"></a>任务缓存及排队策略</h2><p>在前面我们多次提到了任务缓存队列，即workQueue，它用来存放等待执行的任务。workQueue的类型为BlockingQueue<code>&lt;Runnable&gt;</code>，通常可以取下面三种类型：</p>
<p>1）<strong>ArrayBlockingQueue</strong>：<code>有界队列</code>，有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O 边界），则系统可能为超过许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU 使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。</p>
<p>2）<strong>LinkedBlockingQueue</strong>：<code>无界队列</code>，将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize 的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</p>
<p>3）<strong>SynchronousQueue</strong>：工作队列的<code>默认选项是 SynchronousQueue</code>，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</p>
<h2 id="任务拒绝策略"><a href="#任务拒绝策略" class="headerlink" title="任务拒绝策略"></a>任务拒绝策略</h2><p>当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:			丢弃任务并抛出RejectedExecutionException异常。</span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：   	也是丢弃任务，但是不抛出异常。</span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy： 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：	由调用线程处理该任务</span><br></pre></td></tr></table></figure>

<h2 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h2><p>ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()：</p>
<ul>
<li>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。</li>
<li>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。</li>
</ul>
<h2 id="线程池容量的动态调整"><a href="#线程池容量的动态调整" class="headerlink" title="线程池容量的动态调整"></a>线程池容量的动态调整</h2><p>ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize()：</p>
<ul>
<li><div align=center><img src="../../../../images/2018-3/Mybatis/ehcachecache.png" algin="center"/></div></li>
<li>setMaximumPoolSize：设置线程池最大能创建的线程数目大小。</li>
</ul>
<h1 id="使用Executors创建线程池"><a href="#使用Executors创建线程池" class="headerlink" title="使用Executors创建线程池"></a>使用Executors创建线程池</h1><p>Executors提供的工厂方法，可以创建以下四种类型线程池：</p>
<ul>
<li><strong>newFixedThreadPool：</strong>该方法将用于创建一个固定大小的线程池（此时corePoolSize = maxPoolSize），每提交一个任务就创建一个线程池，直到线程池达到最大数量，线程池的规模在此后不会发生任何变化；</li>
</ul>
<ul>
<li><strong>newCachedThreadPool：</strong>该方法创建了一个可缓存的线程池，（此时corePoolSize = 0，maxPoolSize = Integer.MAX_VALUE），空闲线程超过60秒就会被自动回收，该线程池存在的风险是，如果服务器应用达到请求高峰期时，会不断创建新的线程，直到内存耗尽；</li>
</ul>
<ul>
<li><strong>newSingleThreadExecutor：</strong>该方法创建了一个单线程的线程池，该线程池按照任务在队列中的顺序串行执行（如：<strong>FIFO</strong>、<strong>LIFO</strong>、优先级）；</li>
</ul>
<ul>
<li><strong>newScheduledThreadPool：</strong>该方法创建了一个固定长度的线程池，可以以延迟或者定时的方式执行任务；</li>
</ul>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadFactory factory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;test&quot;</span>).build();</span><br><span class="line">		ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">200</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">				<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>),factory,<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">			MyTask myTask = <span class="keyword">new</span> MyTask(i);</span><br><span class="line">			executor.execute(myTask);</span><br><span class="line">			System.out.println(<span class="string">&quot;线程池中线程数目：&quot;</span> + executor.getPoolSize() + <span class="string">&quot;，队列中等待执行的任务数目：&quot;</span> + executor.getQueue().size()</span><br><span class="line">					+ <span class="string">&quot;，已执行玩别的任务数目：&quot;</span> + executor.getCompletedTaskCount());</span><br><span class="line">		&#125;</span><br><span class="line">		executor.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> taskNum;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.taskNum = num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;正在执行task &quot;</span> + taskNum);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;task &quot;</span> + taskNum + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<div align=center><img src="../../../../images//2018-3/threadpoolexcetor/result.png" algin="center"/></div>

<h2 id="合理配置线程池大小"><a href="#合理配置线程池大小" class="headerlink" title="合理配置线程池大小"></a>合理配置线程池大小</h2><p>一般需要根据任务的类型来配置线程池大小：</p>
<ul>
<li><p>如果是<strong>CPU密集型任务</strong>，就需要尽量压榨CPU，参考值可以设为 <strong><em>N</em>CPU+1</strong></p>
</li>
<li><p>如果是<strong>IO密集型任务</strong>，参考值可以设置为2*<em>N</em>CPU</p>
</li>
</ul>
<p>这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMTY0NDU3Nw==&mid=2651935366&idx=1&sn=ee82f1deb13192c5f1a20721a0c1abbe&chksm=8d0f3dc8ba78b4de93a26cdb6eea3b3804149a7fe88e9e8114757b0aa2cd39a67ad10e6f42ee&mpshare=1&scene=1&srcid=0317Fqotu8V4wTWmJ07lgTbS#rd"><em><strong>Java并发编程：线程池的使用</strong></em></a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池踩坑</title>
    <url>/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<p>使用线程池这么久，自认为很熟悉，居然还能踩到坑！问题原因：线程池使用 <code>FutureTask</code>的时候如果拒绝策略设置为了 <code>DiscardPolicy或DiscardOldestPolicy</code>并且在被拒绝的任务 <code>Future</code>对象上调用无参 <code>get</code>方法那么调用线程会一直被阻塞。</p>
<h1 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h1><p>先来看一段代码进行复现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建核心数量为1，队列个数为1的线程池。拒绝策略为DiscardPolicy。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadPoolExecutor EXECUTOR = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">1</span>), <span class="keyword">new</span> NamedThreadFactory(<span class="string">&quot;executor&quot;</span>), <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 添加任务一</span></span><br><span class="line">        Future&lt;?&gt; first = EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;first task start&quot;</span>);</span><br><span class="line">            Uninterruptibles.sleepUninterruptibly(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加任务二</span></span><br><span class="line">        Future&lt;?&gt; second = EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;second task start&quot;</span>);</span><br><span class="line">            Uninterruptibles.sleepUninterruptibly(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加任务、三</span></span><br><span class="line">        Future&lt;?&gt; third = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            third = EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;first task start&quot;</span>);</span><br><span class="line">                Uninterruptibles.sleepUninterruptibly(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getLocalizedMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待任务一执行完毕</span></span><br><span class="line">        System.out.println(<span class="string">&quot;first task output. &quot;</span> + first.get());</span><br><span class="line">        <span class="comment">// 等待任务二执行完毕</span></span><br><span class="line">        System.out.println(<span class="string">&quot;second task output. &quot;</span> + second.get());</span><br><span class="line">        <span class="comment">// 等待任务三执行完毕</span></span><br><span class="line">        System.out.println(<span class="string">&quot;third task output. &quot;</span> + (third == <span class="keyword">null</span> ? <span class="keyword">null</span> : third.get()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        EXECUTOR.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果为下图所示，<code>third task</code> 一直没有执行，且主线程阻塞在<code>third.get()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">first task start</span><br><span class="line">first task output. <span class="keyword">null</span></span><br><span class="line">second task start</span><br><span class="line">second task output. <span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>流程分析</p>
<ol>
<li>创建一个核心线程数为1且队列大小为1的线程池，设置拒绝策略为<code>DiscardPolicy</code>。</li>
<li>向线程池提交first任务，线程池会使用核心线程池执行该任务，任务将会阻塞3s。</li>
<li>向线程池提交second任务，线程池将任务放到队列中。</li>
<li>向线程池提交third任务，线程池已满，线程池采用<code>DiscardPolicy</code>丢弃任务。</li>
<li>等待first任务执行完毕后主线程打印 first task output. null</li>
<li>first任务执行完成关闭后，线程池从队列中取出second任务执行，主线程打印second task output. null</li>
<li>third任务会一直阻塞，程序不会结束。如果把拒绝策略修改为<code>DiscardOldestPolicy</code>，也会出现同样的问题。</li>
</ol>
<p>将拒绝策略修改为<code>AbortPolicy</code>后输出结果如下，线程池正常关闭。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">first task start</span><br><span class="line">Task java.util.concurrent.FutureTask@32c4e8b2 rejected from java.util.concurrent.ThreadPoolExecutor@64bce832[Running, pool size = <span class="number">1</span>, active threads = <span class="number">1</span>, queued tasks = <span class="number">1</span>, completed tasks = <span class="number">0</span>]</span><br><span class="line">first task output. <span class="keyword">null</span></span><br><span class="line">second task start</span><br><span class="line">second task output. <span class="keyword">null</span></span><br><span class="line">third task output. <span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<h1 id="调用逻辑梳理"><a href="#调用逻辑梳理" class="headerlink" title="调用逻辑梳理"></a>调用逻辑梳理</h1><p>当提交任务到线程池中时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 包装Runnable为Future对象</span></span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="comment">// 返回Future对象</span></span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装Runnable为Future对象</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 任务数量小于核心线程池数量时新增线程处理</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 任务数量达到核心线程数量时，将任务放入队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试新增线程处理任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        <span class="comment">// 新增失败，调用拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述是任务不断加入线程池的流程处理，其中需要研究的就是最后一步拒绝策略对任务的影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">		<span class="comment">// 什么都没做</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当拒绝策略使用<code>DiscardPolicy</code>时发现什么都没做。但是当把 <code>Runnable</code>包装为<code>Future</code>对象时，<code>Future</code>是有状态的，<code>Future</code>中的状态如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p>在把<code>Runnable</code>包装为<code>Future</code>对象的时候使用<code>newTaskFor</code>方法转换<code>Runnable</code>为<code>FutureTask</code>，而<code>FutureTask</code>的构造函数里面设置的线程状态就是<code>New</code>。所以使用<code>DiscardPolicy</code>策略提交后返回了一个状态为<code>NEW</code>的<code>Future</code>对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用<code>Future</code>的无参<code>get</code>方法时逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="comment">// 当状态值 &lt;= COMPLETING时需要等待，否者调用report返回</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">    s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="comment">// 状态值为NORMAL正常返回</span></span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="comment">// 状态值大于等于CANCELLED则抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说当<code>Future</code>的状态 &gt;<code>COMPLETING</code>时候调用<code>get</code>方法才会正常返回，而<code>DiscardPolicy</code>策略在拒绝任务的时候并没有设置<code>future</code>的状态，后面也没有其他机会可以设置该<code>future</code>的状态，所以<code>future</code>的状态一直是<code>NEW</code>，导致任务阻塞，一直不会返回。同理<code>DiscardOldestPolicy</code>策略也是这样的问题，最老的任务被淘汰时没有设置淘汰任务<code>future</code>的状态。</p>
<p>默认的<code>AbortPolicy</code>策略当任务超出后会直接会抛出<code>RejectedExecutionException</code>异常，也就是<code>submit</code>方法并没有返回<code>future</code>对象，这时候<code>third</code>是<code>null</code>，可以正常返回。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>当使用<code>Future</code>的时候，尽量使用带超时时间的<code>get</code>方法，这样即使使用了<code>DiscardPolicy</code>拒绝策略也不至于任务一直等待，超时时间到了会自动返回，如果非要使用不带参数的<code>get</code>方法则可以重写<code>DiscardPolicy</code>的拒绝策略，在执行策略时候设置该<code>Future</code>的状态大于<code>COMPLETING</code>即可，但是查看<code>FutureTask</code>提供的方法发现只有<code>cancel</code>方法是<code>public</code>的并且可以设置<code>FutureTask</code>的状态大于<code>COMPLETING</code>，重写拒绝策略的线程池具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadPoolExecutor EXECUTOR = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">1</span>), <span class="keyword">new</span> NamedThreadFactory(<span class="string">&quot;executor&quot;</span>), (r, executor) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> FutureTask) &#123;</span><br><span class="line">            ((FutureTask&lt;?&gt;) r).cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>使用这个策略后，<code>Future.isCancelled</code>方法可判断线程是否已经取消，所以可以将代码修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待任务三执行完毕</span></span><br><span class="line">System.out.println(<span class="string">&quot;third task output. &quot;</span> + (third.isCancelled() ? <span class="string">&quot;拒绝了&quot;</span> : third.get()));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>网址收藏</title>
    <url>/%E7%BD%91%E5%9D%80%E6%94%B6%E8%97%8F/</url>
    <content><![CDATA[<h1 id="开发类"><a href="#开发类" class="headerlink" title="开发类"></a>开发类</h1><table>
<thead>
<tr>
<th>名称</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>Jetbrains系列产品重置试用方法</td>
<td><a href="https://zhile.io/">https://zhile.io</a></td>
</tr>
<tr>
<td>23种设计模式</td>
<td><a href="https://refactoringguru.cn/design-patterns">https://refactoringguru.cn/design-patterns</a></td>
</tr>
</tbody></table>
<h1 id="手册类"><a href="#手册类" class="headerlink" title="手册类"></a>手册类</h1><table>
<thead>
<tr>
<th>名称</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>Elasticsearch中文文档</td>
<td><a href="https://doc.codingdict.com/elasticsearch/323/">https://doc.codingdict.com/elasticsearch/323/</a></td>
</tr>
<tr>
<td>Elasticsearch中文文档</td>
<td><a href="https://learnku.com/docs/elasticsearch73/7.3">https://learnku.com/docs/elasticsearch73/7.3</a></td>
</tr>
</tbody></table>
<h1 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h1><table>
<thead>
<tr>
<th>名称</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>青龙面板</td>
<td><a href="https://github.com/whyour/qinglong">https://github.com/whyour/qinglong</a></td>
</tr>
<tr>
<td>AutoHotkey</td>
<td><a href="https://www.autohotkey.com/">https://www.autohotkey.com</a></td>
</tr>
<tr>
<td>数据库建模工具PDManer</td>
<td><a href="https://gitee.com/robergroup/pdmaner">https://gitee.com/robergroup/pdmaner</a></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>自定义StopWatch</title>
    <url>/%E8%87%AA%E5%AE%9A%E4%B9%89StopWatch/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在平时的开发调试工作或线上中，有时会遇到程序执行效率非常慢，通过一般的经验只能判断出部分逻辑有问题，但判断并不直观且效率较低，不知道方法中哪个阶段比较耗时。<span id="more"></span>目前spring-framework提供了一个StopWatch类可以做类似任务执行时间控制，于是利用此思想重新实现了一套自己的逻辑。<div align=center><img width="220" height="220" src="../../../../images/2019/1-3/StopWatch.jpg" algin="center"/></div></p>
<h1 id="Spring中StopWatch"><a href="#Spring中StopWatch" class="headerlink" title="Spring中StopWatch"></a>Spring中StopWatch</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStopWatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        StopWatch sw = <span class="keyword">new</span> StopWatch();</span><br><span class="line"></span><br><span class="line">        sw.start(<span class="string">&quot;起床&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        sw.stop();</span><br><span class="line"></span><br><span class="line">        sw.start(<span class="string">&quot;洗漱&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        sw.stop();</span><br><span class="line"></span><br><span class="line">        sw.start(<span class="string">&quot;锁门&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        sw.stop();</span><br><span class="line"></span><br><span class="line">        log.warn(<span class="string">&quot;prettyPrint = &#123;&#125;&quot;</span>, sw.prettyPrint());</span><br><span class="line">        log.info(<span class="string">&quot;totalTimeMillis = &#123;&#125;&quot;</span>, sw.getTotalTimeMillis());</span><br><span class="line">        log.warn(<span class="string">&quot;lastTaskName = &#123;&#125;&quot;</span>, sw.getLastTaskName());</span><br><span class="line">        log.info(<span class="string">&quot;lastTaskInfo = &#123;&#125;&quot;</span>, sw.getLastTaskInfo());</span><br><span class="line">        log.warn(<span class="string">&quot;taskCount = &#123;&#125;&quot;</span>, sw.getTaskCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TestStopWatch testStopWatch = <span class="keyword">new</span> TestStopWatch();</span><br><span class="line">        testStopWatch.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span>-<span class="number">22</span> <span class="number">21</span>:<span class="number">43</span>:<span class="number">49.468</span> WARN  c.f.o.d.TestStopWatch - prettyPrint = StopWatch <span class="string">&#x27;&#x27;</span>: <span class="function">running <span class="title">time</span> <span class="params">(millis)</span> </span>= <span class="number">3505</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">ms     %     Task name</span><br><span class="line">-----------------------------------------</span><br><span class="line"><span class="number">01004</span>  029%  起床</span><br><span class="line"><span class="number">02001</span>  <span class="number">057</span>%  洗漱</span><br><span class="line"><span class="number">00500</span>  <span class="number">014</span>%  锁门</span><br><span class="line"></span><br><span class="line"><span class="number">12</span>-<span class="number">22</span> <span class="number">21</span>:<span class="number">43</span>:<span class="number">49.476</span> INFO  c.f.o.d.TestStopWatch - totalTimeMillis = <span class="number">3505</span></span><br><span class="line"><span class="number">12</span>-<span class="number">22</span> <span class="number">21</span>:<span class="number">43</span>:<span class="number">49.476</span> WARN  c.f.o.d.TestStopWatch - lastTaskName = 锁门</span><br><span class="line"><span class="number">12</span>-<span class="number">22</span> <span class="number">21</span>:<span class="number">43</span>:<span class="number">49.477</span> INFO  c.f.o.d.TestStopWatch - lastTaskInfo = org.springframework.util.StopWatch$TaskInfo@5bd03f44</span><br><span class="line"><span class="number">12</span>-<span class="number">22</span> <span class="number">21</span>:<span class="number">43</span>:<span class="number">49.477</span> WARN  c.f.o.d.TestStopWatch - taskCount = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>可以看到，Spring中的StopWatch可以方便的排查程序执行效率，但是结果并不直观且代码侵入性太大。</p>
<h1 id="自定义StopWatch"><a href="#自定义StopWatch" class="headerlink" title="自定义StopWatch"></a>自定义StopWatch</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class StopWatch &#123;</span><br><span class="line">    private long startTime;</span><br><span class="line"></span><br><span class="line">    private long lapStartTime;</span><br><span class="line"></span><br><span class="line">    private String tagName;</span><br><span class="line"></span><br><span class="line">    private List&lt;String&gt; steps = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private StopWatch(String tagName) &#123;</span><br><span class="line">        this.tagName = tagName;</span><br><span class="line"></span><br><span class="line">        long start = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        this.startTime = start;</span><br><span class="line">        this.lapStartTime = start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static StopWatch create(String tagName) &#123;</span><br><span class="line"></span><br><span class="line">        return new StopWatch(tagName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void lap(String stepName) &#123;</span><br><span class="line"></span><br><span class="line">        long elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lapStartTime);</span><br><span class="line">        int index = steps.size() + 1;</span><br><span class="line">        String step = String.format(&quot;T%d(%s)/%d&quot;, index, stepName, elapsedTime);</span><br><span class="line">        steps.add(step);</span><br><span class="line"></span><br><span class="line">        //reset</span><br><span class="line">        this.lapStartTime = System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void log() &#123;</span><br><span class="line">        StringBuilder stringBuilder = createLog();</span><br><span class="line"></span><br><span class="line">        log.warn(stringBuilder.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void logSlow(long slow) &#123;</span><br><span class="line"></span><br><span class="line">        long totalElapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime);</span><br><span class="line">        if (totalElapsedTime &gt; slow) &#123;</span><br><span class="line">            StringBuilder stringBuilder = createLog();</span><br><span class="line">            log.warn(stringBuilder.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private StringBuilder createLog() &#123;</span><br><span class="line">        long totalElapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime);</span><br><span class="line"></span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder(tagName);</span><br><span class="line">        stringBuilder.append(&#x27; &#x27;);</span><br><span class="line">        stringBuilder.append(&quot; Total/&quot;);</span><br><span class="line">        stringBuilder.append(totalElapsedTime);</span><br><span class="line">        stringBuilder.append(&#x27; &#x27;);</span><br><span class="line"></span><br><span class="line">        for (String step : steps) &#123;</span><br><span class="line">            stringBuilder.append(step);</span><br><span class="line">            stringBuilder.append(&#x27; &#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        return stringBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStopWatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        StopWatch stopWatch = StopWatch.create(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        stopWatch.lap(<span class="string">&quot;起床&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        stopWatch.lap(<span class="string">&quot;洗漱&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        stopWatch.lap(<span class="string">&quot;锁门&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        stopWatch.log();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TestStopWatch testStopWatch = <span class="keyword">new</span> TestStopWatch();</span><br><span class="line">        testStopWatch.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span>-<span class="number">22</span> <span class="number">21</span>:<span class="number">53</span>:<span class="number">32.696</span> WARN  c.f.o.r.c.StopWatch - test  Total/<span class="number">3509</span> T1(起床)/<span class="number">1001</span> T2(洗漱)/<span class="number">2005</span> T3(锁门)/<span class="number">500</span> </span><br></pre></td></tr></table></figure>

<p>通过对比，可以发现自实现的StopWatch类更为简洁，同时也包含了必要的信息，但是功能不如Spring自带的强大。可针对不同的场景使用。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义rest代理(二)</title>
    <url>/%E8%87%AA%E5%AE%9A%E4%B9%89rest%E4%BB%A3%E7%90%86-%E4%BA%8C/</url>
    <content><![CDATA[<p>之前用<code>HttpClient</code>实现了rest代理(<a href="http://rainbowhorse.site/%E8%87%AA%E5%AE%9A%E4%B9%89rest%E4%BB%A3%E7%90%86/">自定义rest代理(一)</a>)，从网上看了下资料，同时针对公司已有的框架做了一些封装和改造。用<code>Retrofit2</code>另外实现了一套rest代理工具包。其中基本都是都是基于<code>Retrofit2</code>，自己又做了一层简单的封装。<div align=center><img width="220" height="220" src="../../../../images/2019/1-3/restful.png" algin="center"/></div></p>
<p>源码在我的GitHub上：<a href="https://github.com/mx-go/retrofit-rest-proxy">https://github.com/mx-go/retrofit-rest-proxy</a></p>
<h1 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h1><h2 id="引入Maven坐标"><a href="#引入Maven坐标" class="headerlink" title="引入Maven坐标"></a>引入Maven坐标</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.mx-go<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>retrofit-rest-proxy<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="在applicationContext-xml文件中加入配置"><a href="#在applicationContext-xml文件中加入配置" class="headerlink" title="在applicationContext.xml文件中加入配置"></a>在<em>applicationContext.xml</em>文件中加入配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;retrofitFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.github.proxy.core.ConfigRetrofitSpringFactory&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:configLocation</span>=<span class="string">&quot;classpath*:rest-proxy.json,classpath*:rest-proxy1.json&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">// 可针对不同接口配置多个</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sendHttp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.github.proxy.RetrofitSpringFactoryBean&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:type</span>=<span class="string">&quot;com.max.open.SendHttp&quot;</span> <span class="attr">p:factory-ref</span>=<span class="string">&quot;retrofitFactory&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.github.proxy.RetrofitSpringFactoryBean&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:type</span>=<span class="string">&quot;com.max.open.xxx&quot;</span> <span class="attr">p:factory-ref</span>=<span class="string">&quot;retrofitFactory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中参数：</p>
<ul>
<li><strong>configLocation</strong>：配置文件所在路径。支持多个配置文件路径，以英文**,**隔开。</li>
<li><strong>type</strong>：接口所在的路径。</li>
</ul>
<h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><p>针对Spring配置中的<em>configLocation</em>。<strong>有配置中心可修改源码从配置中心获取。</strong>以下举个例子：</p>
<p><em>rest-proxy.json</em></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;sendHttp&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;domain&quot;</span>: <span class="string">&quot;http://localhost:8081&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;desc&quot;</span>: <span class="string">&quot;测试使用&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;readTimeout&quot;</span>: <span class="string">&quot;10000&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;connectTimeout&quot;</span>: <span class="string">&quot;10000&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;test1&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;domain&quot;</span>: <span class="string">&quot;127.0.0.1:8080&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置中可以存在多个KV。</p>
<ul>
<li><strong>domain</strong>：HTTP请求的基础域名，同时可指定为IP地址。<strong>必填。</strong></li>
<li><strong>desc</strong>：功能描述，无其他用处。</li>
<li><strong>readTimeout</strong>：读取超时时间(ms)。对应<code>Retrofit2</code>中的readTimeout。<strong>缺省5000ms。</strong></li>
<li><strong>connectTimeout</strong>：连接超时时间(ms)，对应<code>Retrofit2</code>中的connectTimeout。<strong>缺省5000ms。</strong></li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>示例中用的是SendHttp测试接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RetrofitConfig(value = &quot;sendHttp&quot;, desc = &quot;测试&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SendHttp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST(&quot;/callback&quot;)</span></span><br><span class="line">    <span class="function">Student <span class="title">getResult</span><span class="params">(<span class="meta">@Body</span> Student student)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回为void类型时需写为Void</span></span><br><span class="line">  <span class="meta">@POST(&quot;/update&quot;)</span></span><br><span class="line">    <span class="function">Void <span class="title">update</span><span class="params">(<span class="meta">@Body</span> Student student)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点说一下**@RetrofitConfig**注解。此注解为自定义注解，其中：</p>
<ul>
<li><strong>value</strong>：对应的是基础配置中的Key。</li>
<li><strong>desc</strong>：描述。</li>
</ul>
<p>其余注解和使用与<code>retrofit2</code>一致，使用<code>retrofit2</code>中注解即可。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>在<em>service</em>层或<em>manager</em>层直接注入配置完成的所需接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SendHttp sendHttp;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义rest代理(一)</title>
    <url>/%E8%87%AA%E5%AE%9A%E4%B9%89rest%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在项目中可能我们会调用其他的rest接口，我们会写一个<code>HttpClientSender</code>工具类，返回后然后一大堆的条件判断，既繁琐又不直观。我们可以运用所学的<code>FactoryBean</code>手写一个<strong>rest代理</strong>，使用时可以像Mybatis那样注入接口就可以，方便又简洁。<div align=center><img width="220" height="220" src="../../../../images/2019/1-3/restful.png" algin="center"/></div></p>
<p>此工具类是依据<code>HttpClient</code>编写的。灵活性比较高，代码量也是比较多，还是有一些局限性，比如请求方法只支持GET、POST、PUT、DELETE等。</p>
<h1 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h1><p>使用<code>FactoryBean</code>来动态获取代理对象，这里我们定义一个<code>RestServiceProxyFactoryBean&lt;T&gt;</code>实现<code>FactoryBean</code>接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> max</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestServiceProxyFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RestServiceProxyFactory路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> RestServiceProxyFactory factory;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> factory.newRestServiceProxy(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RestServiceProxyFactoryBean</code>有两个参数：</p>
<ol>
<li><strong>RestServiceProxyFactory</strong>：创建代理对象的factory，下面会说到。</li>
<li><strong>type</strong>：接口所在路径。</li>
</ol>
<h1 id="代理工厂RestServiceProxyFactory"><a href="#代理工厂RestServiceProxyFactory" class="headerlink" title="代理工厂RestServiceProxyFactory"></a>代理工厂RestServiceProxyFactory</h1><p>当程序调用rest接口时，会由代理工厂根据各种配置生成代理对象并填充返回结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> max</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestServiceProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> RestClient restClient = <span class="keyword">new</span> RestClient();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConfigManager configManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置文件路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RestServiceProxyFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        configManager = ServiceConfigManager.build(location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">newRestServiceProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Reflection.newProxy(clazz, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">                    <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (method.isDefault()) &#123;</span><br><span class="line">                    MethodHandle methodHandler = RestServiceProxyFactory.<span class="keyword">this</span>.getMethodHandler(method);</span><br><span class="line">                    <span class="keyword">return</span> methodHandler.bindTo(proxy).invokeWithArguments(args);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                InvokeParams invokeParams = InvokeParams.getInstance(configManager, method, args);</span><br><span class="line"></span><br><span class="line">                Object ret = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ret = restClient.invoke(invokeParams);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> MethodHandle <span class="title">getMethodHandler</span><span class="params">(Method method)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InstantiationException, java.lang.reflect.InvocationTargetException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Constructor&lt;MethodHandles.Lookup&gt; constructor = MethodHandles.Lookup.class</span><br><span class="line">                .getDeclaredConstructor(Class.class, <span class="keyword">int</span>.class);</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">        <span class="keyword">int</span> allModes = (MethodHandles.Lookup.PUBLIC | MethodHandles.Lookup.PRIVATE | MethodHandles.Lookup.PROTECTED | MethodHandles.Lookup.PACKAGE);</span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance(declaringClass, allModes)</span><br><span class="line">                .unreflectSpecial(method, declaringClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址"></a>开源地址</h1><p>由代理对象根据配置可以调用HTTP请求反序列化并封装返回结果，这样就不需要自己做其他的工作。项目已经更新到我的GitHub：<a href="https://github.com/mx-go/rest-proxy">https://github.com/mx-go/rest-proxy</a>，<strong>READM</strong>中有使用方法。打成jar放到自己的项目中即可使用。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>计算密集型 VS IO密集型</title>
    <url>/%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B-VS-IO%E5%AF%86%E9%9B%86%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>　　在开发过程中，经常会遇到多线程的问题，解决多线程的其中一种方式就是利用线程池，其中需要开启线程的数量便成为了我们关注的焦点。JAVA中有两种并发类型：<strong>计算密集型（CUP-bound）</strong>和<strong>IO密集型（I/O-bound）</strong>。<span id="more"></span></p>
<h1 id="计算密集型（CPU-bound）"><a href="#计算密集型（CPU-bound）" class="headerlink" title="计算密集型（CPU-bound）"></a>计算密集型（CPU-bound）</h1><p>　　计算密集型，顾名思义就是应用需要非常多的CPU计算资源，CPU大部份时间用来做计算、逻辑判断等CPU动作的程序称之CPU bound。在多核CPU时代，我们要让每一个CPU核心都参与计算，将CPU的性能充分利用起来，这样才算是没有浪费服务器配置，如果在非常好的服务器配置上还运行着单线程程序，那将是非常大的浪费。对于计算密集型的应用，完全是靠CPU的核数来工作，所以为了让它的优势完全发挥出来，避免过多的上下文切换，比较理性的方案是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">线程数 = CPU核数 + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>为什么是 +1？<strong>因为即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费。</strong></p>
<blockquote>
<p>也可以设置成CPU核数 x 2，这还是要看JDK的使用版本，以及CPU配置(服务器的CPU有超线程)。对于JDK1.8来说，里面增加了一个并行计算，计算密集型的较理想线程数 = CPU内核线程数 x 2</p>
</blockquote>
<p>以下是一个计算文件夹大小的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算文件夹大小</span></span><br><span class="line"><span class="comment"> * ClassName: FileSizeCalc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSizeCalc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SubDirsAndSize</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> size;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">final</span> List&lt;File&gt; subDirs;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">SubDirsAndSize</span><span class="params">(<span class="keyword">long</span> size, List&lt;File&gt; subDirs)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.size = size;</span><br><span class="line">			<span class="keyword">this</span>.subDirs = Collections.unmodifiableList(subDirs);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> SubDirsAndSize <span class="title">getSubDirsAndSize</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">		List&lt;File&gt; subDirs = <span class="keyword">new</span> ArrayList&lt;File&gt;();</span><br><span class="line">		<span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">			File[] children = file.listFiles();</span><br><span class="line">			<span class="keyword">if</span> (children != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (File child : children) &#123;</span><br><span class="line">					<span class="keyword">if</span> (child.isFile())</span><br><span class="line">						total += child.length();</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						subDirs.add(child);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SubDirsAndSize(total, subDirs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getFileSize</span><span class="params">(File file)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> cpuCore = Runtime.getRuntime().availableProcessors();</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> poolSize = cpuCore + <span class="number">1</span>;</span><br><span class="line">		ExecutorService service = Executors.newFixedThreadPool(poolSize);</span><br><span class="line">		<span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">		List&lt;File&gt; directories = <span class="keyword">new</span> ArrayList&lt;File&gt;();</span><br><span class="line">		directories.add(file);</span><br><span class="line">		SubDirsAndSize subDirsAndSize = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (!directories.isEmpty()) &#123;</span><br><span class="line">				List&lt;Future&lt;SubDirsAndSize&gt;&gt; partialResults = <span class="keyword">new</span> ArrayList&lt;Future&lt;SubDirsAndSize&gt;&gt;();</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">final</span> File directory : directories) &#123;</span><br><span class="line">					partialResults.add(service.submit(<span class="keyword">new</span> Callable&lt;SubDirsAndSize&gt;() &#123;</span><br><span class="line">						<span class="meta">@Override</span></span><br><span class="line">						<span class="function"><span class="keyword">public</span> SubDirsAndSize <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">							<span class="keyword">return</span> getSubDirsAndSize(directory);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;));</span><br><span class="line">				&#125;</span><br><span class="line">				directories.clear();</span><br><span class="line">				<span class="keyword">for</span> (Future&lt;SubDirsAndSize&gt; partialResultFuture : partialResults) &#123;</span><br><span class="line">					subDirsAndSize = partialResultFuture.get(<span class="number">100</span>, TimeUnit.SECONDS);</span><br><span class="line">					total += subDirsAndSize.size;</span><br><span class="line">					directories.addAll(subDirsAndSize.subDirs);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> total;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			service.shutdown();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">			<span class="keyword">long</span> total = <span class="keyword">new</span> FileSizeCalc().getFileSize(<span class="keyword">new</span> File(<span class="string">&quot;D:/DevTools&quot;</span>));</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">			System.out.format(<span class="string">&quot;文件夹大小: %dMB%n&quot;</span>, total / (<span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">			System.out.format(<span class="string">&quot;所用时间: %.3fs%n&quot;</span>, (end - start) / <span class="number">1.0e3</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">文件夹大小: 15987MB</span><br><span class="line">所用时间: <span class="number">2.</span>005s</span><br><span class="line">文件夹大小: 15987MB</span><br><span class="line">所用时间: <span class="number">1.</span>879s</span><br><span class="line">文件夹大小: 15987MB</span><br><span class="line">所用时间: <span class="number">2.</span>142s</span><br><span class="line">文件夹大小: 15987MB</span><br><span class="line">所用时间: <span class="number">2.</span>089s</span><br><span class="line">文件夹大小: 15987MB</span><br><span class="line">所用时间: <span class="number">1.</span>996s</span><br><span class="line">文件夹大小: 15987MB</span><br><span class="line">所用时间: <span class="number">2.</span>258s</span><br><span class="line">文件夹大小: 15987MB</span><br><span class="line">所用时间: <span class="number">2.</span>198s</span><br><span class="line">文件夹大小: 15987MB</span><br><span class="line">所用时间: <span class="number">1.</span>968s</span><br><span class="line">文件夹大小: 15987MB</span><br><span class="line">所用时间: <span class="number">2.</span>105s</span><br><span class="line">文件夹大小: 15987MB</span><br><span class="line">所用时间: <span class="number">2.</span>071s</span><br></pre></td></tr></table></figure>

<p>　　在上面的例子中，线程池设置为<em><strong>CPU核心数  + 1</strong></em>个，结果如上图。如果在这里把线程池加大，比如调到100，会发现所用的时间变多了。虽然增加的时间不是太多，但是对于CPU来说可是相当长的，因为CPU里面是以纳秒为计算单位，1毫秒=1000000纳秒。所以加大线程池会增加CPU上下文的切换成本，有时程序的优化就是从这些微小的地方积累起来的。</p>
<h1 id="I-O密集型（I-O-bound）"><a href="#I-O密集型（I-O-bound）" class="headerlink" title="I/O密集型（I/O-bound）"></a>I/O密集型（I/O-bound）</h1><p>　　对于IO密集型的应用，就很好理解了，现在做的开发大部分都是WEB应用，涉及到大量的网络传输，不仅如此，<strong>与数据库、缓存（网络、磁盘）间的交互也涉及到IO，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。一旦发生IO，线程就会处于等待状态，当IO结束，数据准备好后，线程才会继续执行。因此从这里可以发现，对于IO密集型的应用，可以多设置一些线程池中线程的数量，这样就能让在等待IO的这段时间内，线程可以去做其它事，提高并发处理效率。</strong><br>　　那么这个线程池的数据量是不是可以随便设置呢？当然不是的，一定要记得，线程上下文切换是有代价的。目前总结了一套公式，对于IO密集型应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">线程数 = CPU核心数/(<span class="number">1</span>-阻塞系数)</span><br></pre></td></tr></table></figure>

<p>　　这个阻塞系数一般为<em>0.8~0.9</em>之间，也可以取<em>0.8</em>或者<em>0.9</em>。套用公式，对于双核CPU来说，它比较理想的线程数就是20，当然这都不是绝对的，需要根据实际情况以及实际业务来调整。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> poolSize = (<span class="keyword">int</span>) (cpuCore / (<span class="number">1</span> - <span class="number">0.9</span>));</span><br></pre></td></tr></table></figure>

<p><a href="http://www.blogjava.net/bolo/archive/2015/01/20/422296.html"><em>浅谈Java两种并发类型——计算密集型与IO密集型</em></a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>设计合理的架构</title>
    <url>/%E8%AE%BE%E8%AE%A1%E5%90%88%E7%90%86%E7%9A%84%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="架构师职责"><a href="#架构师职责" class="headerlink" title="架构师职责"></a><a href="https://www.mubucm.com/doc/5jhFgPTD_Zp">架构师职责</a></h1><mark class="hl-label red">架构师是业务与技术之间的桥梁。</mark> 

<h2 id="核心能力"><a href="#核心能力" class="headerlink" title="核心能力"></a>核心能力</h2><ul>
<li>判断-确定性思维</li>
<li>拆解-创造性思维</li>
<li>取舍-系统性思维</li>
</ul>
<h2 id="主要职责"><a href="#主要职责" class="headerlink" title="主要职责"></a>主要职责</h2><h3 id="架构设计前期"><a href="#架构设计前期" class="headerlink" title="架构设计前期"></a>架构设计前期</h3><ul>
<li>澄清不确定性</li>
<li>识别复杂需求</li>
<li>与业务方交流</li>
<li>与利益干系人交流</li>
<li>业务架构图</li>
<li>核心场景流程</li>
</ul>
<h3 id="架构设计中期"><a href="#架构设计中期" class="headerlink" title="架构设计中期"></a>架构设计中期</h3><ul>
<li>选择、设计备选方案</li>
<li>架构小组讨论</li>
<li>方案评估</li>
<li>方案汇报</li>
</ul>
<h3 id="架构设计后期"><a href="#架构设计后期" class="headerlink" title="架构设计后期"></a>架构设计后期</h3><ul>
<li>细化架构</li>
<li>完善架构</li>
<li>写文档</li>
<li>架构宣讲</li>
<li>最终的架构文档</li>
</ul>
<div align=center><img src="../../../../images/2022/1-3/3.1_architect_ responsibilities.png" algin="center"/></div>

<h1 id="架构设计前期-1"><a href="#架构设计前期-1" class="headerlink" title="架构设计前期"></a><a href="https://www.mubucm.com/doc/2SasZqNwyZp">架构设计前期</a></h1><div align=center><img src="../../../../images/2022/1-3/3.2_arch_prophase.png" algin="center"/></div>

<h1 id="架构设计中期-1"><a href="#架构设计中期-1" class="headerlink" title="架构设计中期"></a><a href="https://www.mubucm.com/doc/7FhHnbjLDdp">架构设计中期</a></h1><div align=center><img src="../../../../images/2022/1-3/3.3_arch_metaphase.png" algin="center"/></div>

<h1 id="架构设计后期-1"><a href="#架构设计后期-1" class="headerlink" title="架构设计后期"></a><a href="https://www.mubucm.com/doc/2C5tQ9wHvdp">架构设计后期</a></h1><h2 id="架构设计文档"><a href="#架构设计文档" class="headerlink" title="架构设计文档"></a>架构设计文档</h2><ol>
<li>业务背景</li>
<li>约束&amp;限制</li>
<li>总体架构设计</li>
<li>详细架构设计</li>
<li>架构质量设计</li>
<li>架构演进规则</li>
</ol>
<h2 id="详细架构设计"><a href="#详细架构设计" class="headerlink" title="详细架构设计"></a>详细架构设计</h2><ul>
<li>架构规范</li>
<li>架构质量</li>
</ul>
<div align=center><img src="../../../../images/2022/1-3/3.4_arch_anaphase.png" algin="center"/></div>
]]></content>
      <categories>
        <category>架构</category>
        <category>设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>详解MongoDB执行计划</title>
    <url>/%E8%AF%A6%E8%A7%A3MongoDB%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在RDBMS(Relational Database Management System)中，无论哪种数据库，都提供了SQL剖析工具，用来解决SQL效率低下的问题。在MongoDB中，也有相应的策略来实现剖析。MongoDB提供了**db.collection.explain()<strong>、</strong>cursor.explain()**方法和<code>explain</code>命令返回查询计划信息和查询计划的执行统计信息。<div align=center><img width="420" height="220" src="../../../../images/2019/4-6/MongoDB-explain.png" algin="center"/></div><span id="more"></span></p>
<h1 id="db-collection-explain-简介"><a href="#db-collection-explain-简介" class="headerlink" title="db.collection.explain()简介"></a>db.collection.explain()简介</h1><h2 id="支持的操作"><a href="#支持的操作" class="headerlink" title="支持的操作"></a>支持的操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aggregate(); count(); distinct(); find(); group(); remove(); update() </span><br><span class="line"></span><br><span class="line">cursor.explain(verbosity) 为一个游标返回其查询执行计划(Reports on the query execution plan for a cursor)</span><br><span class="line">cursor.explain(verbosity) 最通常的行式为db.collection.find().explain()。其中verbosity说明返回信息的粒度。</span><br></pre></td></tr></table></figure>

<p><strong>explain()写操作(remove和update)时，返回是删除和更新操作的信息，并不将修改应用至数据库。</strong></p>
<p>通过<code>db.collection.explain().help()</code>可以获取支持的操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.collection.explain().help()</span><br><span class="line">Explainable operations</span><br><span class="line">	.aggregate(...) <span class="operator">-</span> explain an aggregation operation</span><br><span class="line">	.<span class="built_in">count</span>(...) <span class="operator">-</span> explain a count operation</span><br><span class="line">	.<span class="keyword">distinct</span>(...) <span class="operator">-</span> explain a <span class="keyword">distinct</span> operation</span><br><span class="line">	.find(...) <span class="operator">-</span> <span class="keyword">get</span> an explainable query</span><br><span class="line">	.findAndModify(...) <span class="operator">-</span> explain a findAndModify operation</span><br><span class="line">	.<span class="keyword">group</span>(...) <span class="operator">-</span> explain a <span class="keyword">group</span> operation</span><br><span class="line">	.remove(...) <span class="operator">-</span> explain a remove operation</span><br><span class="line">	.update(...) <span class="operator">-</span> explain an update operation</span><br><span class="line">Explainable collection methods</span><br><span class="line">	.getCollection()</span><br><span class="line">	.getVerbosity()</span><br><span class="line">	.setVerbosity(verbosity)</span><br></pre></td></tr></table></figure>

<h2 id="执行模式"><a href="#执行模式" class="headerlink" title="执行模式"></a>执行模式</h2><p><strong>db.collection.find().explain(<em>verbose</em>)</strong></p>
<ul>
<li>explain(）输出一个以文档形式展现的执行计划，可以包括统计信息(可选)。</li>
<li>verbose：可选参数。<strong>缺省值为queryPlanner</strong>，用于查看指定执行计划的特定部分。即给定不同的参数则输出信息的详细程度不同。常用的有<strong>queryPlanner</strong>、<strong>executionStats</strong>、<strong>allPlansExecution。</strong></li>
</ul>
<h3 id="queryPlanner"><a href="#queryPlanner" class="headerlink" title="queryPlanner"></a>queryPlanner</h3><p><strong>缺省模式</strong>。MongoDB运行查询优化器对当前的查询进行评估并选择一个最佳的查询计划。</p>
<h3 id="executionStats"><a href="#executionStats" class="headerlink" title="executionStats"></a>executionStats</h3><p>MongoDB运行查询优化器对当前的查询进行评估并选择一个最佳的查询计划进行执行。在执行完毕后返回这个最佳执行计划执行完成时的相关统计信息。<strong>对于写操作db.collection.explain()返回关于更新和删除操作的信息，但是并不将修改应用到数据库</strong>。对于那些被拒绝的执行计划(<code>rejectedPlans</code>)，不返回其统计信息。</p>
<h3 id="allPlansExecution"><a href="#allPlansExecution" class="headerlink" title="allPlansExecution"></a>allPlansExecution</h3><p>该模式是前2种模式的更细化，即会包括上述2种模式的所有信息。<br>即按照最佳的执行计划执行以及列出统计信息，而且还会列出一些候选的执行计划。<br>如果有多个查询计划，<code>executionStats</code>信息包括这些执行计划的部分统计信息。</p>
<h1 id="相关用法"><a href="#相关用法" class="headerlink" title="相关用法"></a>相关用法</h1><p>先在集合中插入一条数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; db.student.insert(&#123;&quot;age&quot; : 90.0,&quot;name&quot; : &quot;rainbowhorse&quot;,&quot;score&quot; : 90.0,&quot;sex&quot; : &quot;M&quot;&#125;);</span><br><span class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="演示db-collection-explain-update"><a href="#演示db-collection-explain-update" class="headerlink" title="演示db.collection.explain().update()"></a>演示db.collection.explain().update()</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.student.explain(&quot;allPlansExecution&quot;).update(&#123;&quot;name&quot;:&quot;rainbowhorse&quot;&#125;,&#123;$<span class="keyword">set</span>:&#123;&quot;score&quot;:<span class="number">99</span>&#125;&#125;);</span><br><span class="line">&#123;</span><br><span class="line">	&quot;queryPlanner&quot; : &#123;</span><br><span class="line">		&quot;plannerVersion&quot; : <span class="number">1</span>,</span><br><span class="line">		&quot;namespace&quot; : &quot;TEST.student&quot;,</span><br><span class="line">		&quot;indexFilterSet&quot; : <span class="literal">false</span>,</span><br><span class="line">		&quot;parsedQuery&quot; : &#123;</span><br><span class="line">			&quot;name&quot; : &#123;</span><br><span class="line">				&quot;$eq&quot; : &quot;rainbowhorse&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;winningPlan&quot; : &#123;</span><br><span class="line">			&quot;stage&quot; : &quot;UPDATE&quot;,</span><br><span class="line">			&quot;inputStage&quot; : &#123;</span><br><span class="line">				&quot;stage&quot; : &quot;COLLSCAN&quot;,</span><br><span class="line">				&quot;filter&quot; : &#123;</span><br><span class="line">					&quot;name&quot; : &#123;</span><br><span class="line">						&quot;$eq&quot; : &quot;rainbowhorse&quot;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				&quot;direction&quot; : &quot;forward&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;rejectedPlans&quot; : [ ]</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;executionStats&quot; : &#123;</span><br><span class="line">		&quot;executionSuccess&quot; : <span class="literal">true</span>,</span><br><span class="line">		&quot;nReturned&quot; : <span class="number">0</span>,</span><br><span class="line">		&quot;executionTimeMillis&quot; : <span class="number">0</span>,</span><br><span class="line">		&quot;totalKeysExamined&quot; : <span class="number">0</span>,</span><br><span class="line">		&quot;totalDocsExamined&quot; : <span class="number">11</span>,</span><br><span class="line">		&quot;executionStages&quot; : &#123;</span><br><span class="line">			&quot;stage&quot; : &quot;UPDATE&quot;,</span><br><span class="line">			&quot;nReturned&quot; : <span class="number">0</span>,</span><br><span class="line">			&quot;executionTimeMillisEstimate&quot; : <span class="number">0</span>,</span><br><span class="line">			&quot;works&quot; : <span class="number">13</span>,</span><br><span class="line">			&quot;advanced&quot; : <span class="number">0</span>,</span><br><span class="line">			&quot;needTime&quot; : <span class="number">12</span>,</span><br><span class="line">			&quot;needYield&quot; : <span class="number">0</span>,</span><br><span class="line">			&quot;saveState&quot; : <span class="number">0</span>,</span><br><span class="line">			&quot;restoreState&quot; : <span class="number">0</span>,</span><br><span class="line">			&quot;isEOF&quot; : <span class="number">1</span>,</span><br><span class="line">			&quot;invalidates&quot; : <span class="number">0</span>,</span><br><span class="line">			&quot;nMatched&quot; : <span class="number">1</span>,</span><br><span class="line">			&quot;nWouldModify&quot; : <span class="number">1</span>,</span><br><span class="line">			&quot;nInvalidateSkips&quot; : <span class="number">0</span>,</span><br><span class="line">			&quot;wouldInsert&quot; : <span class="literal">false</span>,</span><br><span class="line">			&quot;fastmodinsert&quot; : <span class="literal">false</span>,</span><br><span class="line">			&quot;inputStage&quot; : &#123;</span><br><span class="line">				&quot;stage&quot; : &quot;COLLSCAN&quot;,</span><br><span class="line">				&quot;filter&quot; : &#123;</span><br><span class="line">					&quot;name&quot; : &#123;</span><br><span class="line">						&quot;$eq&quot; : &quot;rainbowhorse&quot;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				&quot;nReturned&quot; : <span class="number">1</span>,</span><br><span class="line">				&quot;executionTimeMillisEstimate&quot; : <span class="number">0</span>,</span><br><span class="line">				&quot;works&quot; : <span class="number">12</span>,</span><br><span class="line">				&quot;advanced&quot; : <span class="number">1</span>,</span><br><span class="line">				&quot;needTime&quot; : <span class="number">11</span>,</span><br><span class="line">				&quot;needYield&quot; : <span class="number">0</span>,</span><br><span class="line">				&quot;saveState&quot; : <span class="number">1</span>,</span><br><span class="line">				&quot;restoreState&quot; : <span class="number">1</span>,</span><br><span class="line">				&quot;isEOF&quot; : <span class="number">0</span>,</span><br><span class="line">				&quot;invalidates&quot; : <span class="number">0</span>,</span><br><span class="line">				&quot;direction&quot; : &quot;forward&quot;,</span><br><span class="line">				&quot;docsExamined&quot; : <span class="number">11</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;allPlansExecution&quot; : [ ]</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;serverInfo&quot; : &#123;</span><br><span class="line">		&quot;host&quot; : &quot;rainbowhorse&quot;,</span><br><span class="line">		&quot;port&quot; : <span class="number">27017</span>,</span><br><span class="line">		&quot;version&quot; : &quot;4.0.3&quot;,</span><br><span class="line">		&quot;gitVersion&quot; : &quot;7ea530946fa7880364d88c8d8b6026bbc9ffa48c&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;ok&quot; : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次查看文档，文档并没有被更新。正如前文所述，该方式并不将修改应用到数据库。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.student.find(&#123;&quot;name&quot;:&quot;rainbowhorse&quot;&#125;);</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5cbbd841525ed310c440610a&quot;), &quot;age&quot; : <span class="number">90</span>, &quot;name&quot; : &quot;rainbowhorse&quot;, &quot;score&quot; : <span class="number">90</span>, &quot;sex&quot; : &quot;M&quot; &#125;</span><br></pre></td></tr></table></figure>

<p>注意：将explain()放置到update()之后则会提示错误。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.student.update(&#123;&quot;name&quot;:&quot;rainbowhorse&quot;&#125;,&#123;$<span class="keyword">set</span>:&#123;&quot;score&quot;:<span class="number">99</span>&#125;&#125;).explain(&quot;allPlansExecution&quot;);</span><br><span class="line"><span class="number">2019</span><span class="number">-04</span><span class="number">-21</span>T10:<span class="number">53</span>:<span class="number">40.824</span><span class="operator">+</span><span class="number">0800</span> E QUERY    [js] TypeError: db.student.update(...).explain <span class="keyword">is</span> <span class="keyword">not</span> a <span class="keyword">function</span> :</span><br><span class="line">@(shell):<span class="number">1</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>在执行计划中，部分操作符需要放至<code>explain()</code>之前，部分需要放到<code>explain()</code>之后才能正确执行。</p>
<p>聚合查询中使用：<code>collection.explain().aggregate(...)</code></p>
<h2 id="执行计划相关描述"><a href="#执行计划相关描述" class="headerlink" title="执行计划相关描述"></a>执行计划相关描述</h2><p>缺省情况下，explain包括2个部分，<code>queryPlanner</code>和<code>serverInfo</code>。如果使用了<code>executionStats</code>或者<code>allPlansExecution</code>，则还会返回<code>executionStats</code>信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> db.student.find(&#123;&quot;name&quot;:&quot;rainbowhorse&quot;&#125;).explain(&quot;allPlansExecution&quot;);</span><br><span class="line">&#123;</span><br><span class="line">	&quot;queryPlanner&quot; : &#123;</span><br><span class="line">		&quot;plannerVersion&quot; : <span class="number">1</span>,		<span class="operator">/</span><span class="operator">/</span>查询计划版本</span><br><span class="line">		&quot;namespace&quot; : &quot;TEST.student&quot;,		<span class="operator">/</span><span class="operator">/</span>被查询对象</span><br><span class="line">		&quot;indexFilterSet&quot; : <span class="literal">false</span>,		<span class="operator">/</span><span class="operator">/</span>是否使用到了索引过滤</span><br><span class="line">		&quot;parsedQuery&quot; : &#123;			<span class="operator">/</span><span class="operator">/</span>解析查询，即过滤条件是什么</span><br><span class="line">			&quot;name&quot; : &#123;		<span class="operator">/</span><span class="operator">/</span>此处为name<span class="operator">=</span>rainbowhorse</span><br><span class="line">				&quot;$eq&quot; : &quot;rainbowhorse&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;winningPlan&quot; : &#123;		<span class="operator">/</span><span class="operator">/</span>最佳的执行计划</span><br><span class="line">			&quot;stage&quot; : &quot;COLLSCAN&quot;,		<span class="operator">/</span><span class="operator">/</span>COLLSCAN为集合扫描</span><br><span class="line">			&quot;filter&quot; : &#123;		<span class="operator">/</span><span class="operator">/</span>过滤条件</span><br><span class="line">				&quot;name&quot; : &#123;</span><br><span class="line">					&quot;$eq&quot; : &quot;rainbowhorse&quot;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;direction&quot; : &quot;forward&quot;		<span class="operator">/</span><span class="operator">/</span>方向：forward</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;rejectedPlans&quot; : [ ]		<span class="operator">/</span><span class="operator">/</span>拒绝的执行计划，此处没有</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;executionStats&quot; : &#123;		<span class="operator">/</span><span class="operator">/</span>执行计划相关统计信息</span><br><span class="line">		&quot;executionSuccess&quot; : <span class="literal">true</span>,		<span class="operator">/</span><span class="operator">/</span>执行成功的状态</span><br><span class="line">		&quot;nReturned&quot; : <span class="number">1</span>,		<span class="operator">/</span><span class="operator">/</span>返回结果集数目</span><br><span class="line">		&quot;executionTimeMillis&quot; : <span class="number">0</span>,		<span class="operator">/</span><span class="operator">/</span>执行所需的时间,毫秒</span><br><span class="line">		&quot;totalKeysExamined&quot; : <span class="number">0</span>,		<span class="operator">/</span><span class="operator">/</span>索引检查的时间</span><br><span class="line">		&quot;totalDocsExamined&quot; : <span class="number">11</span>,		<span class="operator">/</span><span class="operator">/</span>检查文档总数</span><br><span class="line">		&quot;executionStages&quot; : &#123;</span><br><span class="line">			&quot;stage&quot; : &quot;COLLSCAN&quot;,		<span class="operator">/</span><span class="operator">/</span>使用集合扫描方式</span><br><span class="line">			&quot;filter&quot; : &#123;		<span class="operator">/</span><span class="operator">/</span>过滤条件</span><br><span class="line">				&quot;name&quot; : &#123;</span><br><span class="line">					&quot;$eq&quot; : &quot;rainbowhorse&quot;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;nReturned&quot; : <span class="number">1</span>,		<span class="operator">/</span><span class="operator">/</span>返回结果集数目</span><br><span class="line">			&quot;executionTimeMillisEstimate&quot; : <span class="number">0</span>,		<span class="operator">/</span><span class="operator">/</span>预估的执行时间，毫秒</span><br><span class="line">			&quot;works&quot; : <span class="number">13</span>,		<span class="operator">/</span><span class="operator">/</span>工作单元数，一个查询会被派生为一些小的工作单元</span><br><span class="line">			&quot;advanced&quot; : <span class="number">1</span>,		<span class="operator">/</span><span class="operator">/</span>优先返回的结果数目</span><br><span class="line">			&quot;needTime&quot; : <span class="number">11</span>,</span><br><span class="line">			&quot;needYield&quot; : <span class="number">0</span>,</span><br><span class="line">			&quot;saveState&quot; : <span class="number">0</span>,</span><br><span class="line">			&quot;restoreState&quot; : <span class="number">0</span>,</span><br><span class="line">			&quot;isEOF&quot; : <span class="number">1</span>,</span><br><span class="line">			&quot;invalidates&quot; : <span class="number">0</span>,</span><br><span class="line">			&quot;direction&quot; : &quot;forward&quot;,</span><br><span class="line">			&quot;docsExamined&quot; : <span class="number">11</span>		<span class="operator">/</span><span class="operator">/</span>文档检查数目</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;allPlansExecution&quot; : [ ]</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;serverInfo&quot; : &#123;		<span class="operator">/</span><span class="operator">/</span>服务器信息，包括主机名，端口，版本等。</span><br><span class="line">		&quot;host&quot; : &quot;rainbowhorse&quot;,</span><br><span class="line">		&quot;port&quot; : <span class="number">27017</span>,</span><br><span class="line">		&quot;version&quot; : &quot;4.0.3&quot;,</span><br><span class="line">		&quot;gitVersion&quot; : &quot;7ea530946fa7880364d88c8d8b6026bbc9ffa48c&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;ok&quot; : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更详细的描述可以参考官方文档：<a href="https://docs.mongodb.com/manual/reference/explain-results/#executionstats">https://docs.mongodb.com/manual/reference/explain-results/#executionstats</a></p>
<h3 id="Stage状态分析"><a href="#Stage状态分析" class="headerlink" title="Stage状态分析"></a>Stage状态分析</h3><table>
<thead>
<tr>
<th align="center"><strong>stage</strong></th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">COLLSCAN</td>
<td align="left">全表扫描</td>
</tr>
<tr>
<td align="center">IXSCAN</td>
<td align="left">扫描索引</td>
</tr>
<tr>
<td align="center">FETCH</td>
<td align="left">根据索引去检索指定document</td>
</tr>
<tr>
<td align="center">SHARD_MERGE</td>
<td align="left">将各个分片返回数据进行merge</td>
</tr>
<tr>
<td align="center">SORT</td>
<td align="left">表明在内存中进行了排序</td>
</tr>
<tr>
<td align="center">LIMIT</td>
<td align="left">使用limit限制返回数</td>
</tr>
<tr>
<td align="center">SKIP</td>
<td align="left">使用skip进行跳过</td>
</tr>
<tr>
<td align="center">IDHACK</td>
<td align="left">针对_id进行查询</td>
</tr>
<tr>
<td align="center">SHARDING_FILTER</td>
<td align="left">通过mongos对分片数据进行查询</td>
</tr>
<tr>
<td align="center">COUNT</td>
<td align="left">利用db.coll.explain().count()之类进行count运算</td>
</tr>
<tr>
<td align="center">COUNTSCAN</td>
<td align="left">count不使用Index进行count时的stage返回</td>
</tr>
<tr>
<td align="center">COUNT_SCAN</td>
<td align="left">count使用了Index进行count时的stage返回</td>
</tr>
<tr>
<td align="center">SUBPLA</td>
<td align="left">未使用到索引的$or查询的stage返回</td>
</tr>
<tr>
<td align="center">TEXT</td>
<td align="left">使用全文索引进行查询时候的stage返回</td>
</tr>
<tr>
<td align="center">PROJECTION</td>
<td align="left">限定返回字段时候stage的返回</td>
</tr>
</tbody></table>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$eq    =               <span class="string">&quot;=&quot;</span></span><br><span class="line">$gt   (greater than )  &gt;</span><br><span class="line">$gte                   &gt;=  (equal)</span><br><span class="line">$lt   (less than)      &lt;</span><br><span class="line">$lte                   &lt;=  (equal)</span><br><span class="line">$ne   (not equal)      !=</span><br><span class="line">$in                    <span class="keyword">in</span></span><br><span class="line">$nin  (not <span class="keyword">in</span>)         !<span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">重点：所有的比较运算符都是出现在键与值得中间，示例如下</span><br><span class="line">&#123; &lt;field_name&gt;: &#123; <span class="attr">$operator</span>: &lt;value&gt; &#125; &#125;</span><br><span class="line">&#123; &lt;ename&gt;: &#123; <span class="attr">$eq</span>: <span class="string">&quot;robin&quot;</span> &#125; &#125;</span><br><span class="line">&#123; &lt;qty&gt;: &#123; <span class="attr">$gt</span>: <span class="number">20</span> &#125; &#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.voidcn.com/article/p-gxwefchh-bgt.html">MongoDB执行计划获取(db.collection.explain())</a></p>
<p><a href="https://docs.mongodb.com/manual/reference/explain-results/#executionstats">https://docs.mongodb.com/manual/reference/explain-results/#executionstats</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>详解Tomcat连接池与连接数</title>
    <url>/%E8%AF%A6%E8%A7%A3Tomcat%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%B8%8E%E8%BF%9E%E6%8E%A5%E6%95%B0/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在使用Tomcat时，经常会遇到连接数、线程数之类的配置，然后自己就去谷歌、百度，没有真正理解Tomcat配置的作用及当前业务环境、服务器配置等情况下Tomcat最优配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">maxThreads</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minSpareThreads</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">		   <span class="attr">maxSpareThreads</span>=<span class="string">&quot;200&quot;</span> <span class="attr">acceptCount</span>=<span class="string">&quot;900&quot;</span> <span class="attr">enableLookups</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">		   <span class="attr">compression</span>=<span class="string">&quot;on&quot;</span> <span class="attr">compressionMinSize</span>=<span class="string">&quot;1024&quot;</span> <span class="attr">compressableMimeType</span>=<span class="string">&quot;text/html,text/xml,text/css,text/javascript&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> <span class="attr">URIEncoding</span>=<span class="string">&quot;UTF-8&quot;</span> <span class="attr">maxHttpHeaderSize</span>=<span class="string">&quot;8192&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="Tomcat连接器（Connector）"><a href="#Tomcat连接器（Connector）" class="headerlink" title="Tomcat连接器（Connector）"></a>Tomcat连接器（Connector）</h1><p>上一篇文章说到过Tomcat的配置文件server.xml ：Connector的主要功能，是<strong>接收连接请求</strong>，创建<strong>Request和Response对象用于和请求端交换数据</strong>；然后分配线程让Engine（也就是Servlet容器）来处理这个请求，并把产生的Request和Response对象传给Engine。当Engine处理完请求后，也会通过Connector将响应返回给客户端。</p>
<p>可以说，Servlet容器处理请求，是需要Connector进行调度和控制的，Connector是Tomcat处理请求的主干，因此Connector的配置和使用对Tomcat的性能有着重要的影响。这篇文将从Connector入手，讨论一些与Connector有关的重要问题，包括NIO/BIO模式、线程池、连接数等。</p>
<p>根据协议的不同，Connector可以分为HTTP Connector、AJP Connector等，在这篇文章我们只讨论HTTP Connector。</p>
<h1 id="BIO、NIO、APR"><a href="#BIO、NIO、APR" class="headerlink" title="BIO、NIO、APR"></a>BIO、NIO、APR</h1><h2 id="Connector的protocal"><a href="#Connector的protocal" class="headerlink" title="Connector的protocal"></a>Connector的protocal</h2><p>Connector在处理HTTP请求时，会使用不同的protocal。不同的Tomcat版本支持的protocal不同，其中最典型的protocol包括BIO、NIO和APR（Tomcat7中支持这3种，Tomcat8增加了对NIO2的支持，而到了Tomcat8.5和Tomcat9.0，则去掉了对BIO的支持）。</p>
<p>BIO是Blocking IO，顾名思义是阻塞的IO；NIO是Non-blocking IO，则是非阻塞的IO。而APR是Apache Portable Runtime，是Apache可移植运行库，利用本地库可以实现高可扩展性、高性能；Apr是在Tomcat上运行高并发应用的首选模式，但是需要安装apr、apr-utils、tomcat-native等包。</p>
<h2 id="指定protocal"><a href="#指定protocal" class="headerlink" title="指定protocal"></a>指定protocal</h2><p>Connector使用哪种protocol，可以通过**<code>&lt;connector&gt;</code>**元素中的protocol属性进行指定，也可以使用默认值。</p>
<p>指定的protocol取值及对应的协议如下：</p>
<ul>
<li>HTTP/1.1：默认值，使用的协议与Tomcat版本有关</li>
<li>org.apache.coyote.http11.Http11Protocol：BIO</li>
<li>org.apache.coyote.http11.Http11NioProtocol：NIO</li>
<li>org.apache.coyote.http11.Http11Nio2Protocol：NIO2</li>
<li>org.apache.coyote.http11.Http11AprProtocol：APR</li>
</ul>
<p>如果没有指定protocol，则使用默认值HTTP/1.1，其含义如下：在Tomcat7中，自动选取使用BIO或APR（如果找到APR需要的本地库，则使用APR，否则使用BIO）；在Tomcat8中，自动选取使用NIO或APR（如果找到APR需要的本地库，则使用APR，否则使用NIO）。</p>
<h2 id="BIO和NIO的不同"><a href="#BIO和NIO的不同" class="headerlink" title="BIO和NIO的不同"></a>BIO和NIO的不同</h2><p>无论是BIO，还是NIO，Connector处理请求的大致流程是一样的：</p>
<p>在accept队列中接收连接（当客户端向服务器发送请求时，如果客户端与OS完成三次握手建立了连接，则OS将该连接放入accept队列）；在连接中获取请求的数据，生成request；调用servlet容器处理请求；返回response。为了便于后面的说明，首先明确一下连接与请求的关系：连接是TCP层面的（传输层），对应socket；请求是HTTP层面的（应用层），必须依赖于TCP的连接实现；一个TCP连接中可能传输多个HTTP请求。</p>
<p>在BIO实现的Connector中，处理请求的主要实体是JIoEndpoint对象。JIoEndpoint维护了Acceptor和Worker：Acceptor接收socket，然后从Worker线程池中找出空闲的线程处理socket，如果worker线程池没有空闲线程，则Acceptor将阻塞。其中Worker是Tomcat自带的线程池，如果通过<Executor>配置了其他线程池，原理与Worker类似。</p>
<p>在NIO实现的Connector中，处理请求的主要实体是NIoEndpoint对象。NIoEndpoint中除了包含Acceptor和Worker外，还是用了Poller，处理流程如下图所示</p>
<div align=center><img width="600" height="200" src="../../../../images/2017-12-28/tomcat%E8%BF%9E%E6%8E%A5%E6%B1%A0/Nio.jpg"/>

</div>

<p>Acceptor接收socket后，不是直接使用Worker中的线程处理请求，而是先将请求发送给了Poller，而Poller是实现NIO的关键。Acceptor向Poller发送请求通过队列实现，使用了典型的生产者-消费者模式。在Poller中，维护了一个Selector对象；当Poller从队列中取出socket后，注册到该Selector中；然后通过遍历Selector，找出其中可读的socket，并使用Worker中的线程处理相应请求。与BIO类似，Worker也可以被自定义的线程池代替。</p>
<p>通过上述过程可以看出，在NIoEndpoint处理请求的过程中，无论是Acceptor接收socket，还是线程处理请求，使用的仍然是阻塞方式；但在“读取socket并交给Worker中的线程”的这个过程中，使用非阻塞的NIO实现，这是NIO模式与BIO模式的最主要区别（其他区别对性能影响较小，暂时略去不提）。而这个区别，在并发量较大的情形下可以带来Tomcat效率的显著提升：</p>
<p>目前大多数HTTP请求使用的是长连接（HTTP/1.1默认keep-alive为true），而长连接意味着，一个TCP的socket在当前请求结束后，如果没有新的请求到来，socket不会立马释放，而是等timeout后再释放。如果使用BIO，“读取socket并交给Worker中的线程”这个过程是阻塞的，也就意味着在socket等待下一个请求或等待释放的过程中，处理这个socket的工作线程会一直被占用，无法释放；因此Tomcat可以同时处理的socket数目不能超过最大线程数，性能受到了极大限制。而使用NIO，“读取socket并交给Worker中的线程”这个过程是非阻塞的，当socket在等待下一个请求或等待释放时，并不会占用工作线程，因此Tomcat可以同时处理的socket数目远大于最大线程数，并发性能大大提高。</p>
<h1 id="acceptCount、maxConnections、maxThreads参数"><a href="#acceptCount、maxConnections、maxThreads参数" class="headerlink" title="acceptCount、maxConnections、maxThreads参数"></a>acceptCount、maxConnections、maxThreads参数</h1><p>Tomcat处理请求的过程：在accept队列中接收连接（当客户端向服务器发送请求时，如果客户端与OS完成三次握手建立了连接，则OS将该连接放入accept队列）；在连接中获取请求的数据，生成request；调用servlet容器处理请求；返回response。</p>
<p>相对应的，Connector中的几个参数功能如下：</p>
<h2 id="acceptCount"><a href="#acceptCount" class="headerlink" title="acceptCount"></a>acceptCount</h2><p>accept队列的长度；当accept队列中连接的个数达到acceptCount时，队列满，进来的请求一律被拒绝。<em>默认值是100</em>。</p>
<h2 id="maxConnections"><a href="#maxConnections" class="headerlink" title="maxConnections"></a>maxConnections</h2><p>Tomcat在任意时刻接收和处理的最大连接数。当Tomcat接收的连接数达到maxConnections时，Acceptor线程不会读取accept队列中的连接；这时accept队列中的线程会一直阻塞着，直到Tomcat接收的连接数小于maxConnections。如果设置为-1，则连接数不受限制。</p>
<p><em>默认值与连接器使用的协议有关：NIO的默认值是10000，APR/native的默认值是8192，而BIO的默认值为maxThreads（如果配置了Executor，则默认值是Executor的maxThreads）。</em></p>
<p><em>在windows下，APR/native的maxConnections值会自动调整为设置值以下最大的1024的整数倍；如设置为2000，则最大值实际是1024。</em></p>
<h2 id="maxThreads"><a href="#maxThreads" class="headerlink" title="maxThreads"></a>maxThreads</h2><p>请求处理线程的最大数量。<em>默认值是200（Tomcat7和8都是的）</em>。如果该Connector绑定了Executor，这个值会被忽略，因为该Connector将使用绑定的Executor，而不是内置的线程池来执行任务。</p>
<p>maxThreads规定的是最大的线程数目，并不是实际running的CPU数量；实际上，maxThreads的大小比CPU核心数量要大得多。这是因为，处理请求的线程真正用于计算的时间可能很少，大多数时间可能在阻塞，如等待数据库返回数据、等待硬盘读写数据等。因此，在某一时刻，只有少数的线程真正的在使用物理CPU，大多数线程都在等待；因此线程数远大于物理核心数才是合理的。</p>
<p>换句话说，Tomcat通过使用比CPU核心数量多得多的线程数，可以使CPU忙碌起来，大大提高CPU的利用率。</p>
<h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><ol>
<li>maxThreads的设置既与应用的特点有关，也与服务器的CPU核心数量有关。通过前面介绍可以知道，maxThreads数量应该远大于CPU核心数量；而且CPU核心数越大，maxThreads应该越大；应用中CPU越不密集（IO越密集），maxThreads应该越大，以便能够充分利用CPU。当然，maxThreads的值并不是越大越好，如果maxThreads过大，那么CPU会花费大量的时间用于线程的切换，整体效率会降低。</li>
<li>maxConnections的设置与Tomcat的运行模式有关。如果tomcat使用的是BIO，那么maxConnections的值应该与maxThreads一致；如果tomcat使用的是NIO，那么类似于Tomcat的默认值，maxConnections值应该远大于maxThreads。</li>
<li>通过前面的介绍可以知道，虽然tomcat同时可以处理的连接数目是maxConnections，但服务器中可以同时接收的连接数为maxConnections+acceptCount 。acceptCount的设置，与应用在连接过高情况下希望做出什么反应有关系。如果设置过大，后面进入的请求等待时间会很长；如果设置过小，后面进入的请求立马返回connection refused。</li>
</ol>
<h1 id="线程池Executor"><a href="#线程池Executor" class="headerlink" title="线程池Executor"></a>线程池Executor</h1><p>Executor元素代表Tomcat中的线程池，可以由其他组件共享使用；要使用该线程池，组件需要通过Executor属性指定该线程池。</p>
<p>Executor是Service元素的内嵌元素。一般来说，使用线程池的是Connector组件；为了使Connector能使用线程池，Executor元素应该放在Connector前面。Executor与Connector的配置举例如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Executor</span> <span class="attr">name</span>=<span class="string">&quot;tomcatThreadPool&quot;</span> <span class="attr">namePrefix</span> =<span class="string">&quot;catalina-exec-&quot;</span> <span class="attr">maxThreads</span>=<span class="string">&quot;150&quot;</span> <span class="attr">minSpareThreads</span>=<span class="string">&quot;4&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">executor</span>=<span class="string">&quot;tomcatThreadPool&quot;</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> <span class="attr">acceptCount</span>=<span class="string">&quot;1000&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>Executor的主要属性包括：</p>
<ul>
<li>name：该线程池的标记</li>
<li>maxThreads：线程池中最大活跃线程数，默认值200（Tomcat7和8都是）</li>
<li>minSpareThreads：线程池中保持的最小线程数，最小值是25</li>
<li>maxIdleTime：线程空闲的最大时间，当空闲超过该值时关闭线程（除非线程数小于minSpareThreads），单位是ms，默认值60000（1分钟）</li>
<li>daemon：是否后台线程，默认值true</li>
<li>threadPriority：线程优先级，默认值5</li>
<li>namePrefix：线程名字的前缀，线程池中线程名字为：namePrefix+线程编号</li>
</ul>
<h1 id="查看当前状态"><a href="#查看当前状态" class="headerlink" title="查看当前状态"></a>查看当前状态</h1><p>上面介绍了Tomcat连接数、线程数的概念以及如何设置，下面说明如何查看服务器中的连接数和线程数。</p>
<p>查看服务器的状态，大致分为两种方案：</p>
<h2 id="jconsole工具"><a href="#jconsole工具" class="headerlink" title="jconsole工具"></a>jconsole工具</h2><p>现成的工具，如JDK自带的jconsole工具可以方便的查看线程信息（此外还可以查看CPU、内存、类、JVM基本信息等），Tomcat自带的manager，收费工具New Relic等。下图是jconsole查看线程信息的界面：</p>
<div align=center><img width="600" height="200" src="../../../../images/2017-12-28/tomcat%E8%BF%9E%E6%8E%A5%E6%B1%A0/jconsole.png"/>

</div>

<h2 id="Linux命令查看"><a href="#Linux命令查看" class="headerlink" title="Linux命令查看"></a>Linux命令查看</h2><p>假设Tomcat接收http请求的端口是8083，则可以使用如下语句查看连接情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">netstat –nat|grep <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<p>结果如下所示：</p>
<div align=center><img width="600" height="200" src="../../../../images/2017-12-28/tomcat%E8%BF%9E%E6%8E%A5%E6%B1%A0/net.png"/>

</div>

<p>可以看出，有一个连接处于listen状态，监听请求；除此之外，还有6个已经建立的连接（ESTABLISHED）和0个等待关闭的连接（CLOSE_WAIT）。</p>
<p>原文：</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;mid=2651479428&amp;idx=1&amp;sn=791fed1205da057aba77655aaac9d841&amp;chksm=bd2531fb8a52b8ed0066a8efc76d031ffb6e0d2099fb342129c307f78b4bf0581cbf3bbcb058&amp;mpshare=1&amp;scene=1&amp;srcid=1114Osu1mhmfSobleuByFbEC#rd">https://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;mid=2651479428&amp;idx=1&amp;sn=791fed1205da057aba77655aaac9d841&amp;chksm=bd2531fb8a52b8ed0066a8efc76d031ffb6e0d2099fb342129c307f78b4bf0581cbf3bbcb058&amp;mpshare=1&amp;scene=1&amp;srcid=1114Osu1mhmfSobleuByFbEC#rd</a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>tips</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>说说JSON和JSONP</title>
    <url>/%E8%AF%B4%E8%AF%B4JSON%E5%92%8CJSONP/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说到AJAX就会不可避免的面临两个问题，<strong>第一个是AJAX以何种格式来交换数据？第二个是跨域的需求如何解决？</strong>这两个问题目前都有不同的解决方案，比如数据可以用自定义字符串或者用XML来描述，跨域可以通过服务器端代理来解决。</p>
<p>JSON和JSONP虽然只有一个字母的差别，但其实他们根本不是一回事：JSON是一种数据交换格式，而JSONP是一种依靠开发人员的聪明才智创造出的一种<code>非官方跨域数据交互协议</code>。我们拿最近比较火的谍战片来打个比方，JSON是地下党们用来书写和交换情报的“暗号”，而JSONP则是把用暗号书写的情报传递给自己同志时使用的接头方式。看到没？一个是描述信息的格式，一个是信息传递双方约定的方法。<div align=center><img width="450" height="200" src="../../../../images/2018-01/JSON_JSONP/jsonp-json-with-padding.gif" algin="center"/></div><span id="more"></span></p>
<h1 id="什么是JSON"><a href="#什么是JSON" class="headerlink" title="什么是JSON"></a>什么是JSON</h1><p>前面简单说了一下，JSON是一种基于文本的数据交换方式，或者叫做数据描述格式，你是否该选用他首先肯定要关注它所拥有的优点。</p>
<h2 id="JSON的优点"><a href="#JSON的优点" class="headerlink" title="JSON的优点"></a>JSON的优点</h2><ol>
<li>基于纯文本，跨平台传递极其简单；</li>
<li>JavaScript原生支持，后台语言几乎全部支持；</li>
<li>轻量级数据格式，占用字符数量极少，特别适合互联网传递；</li>
<li>可读性较强，虽然比不上XML那么一目了然，但在合理的依次缩进之后还是很容易识别的；</li>
<li>容易编写和解析，当然前提是你要知道数据结构；</li>
</ol>
<p>JSON的缺点当然也有，但在作者看来实在是无关紧要的东西，所以不再单独说明。</p>
<h2 id="JSON的格式或者叫规则"><a href="#JSON的格式或者叫规则" class="headerlink" title="JSON的格式或者叫规则"></a>JSON的格式或者叫规则</h2><p>JSON能够以非常简单的方式来描述数据结构，XML能做的它都能做，因此在跨平台方面两者完全不分伯仲。</p>
<ol>
<li>JSON只有两种数据类型描述符，大括号{}和方括号[]，其余英文冒号:是映射符，英文逗号,是分隔符，英文双引号””是定义符。</li>
<li>大括号{}用来描述一组“不同类型的无序键值对集合”（每个键值对可以理解为OOP的属性描述），方括号[]用来描述一组“相同类型的有序数据集合”（可对应OOP的数组）。</li>
<li>上述两种集合中若有多个子项，则通过英文逗号,进行分隔。</li>
<li>键值对以英文冒号:进行分隔，并且建议键名都加上英文双引号””，以便于不同语言的解析。</li>
<li>JSON内部常用数据类型无非就是字符串、数字、布尔、日期、null 这么几个，字符串必须用双引号引起来，其余的都不用，日期类型比较特殊，这里就不展开讲述了，只是建议如果客户端没有按日期排序功能需求的话，那么把日期时间直接作为字符串传递就好，可以省去很多麻烦。</li>
</ol>
<h2 id="JSON的实例"><a href="#JSON的实例" class="headerlink" title="JSON的实例"></a>JSON的实例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 描述一个人</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Age&quot;</span>: <span class="number">32</span>,</span><br><span class="line">    <span class="string">&quot;Company&quot;</span>: <span class="string">&quot;IBM&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Engineer&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取这个人的信息</span></span><br><span class="line"><span class="keyword">var</span> personAge = person.Age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述几个人</span></span><br><span class="line"><span class="keyword">var</span> members = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Age&quot;</span>: <span class="number">32</span>,</span><br><span class="line">        <span class="string">&quot;Company&quot;</span>: <span class="string">&quot;IBM&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Engineer&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Age&quot;</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="string">&quot;Company&quot;</span>: <span class="string">&quot;Oracle&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Engineer&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Henry&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Age&quot;</span>: <span class="number">45</span>,</span><br><span class="line">        <span class="string">&quot;Company&quot;</span>: <span class="string">&quot;Microsoft&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Engineer&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取其中John的公司名称</span></span><br><span class="line"><span class="keyword">var</span> johnsCompany = members[<span class="number">1</span>].Company;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述一次会议</span></span><br><span class="line"><span class="keyword">var</span> conference = &#123;</span><br><span class="line">    <span class="string">&quot;Conference&quot;</span>: <span class="string">&quot;Future Marketing&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Date&quot;</span>: <span class="string">&quot;2012-6-1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Address&quot;</span>: <span class="string">&quot;Beijing&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Members&quot;</span>: </span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Age&quot;</span>: <span class="number">32</span>,</span><br><span class="line">            <span class="string">&quot;Company&quot;</span>: <span class="string">&quot;IBM&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Engineer&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Age&quot;</span>: <span class="number">20</span>,</span><br><span class="line">            <span class="string">&quot;Company&quot;</span>: <span class="string">&quot;Oracle&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Engineer&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Henry&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Age&quot;</span>: <span class="number">45</span>,</span><br><span class="line">            <span class="string">&quot;Company&quot;</span>: <span class="string">&quot;Microsoft&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Engineer&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取参会者Henry是否工程师</span></span><br><span class="line"><span class="keyword">var</span> henryIsAnEngineer = conference.Members[<span class="number">2</span>].Engineer;</span><br></pre></td></tr></table></figure>

<p>关于JSON，就说这么多，更多细节请在开发过程中查阅资料深入学习。</p>
<h1 id="什么是JSONP"><a href="#什么是JSONP" class="headerlink" title="什么是JSONP"></a>什么是JSONP</h1><h2 id="JSONP的产生"><a href="#JSONP的产生" class="headerlink" title="JSONP的产生"></a>JSONP的产生</h2><p>其实网上关于JSONP的讲解有很多，但却千篇一律，而且云里雾里，对于很多刚接触的人来讲理解起来有些困难，试着用自己的方式来阐释一下这个问题。</p>
<p>1、一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准；</p>
<p>2、不过我们又发现，Web页面上<code>调用js文件时则不受是否跨域的影响</code>（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>）；</p>
<p>3、于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理；</p>
<p>4、恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据；</p>
<p>5、这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。</p>
<p>6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。</p>
<p>7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。</p>
<h2 id="JSONP的客户端具体实现"><a href="#JSONP的客户端具体实现" class="headerlink" title="JSONP的客户端具体实现"></a>JSONP的客户端具体实现</h2><p>不管jQuery也好，extjs也罢，又或者是其他支持jsonp的框架，他们幕后所做的工作都是一样的，下面我来循序渐进的说明一下jsonp在客户端的实现：</p>
<p>1、我们知道，哪怕跨域js文件中的代码（当然指符合web脚本安全策略的），web页面也是可以无条件执行的。</p>
<p>远程服务器remoteserver.com根目录下有个remote.js文件代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="string">&#x27;我是远程文件&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>本地服务器localserver.com下有个jsonp.html页面代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://remoteserver.com/remote.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>毫无疑问，页面将会弹出一个提示窗体，显示跨域调用成功。</p>
<p>2、现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。</p>
<p>jsonp.html页面代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> localHandler = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&#x27;我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：&#x27;</span> + data.result);</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://remoteserver.com/remote.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>remote.js文件代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">localHandler(&#123;<span class="string">&quot;result&quot;</span>:<span class="string">&quot;我是远程js带来的数据&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>运行之后查看结果，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。很欣喜，跨域远程获取数据的目的基本实现了，但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。</p>
<p>3、聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端“我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。</p>
<p>看jsonp.html页面的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 得到航班信息查询结果后的回调函数</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> flightHandler = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&#x27;你查询的航班结果是：票价 &#x27;</span> + data.price + <span class="string">&#x27; 元，&#x27;</span> + <span class="string">&#x27;余票 &#x27;</span> + data.tickets + <span class="string">&#x27; 张。&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> url = <span class="string">&quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler&quot;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建script标签，设置其属性</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    script.setAttribute(<span class="string">&#x27;src&#x27;</span>, url);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 把script标签加入head，此时调用开始</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].appendChild(script); </span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。</p>
<p>我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。</p>
<p>OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">flightHandler(&#123;</span><br><span class="line">    <span class="string">&quot;code&quot;</span>: <span class="string">&quot;CA1998&quot;</span>,</span><br><span class="line">    <span class="string">&quot;price&quot;</span>: <span class="number">1780</span>,</span><br><span class="line">    <span class="string">&quot;tickets&quot;</span>: <span class="number">5</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！</p>
<p>4、到这里为止的话，相信你已经能够理解jsonp的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用。</p>
<p>什么？你用的是jQuery，想知道jQuery如何实现jsonp调用？好吧，那我就好人做到底，再给你一段jQuery使用jsonp的代码（我们依然沿用上面那个航班信息查询的例子，假定返回jsonp结果不变）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span> &gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">title</span>&gt;</span>Untitled Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">jquery.min.js</span>&quot;&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">     jQuery(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">             <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span></span><br><span class="line"><span class="javascript">             <span class="attr">async</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">             <span class="attr">url</span>: <span class="string">&quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&quot;</span>,</span></span><br><span class="line"><span class="javascript">             <span class="attr">dataType</span>: <span class="string">&quot;jsonp&quot;</span>,</span></span><br><span class="line"><span class="javascript">             <span class="attr">jsonp</span>: <span class="string">&quot;callback&quot;</span>,<span class="comment">//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)</span></span></span><br><span class="line"><span class="javascript">             <span class="attr">jsonpCallback</span>:<span class="string">&quot;flightHandler&quot;</span>,<span class="comment">//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写&quot;?&quot;，jQuery会自动为你处理数据</span></span></span><br><span class="line"><span class="javascript">             <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">json</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                 alert(<span class="string">&#x27;您查询到航班信息：票价： &#x27;</span> + json.price + <span class="string">&#x27; 元，余票： &#x27;</span> + json.tickets + <span class="string">&#x27; 张。&#x27;</span>);</span></span><br><span class="line"><span class="javascript">             &#125;,</span></span><br><span class="line"><span class="javascript">             <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                 alert(<span class="string">&#x27;fail&#x27;</span>);</span></span><br><span class="line"><span class="javascript">             &#125;</span></span><br><span class="line"><span class="javascript">         &#125;);</span></span><br><span class="line"><span class="javascript">     &#125;);</span></span><br><span class="line"><span class="javascript">     </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>是不是有点奇怪？为什么我这次没有写flightHandler这个函数呢？而且竟然也运行成功了！哈哈，这就是jQuery的功劳了，jquery在处理jsonp类型的ajax时（还是忍不住吐槽，虽然jquery也把jsonp归入了ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用，是不是很爽呀？</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1、ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装；</p>
<p>2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而<strong>jsonp的核心则是动态添加<code>&lt;script&gt;</code>标签来调用服务器提供的js脚本</strong>。</p>
<p>3、所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。</p>
<p>4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。</p>
<p>总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变着一点！</p>
<p>转自：<a href="http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html"><em>说说JSON和JSONP，也许你会豁然开朗，含jQuery用例</em></a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈敏捷开发</title>
    <url>/%E8%B0%88%E8%B0%88%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><strong>敏捷开发</strong>是一种从上个世纪九十年代开始逐渐引起广泛关注的一些新型软件开发方法，是一种<strong>应对快速变化的需求</strong>的一种软件开发能力。常言道：“<strong>天下武功，唯快不破</strong>”，此言用于形容“敏捷”的威力相当合适。敏捷意思为快，但敏捷思想不仅仅求快，它更多强调“<strong>多快好省</strong>”，产出得多，产出得快，产出得好，同时节省各种成本，既经济又实用。它们更强调<strong>程序员团队与业务专家之间的紧密协作</strong>、<strong>面对面的沟通</strong>（认为比书面的文档更有效）、<strong>频繁交付新的软件版本</strong>、<strong>紧凑而自我组织型的团队</strong>、能够很好地<strong>适应需求变化的代码编写和团队组织方法</strong>，也更<strong>注重软件开发过程中人的作用</strong>。<div align=center><img src="../../../../images/2018-03/scrum/scrum.png" algin="center"/></div><span id="more"></span></p>
<h1 id="敏捷开发宣言和原则"><a href="#敏捷开发宣言和原则" class="headerlink" title="敏捷开发宣言和原则"></a>敏捷开发宣言和原则</h1><h2 id="敏捷宣言的价值观"><a href="#敏捷宣言的价值观" class="headerlink" title="敏捷宣言的价值观"></a>敏捷宣言的价值观</h2><ul>
<li><strong>个体和互动</strong> 高于 流程和工具 </li>
<li><strong>工作的软件</strong> 高于 详尽的文档 </li>
<li><strong>客户合作</strong> 高于 合同谈判</li>
<li><strong>响应变化</strong> 高于 遵循计划</li>
</ul>
<p>也就是说，尽管<strong>右项有其价值</strong>，我们<strong>更重视左项的价值</strong>。</p>
<h2 id="敏捷宣言的原则"><a href="#敏捷宣言的原则" class="headerlink" title="敏捷宣言的原则"></a>敏捷宣言的原则</h2><ul>
<li>我们最重要的目标，是通过<strong>持续不断地及早交付有价值的软件</strong>使客户满意。</li>
<li><strong>欣然面对需求变化</strong>，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。</li>
<li><strong>经常地交付可工作的软件</strong>，相隔几星期或一两个月，倾向于采取较短的周期。</li>
<li>业务人员和开发人员必须<strong>相互合作</strong>，项目中的每一天都不例外。</li>
<li><strong>激发个体的斗志</strong>，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。</li>
<li>不论团队内外，传递信息效果最好效率也最高的方式是<strong>面对面的交谈</strong>。</li>
<li><strong>可工作的软件</strong>是进度的首要度量标准。</li>
<li>敏捷过程倡导<strong>可持续开发</strong>。责任人、开发人员和用户要能够共同<strong>维持其步调稳定延续</strong>。</li>
<li>坚持不懈地<strong>追求技术卓越和良好设计</strong>，敏捷能力由此增强。</li>
<li><strong>以简洁为本</strong>，它是极力减少不必要工作量的艺术。</li>
<li><strong>最好的架构、需求和设计出自自组织团队</strong>。</li>
<li>团队<strong>定期地反思</strong>如何能提高成效，并依此调整自身的举止表现。</li>
</ul>
<p>敏捷宣言中这些价值观和原则，所谓<strong>入门容易精通难</strong>，在旁人或者入门者看来也许略显空洞，所言无物；然而，敏捷精髓的实践者们一直坚信着这些理念，觉得它们字字珠玑，所言极是。不管我们是走敏捷的哪个流派，都不妨在实践敏捷的过程中，回过头来看看这些价值观和原则，想必会常看常新，大有裨益。</p>
<h1 id="Scrum核心"><a href="#Scrum核心" class="headerlink" title="Scrum核心"></a>Scrum核心</h1><div align=center><img src="../../../../images/2018-03/scrum/scrum-core.png" algin="center"/></div>

<h2 id="团队密切协作"><a href="#团队密切协作" class="headerlink" title="团队密切协作"></a>团队密切协作</h2><p>敏捷开发中，最核心的就是人。</p>
<p>不是说每个人坐在自己的格子间里，各自独立开发，定期向领导汇报工作就完事了，敏捷开发需要做到几个关键点：</p>
<ol>
<li>定期会面。通过定期高效会议让开发人员保持紧张有序的工作状态。</li>
<li>及时告知项目进展。鼓励遇到问题一定要及时告知，让所有利益相关者都能够及时了解项目的最新进展。</li>
<li>知识共享。把知识分享出来，可以提升整个团队的开发能力，是对团队的一种投资。</li>
<li>代码共享。把代码集中在版本管理工具之中，团队任何人都有访问权限。</li>
<li>代码审查。针对代码的每个改动，都需要相关人员做代码审查。</li>
</ol>
<h2 id="不断反馈和调整"><a href="#不断反馈和调整" class="headerlink" title="不断反馈和调整"></a>不断反馈和调整</h2><p>敏捷开发与传统瀑布式开发一个最大的不同就是，并非一次定终身。</p>
<p>软件开发不是线性过程，它存在很多的不确定性，有一定的动态波动，所以需要不断的反馈、调整，快速响应变化。</p>
<ul>
<li>需求调整。在产品落地前，你是不可能制定出完美需求方案的，客户也并不一定能够清晰的知道他想要的软件产品到底是什么样子。所以，要做好需求不断变化的心理准备，也要有快速响应需求变化的能力。</li>
</ul>
<ul>
<li>功能调整。收集客户反馈、用户反响，来不断调整和优化软件功能。</li>
</ul>
<ul>
<li>代码重构。在开发的过程中，需要不断的重构代码，保持代码清晰、内聚、整洁。</li>
</ul>
<h2 id="保持软件可用"><a href="#保持软件可用" class="headerlink" title="保持软件可用"></a>保持软件可用</h2><p>传统软件开发的方式是，等代码编写完毕，所有功能都完成之后，再集中测试和上线，在这之前，软件都是用户不可用的。</p>
<p>在信息快速发展的今天，这显然太落伍了，可能等你软件开发个一年半载，外面都变天了。</p>
<p>敏捷开发，另一大特色，就是保持软件一直可用，在最小可用版本基础之上，不断做功能迭代，不断发布新的版本。</p>
<p>通俗点讲就是，先做一个简化版本出来，让用户一直有软件可用，而后再逐步添加更多的功能，「小步快跑」式的做开发，而非一步到位。</p>
<p>这样做的好处，也是为了能够不断收集用户反馈与需求，及时调整开发方向。</p>
<h2 id="短迭代-增量发布"><a href="#短迭代-增量发布" class="headerlink" title="短迭代 增量发布"></a>短迭代 增量发布</h2><p>这一条是上一条的延伸。</p>
<p>所谓「迭代」就是，重复下一个开发周期，此刻你可以想象一下 while loop。</p>
<p>用迭代的方法在前一版本之上逐步开发新的功能，发布新的版本，即：增量发布。</p>
<p>迭代周期不宜过长，一年半年显然就太久了，尽量要缩短迭代周期，保持开发过程稳步前进。</p>
<p>但短迭代并不意味着太过频繁，每天或者每周迭代一次的话，很可能会过犹不及，半个月到一个月应该是一个不错的时间节点。当然这只是参考建议，具体的迭代周期还应根据真实情况量力而行。</p>
<div align=center><img width="700" height="300" src="../../../../images/2018-03/scrum/%E8%BF%AD%E4%BB%A3.jpeg" algin="center"/></div>

<h2 id="提早集成-不断集成"><a href="#提早集成-不断集成" class="headerlink" title="提早集成 不断集成"></a>提早集成 不断集成</h2><p>「集成」的含义就是，把软件的各个模块，新旧代码统一整合在一起，能够正确编译、运行，并且能够通过一系列的单元测试。</p>
<p>敏捷开发要求开发人员，不要临到软件发布或者交付的当天才开始集成，也不要很久才集成一次，尽可能的做到提早继承、频繁集成。理论上讲，每添加进一些新的代码，最好都要做一次集成。</p>
<p>通过提早集成、不断集成，能够尽早发现代码中的问题，保持软件的状态一直是可用的。</p>
<h2 id="自动化集成、测试与部署"><a href="#自动化集成、测试与部署" class="headerlink" title="自动化集成、测试与部署"></a>自动化集成、测试与部署</h2><p>敏捷的另一个关键点是，通过技术手段把集成、测试与部署这些非常耗时的操作自动化。</p>
<p>至于为什么要自动化，如果你是一个人开发一个几千行的程序，那确实没必要自动化，确切的说，也没必要应用什么敏捷开发。</p>
<p>针对开发大型软件的团队而言，编译、测试过程有可能都非常的耗时，编译有时会花上半天的时间，测试可能会持续好几天。而且是多人协作共同开发，如果纯手动的话，你想象一下如果两个人想前后脚提交代码，岂不是要等上好几天的时间，等前面那个人集成结束之后，后面那个人才可以开始集成？</p>
<p>把集成、测试与部署自动化的好处就是，把这些耗时的纯体力劳动扔给机器去做，它做完了，只要返回你一个最终结果就好了，而且两个人同时 Check In 时也不会受到影响。<div align=center><img width="700" height="300" src="../../../../images/2018-03/scrum/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E9%83%A8%E7%BD%B2.png" algin="center"/></div></p>
<p>这副图涵盖了自动化集成、测试以及部署的流程。</p>
<p>开发者 Check In 之后的所有工作将都交给机器去做，它们都有专门的工具 ，包括集成工具、测试工具，当然这些工具可以使用第三方的，也可以自己开发。</p>
<p>一般情况下，这一系列的工作都跟版本管理工具绑定在一起，你只要 Check In 就会触发集成、测试，甚至还有部署。而你，只要专心的等待结果就好。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在流程上，敏捷最大的特色是迭代式开发。敏捷开发可以用一句话概括：<strong>拥抱变化，轻量文档，团队合作，多个短的冲刺周期</strong></p>
<p>参考文章：</p>
<p><a href="https://www.zybuluo.com/yishuailuo/note/672154?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io">https://www.zybuluo.com/yishuailuo/note/672154?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io</a></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈日志</title>
    <url>/%E8%B0%88%E8%B0%88%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>日志用来记录用户操作、系统运行状态等，是一个系统的重要组成部分。 然而，由于日志通常不属于系统的核心功能，所以常常不被团队成员所重视。<span id="more"></span>对于一些简单的小程序，可能并不需要在如何记录日志的问题上花费太多精力。但是对于作为基础平台为很多产品提供服务的后端程序，就必须要考虑如何依靠良好的日志来保证系统可靠的运行了。</p>
<div align=center><img width="250" height="220" src="../../../../images/2018-9-12/log.jpeg" algin="center"/>
</div>



<h1 id="工程配置"><a href="#工程配置" class="headerlink" title="工程配置"></a>工程配置</h1><p>使用slf4j作为日志门面，logback作为日志实现，把其他日志组件的调用转换到slf4j。</p>
<p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 可到https://mvnrepository.com获取最新version版本</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- common-logging 实际调用slf4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- java.util.logging 实际调用slf4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jul-to-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- log4j实际调用slf4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="logback配置"><a href="#logback配置" class="headerlink" title="logback配置"></a>logback配置</h1><p>详见：<a href="http://mx-go.github.io/logback%E6%8E%A8%E8%8D%90%E9%85%8D%E7%BD%AE/">logback配置</a></p>
<h1 id="jrebel配置"><a href="#jrebel配置" class="headerlink" title="jrebel配置"></a>jrebel配置</h1><p>在本地开发过程中，希望把日志打印到stdout，需要配合jrebel插件来实现。通过jrebel插件来启动tomcat的时候，就会优先找到 target/test­-classes/logback­-test.xml文件，这样就会把日志信息输出到stdout了。当正式打包的时候，不会打包test目录下的资源信息。这样就能实现线上和线下2套配置，互不影响。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">application</span> <span class="attr">generated-by</span>=<span class="string">&quot;intellij&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.zeroturnaround.com&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.zeroturnaround.com http://update.zeroturnaround.com/jrebel/rebel-2_1.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">classpath</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 查找资源文件的时候，优先从target/test-classes目录下查找 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dir</span> <span class="attr">name</span>=<span class="string">&quot;/Users/max/Documents/workSpace/open-msg/target/test-classes&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dir</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dir</span> <span class="attr">name</span>=<span class="string">&quot;/Users/max/Documents/workSpace/open-msg/target/classes&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dir</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">classpath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">web</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">link</span> <span class="attr">target</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">dir</span> <span class="attr">name</span>=<span class="string">&quot;/Users/max/Documents/workSpace/open-msg/src/main/webapp&quot;</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;/<span class="name">dir</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">web</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="合理的日志级别"><a href="#合理的日志级别" class="headerlink" title="合理的日志级别"></a>合理的日志级别</h1><ol>
<li>要用异步日志；</li>
<li>要做日志轮转；</li>
<li>要有上下文信息；</li>
<li>不要疯狂打日志。</li>
</ol>
<table>
<thead>
<tr>
<th>日志级别</th>
<th>打印建议</th>
</tr>
</thead>
<tbody><tr>
<td>DEBUG（调试）</td>
<td>不建议在线上环境打印DEBUG日志，在需要的时候可以通过开关打开DEBUG日志，默认需要关闭DEBUG日志。过多的DEBUG日志，并不是好事，特别反对通过aop把函数调用的参数和返回值信息都记录到DEBUG日志中的做法。</td>
</tr>
<tr>
<td>INFO（通知）</td>
<td>业务日志用来记录业务的主流程的走向。INFO日志级别主要用于记录系统运行状态等关联信息。该日志级别，常用于反馈系统当前状态给最终用户。所以，在这里输出的信息，应该对最终用户具有实际意义，也就是最终用户要能够看得明白是什么意思才行。</td>
</tr>
<tr>
<td>WARN（警告）</td>
<td>WARN日志常用来表示系统模块发生问题，但并不影响系统运行。 此时，进行一些修复性的工作，还能把系统恢复到正常的状态。参数验证错误类的可以使用WARN。</td>
</tr>
<tr>
<td>ERROR（错误）</td>
<td>此信息输出后，主体系统核心模块正常工作，需要修复才能正常工作。</td>
</tr>
</tbody></table>
<h1 id="必要的日志元素"><a href="#必要的日志元素" class="headerlink" title="必要的日志元素"></a>必要的日志元素</h1><p><strong>理想的日志中应该记录不多不少的信息。</strong><br>所谓不多，是指不要在日志中记录无用的信息。实践中常见到的无用的日志有：</p>
<ul>
<li>能够放在一条日志里的东西，放在多条日志中输出；</li>
<li>预期会发生且能够被正常处理的异常，打印出一堆无用的堆栈；</li>
<li>开发人员在开发过程中为了调试方便而加入的“临时”日志；</li>
</ul>
<p>所谓不少，是指对于日志的使用者，能够从日志中得到所有需要的信息。在实践中经常发生日志不够的情况，例如：</p>
<ul>
<li>请求出错时不能通过日志直接来定位问题，而需要开发人员再临时增加日志并要求请求的发送者重新发送同样的请求才能定位问题；</li>
<li>无法确定服务中的后台任务是否按照期望执行；</li>
<li>无法确定服务的内存数据结构的状态；</li>
<li>无法确定服务的异常处理逻辑（如重试）是否正确执行；</li>
<li>无法确定服务启动时配置是否正确加载；</li>
<li>……</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>跨页面(Tab/Window)通信的几种方法</title>
    <url>/%E8%B7%A8%E9%A1%B5%E9%9D%A2-Tab-Window-%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>​    今天开发一个功能遇到一个需求，在A页面点击查看详情后打开B页面进行修改或删除，删除后B页面关闭，然后刷新A页面里面的数据。相当于就是两个页面之间进行通讯，作为后端的我第一想法是利用<code>webSocket</code> 进行通讯，之后通过谷歌和百度找出了更为简便的方法。</p>
<div align=center><img width="450" height="200" src="../../../../images/2017-9-13/additional/html%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%80%BC.png" algin="center"/></div><span id="more"></span>

<h1 id="利用webSocket进行通讯"><a href="#利用webSocket进行通讯" class="headerlink" title="利用webSocket进行通讯"></a>利用webSocket进行通讯</h1><p>​    第一想法是这个，但是这样的话工作量巨大而且还需要后端支持，太麻烦了，对于我这种懒人直接就放弃了，去寻找有没有更简便的方法。</p>
<h1 id="定时器不断检查cookies变化"><a href="#定时器不断检查cookies变化" class="headerlink" title="定时器不断检查cookies变化"></a>定时器不断检查cookies变化</h1><p>在<a href="https://stackoverflow.com/">stackoverflow</a>上看到一个方案，大致思路是：</p>
<ol>
<li>在页面A设置一个使用 <code>setInterval</code> 定时器不断刷新，检查 <code>Cookies</code> 的值是否发生变化，如果变化就进行刷新的操作。</li>
<li>由于 <code>Cookies</code> 是在同域可读的，所以在页面 B 审核的时候改变 <code>Cookies</code> 的值，页面 A 自然是可以拿到的。<br>这样做确实可以实现我想要的功能，但是这样的方法相当浪费资源。虽然在这个性能过盛的时代，浪费不浪费也感觉不出来，但是这种实现方案，确实不够优(zhuāng)雅（bī）。</li>
</ol>
<h1 id="localStorage的事件"><a href="#localStorage的事件" class="headerlink" title="localStorage的事件"></a>localStorage的事件</h1><p>功夫不负有心人，后来发现 window 有一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/StorageEvent">StorageEvent</a> ，每当 <code>localStorage</code> 改变的时候可以触发这个事件。（这个原理就像你给一个<code>DOM</code> 绑定了 <code>click</code> 事件，当你点击它的时候，就会自动触发。）也就是说，我给 <code>window</code> 绑定这个事件后，每当我改变 <code>localStorage</code> 的时候，他都会触发这个事件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.addEventListener(&#x27;storage&#x27;, function (event) &#123;</span><br><span class="line">  console.log(event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个回调中的<code>event</code>与普通的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event#Properties">EVNET</a>,基本差不多，但是它比其他的<code>event</code>多了如下几个属性:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>key</td>
<td>受影响的 <code>localStorage</code> 的 <code>key</code></td>
</tr>
<tr>
<td>newValue</td>
<td>新的值</td>
</tr>
<tr>
<td>oldValue</td>
<td>旧的值</td>
</tr>
<tr>
<td>url</td>
<td>触发此事件的url</td>
</tr>
</tbody></table>
<p>每当一个页面改变了 <code>localStorage</code> 的值，都会触发这个事件。也就是说可以很容易的通过改变 <code>localStorage</code> 的值，来实现浏览器中跨页面( tab / window )之间的通讯。记住这个事件只有在 <code>localStorage</code> 发生<strong>改变</strong>的时候才会被触发，如果没改变则<strong>不会触发</strong>此事件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localStorage.setItem(&#x27;delete&#x27;,1); //触发</span><br><span class="line">localStorage.setItem(&#x27;delete&#x27;,1); //不触发</span><br><span class="line">localStorage.setItem(&#x27;delete&#x27;,2); //触发</span><br></pre></td></tr></table></figure>

<p>在使用的时候务必注意这一点。<br>最终实现代码:</p>
<p><strong>页面A：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//页面 A</span><br><span class="line">window.addEventListener(&#x27;storage&#x27;, function (event) &#123;</span><br><span class="line">    if(event.key === &#x27;delete_verify_list&#x27;)&#123;</span><br><span class="line">        //页面操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>页面B：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//页面 B</span><br><span class="line">/**</span><br><span class="line"> *  获取一个随机id</span><br><span class="line"> * @return &#123;String&#125; - 返回一个5位的随机字符串</span><br><span class="line"> */</span><br><span class="line">function randomId() &#123;</span><br><span class="line">    return (Math.random() * 1E18).toString(36).slice(0, 5).toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//每当需要页面A更新时 执行此方法</span><br><span class="line">if (localStorage) &#123;</span><br><span class="line">	//为保证每次页面A都执行，此处我设置里一个随机字符串</span><br><span class="line">    localStorage.setItem(&#x27;delete_verify_list&#x27;, randomId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://ponyfoo.com/articles/cross-tab-communication">https://ponyfoo.com/articles/cross-tab-communication</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量级日志采集Loki搭建</title>
    <url>/%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86Loki%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p><code>Loki</code>是受<code>Prometheus</code>启发由Grafana Labs团队开源的水平可扩展，高度可用的多租户日志聚合系统。它的设计具有很高的成本效益，并且易于操作。使用标签来作为索引，而不是对全文进行检索，也就是说，通过这些标签既可以查询日志的内容也可以查询到监控的数据签，极大地降低了日志索引的存储。<div align=center><img src="../../../../images/2020/9-12/loki.png" algin="center"/></div></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>只要在应用程序服务器上安装<code>Promtail</code>来收集日志然后发送给<code>Loki</code>存储，就可以在Grafana UI界面通过添加<code>Loki</code>为数据源进行日志查询(如果<code>Loki</code>服务器性能不够，可以部署多个<code>Loki</code>进行存储及查询）。作为一个日志系统不光只有查询分析日志的能力，还能对日志进行监控和报警。</p>
<ul>
<li><code>Loki</code>是主服务器，负责存储日志和处理查询 。</li>
<li><code>Promtail</code>是客户端代理，负责收集日志并将其发送给<code>Loki</code>。</li>
<li><code>Grafana</code>用于UI展示。</li>
</ul>
<div align=center><img src="../../../../images/2020/9-12/grafana-loki.png" algin="center"/></div>

<h2 id="Loki架构"><a href="#Loki架构" class="headerlink" title="Loki架构"></a>Loki架构</h2><ol>
<li><p><code>Promtail</code>收集并将日志发送给<code>Loki</code>的<code>Distributor</code>组件；</p>
</li>
<li><p><code>Distributor</code>会对接收到的日志流进行正确性校验，并将验证后的日志分批并行发送到<code>Ingester</code>；</p>
</li>
<li><p><code>Ingester</code>接受日志流并构建数据块，压缩后存放到所连接的存储后端；</p>
</li>
<li><p><code>Querier</code>收到HTTP查询请求，并将请求发送至<code>Ingester</code>用以获取内存数据 ，<code>Ingester</code>收到请求后返回符合条件的数据 ；</p>
</li>
</ol>
<p>如果<code>Ingester</code>没有返回数据，<code>Querier</code>会从后端存储加载数据并遍历去重执行查询 ，通过<code>HTTP</code>返回查询结果。</p>
<div align=center><img src="../../../../images/2020/9-12/loki-architecture.jpg" algin="center"/></div>



<h1 id="安装包下载"><a href="#安装包下载" class="headerlink" title="安装包下载"></a>安装包下载</h1><p><code>Loki</code>安装包下载地址【<strong>loki-linux-amd64.zip</strong>】：<a href="https://github.com/grafana/loki/releases">https://github.com/grafana/loki/releases</a></p>
<p><code>Promtail</code>安装包下载地址【<strong>promtail-linux-amd64.zip</strong>】：<a href="https://github.com/grafana/loki/releases">https://github.com/grafana/loki/releases</a></p>
<h1 id="Loki"><a href="#Loki" class="headerlink" title="Loki"></a>Loki</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="config-yaml配置"><a href="#config-yaml配置" class="headerlink" title="config.yaml配置"></a>config.yaml配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auth_enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">http_listen_port:</span> <span class="number">3100</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ingester:</span></span><br><span class="line">  <span class="attr">lifecycler:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">ring:</span></span><br><span class="line">      <span class="attr">kvstore:</span></span><br><span class="line">        <span class="attr">store:</span> <span class="string">inmemory</span></span><br><span class="line">      <span class="attr">replication_factor:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">final_sleep:</span> <span class="string">0s</span></span><br><span class="line">  <span class="attr">chunk_idle_period:</span> <span class="string">5m</span></span><br><span class="line">  <span class="attr">chunk_retain_period:</span> <span class="string">30s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">schema_config:</span></span><br><span class="line">  <span class="attr">configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">from:</span> <span class="number">2021-03-01</span></span><br><span class="line">      <span class="attr">store:</span> <span class="string">boltdb</span></span><br><span class="line">      <span class="attr">object_store:</span> <span class="string">filesystem</span></span><br><span class="line">      <span class="attr">schema:</span> <span class="string">v9</span></span><br><span class="line">      <span class="attr">index:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">index_</span></span><br><span class="line">        <span class="attr">period:</span> <span class="string">672h</span></span><br><span class="line"></span><br><span class="line"><span class="attr">storage_config:</span></span><br><span class="line">  <span class="attr">boltdb:</span></span><br><span class="line">    <span class="attr">directory:</span> <span class="string">/tmp/loki/index</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">filesystem:</span></span><br><span class="line">    <span class="attr">directory:</span> <span class="string">/tmp/loki/chunks</span></span><br><span class="line"></span><br><span class="line"><span class="attr">limits_config:</span></span><br><span class="line">  <span class="attr">enforce_metric_name:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">reject_old_samples:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">reject_old_samples_max_age:</span> <span class="string">672h</span></span><br><span class="line"></span><br><span class="line"><span class="attr">chunk_store_config:</span></span><br><span class="line">  <span class="attr">max_look_back_period:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">table_manager:</span></span><br><span class="line">  <span class="attr">chunk_tables_provisioning:</span></span><br><span class="line">    <span class="attr">inactive_read_throughput:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">inactive_write_throughput:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">provisioned_read_throughput:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">provisioned_write_throughput:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">index_tables_provisioning:</span></span><br><span class="line">    <span class="attr">inactive_read_throughput:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">inactive_write_throughput:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">provisioned_read_throughput:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">provisioned_write_throughput:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">retention_deletes_enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">retention_period:</span> <span class="string">672h</span></span><br></pre></td></tr></table></figure>

<h3 id="start-sh配置"><a href="#start-sh配置" class="headerlink" title="start.sh配置"></a>start.sh配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">./loki --config.file=config.yaml &amp;</span><br></pre></td></tr></table></figure>

<h2 id="启动Loki"><a href="#启动Loki" class="headerlink" title="启动Loki"></a>启动Loki</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /app/loki</span><br><span class="line">mv loki-linux-amd64.zip promtail-linux-amd64.zip /app/loki</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动Loki</span></span><br><span class="line">cd /app/loki</span><br><span class="line">unzip loki-linux-amd64.zip -d loki</span><br><span class="line">sh start.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证Loki是否正常启动</span></span><br><span class="line">ps -ef | grep loki</span><br></pre></td></tr></table></figure>

<blockquote>
<p>日志及索引存储路径：/tmp/loki</p>
</blockquote>
<h1 id="promtail"><a href="#promtail" class="headerlink" title="promtail"></a>promtail</h1><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><h3 id="promtail-config-yaml配置"><a href="#promtail-config-yaml配置" class="headerlink" title="promtail-config.yaml配置"></a>promtail-config.yaml配置</h3><p><strong>注意：需要修改 clients.url为Loki服务的IP和端口</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  http_listen_port: 9080</span><br><span class="line">  grpc_listen_port: 0</span><br><span class="line"></span><br><span class="line">positions:</span><br><span class="line">  filename: /tmp/positions.yaml</span><br><span class="line"></span><br><span class="line">clients:</span><br><span class="line">    ## loki.host为Loki服务地址</span><br><span class="line">  - url: http://loki.host/loki/api/v1/push</span><br><span class="line"></span><br><span class="line">scrape_configs:</span><br><span class="line">- job_name: system</span><br><span class="line">  static_configs:</span><br><span class="line">  - targets:</span><br><span class="line">      - localhost</span><br><span class="line">    labels:</span><br><span class="line">      ## 系统编码</span><br><span class="line">      systemcode: $&#123;SYSTEM_CODE&#125;</span><br><span class="line">      ## 服务名称</span><br><span class="line">      servicename: $&#123;SERVICE_DLE_NAME&#125;</span><br><span class="line">      ## 实例名称</span><br><span class="line">      instance: $&#123;HOSTNAME&#125;</span><br><span class="line">      ## 采集日志路径</span><br><span class="line">      __path__: /app/deploy/logs/*-warn.log</span><br></pre></td></tr></table></figure>

<h2 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">PROMTAIL_VERSION=promtail-1.0.1-warn</span><br><span class="line">cd /app/</span><br><span class="line">wget http://maven.com/artifactory/maven-releases-local/promtail/$PROMTAIL_VERSION.zip</span><br><span class="line">unzip $PROMTAIL_VERSION.zip -d promtail</span><br><span class="line">rm $PROMTAIL_VERSION.zip</span><br><span class="line">cd promtail</span><br><span class="line">chmod 755 promtail</span><br><span class="line">nohup ./promtail -config.expand-env=true -config.file=promtail-config.yaml &amp;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">其中-config.expand-env=true标识可从环境变量中取值。</mark> 

<p>脚本自动从<code>Maven</code>仓库(可换为其他地址)拉取<code>zip</code>包并解压，<code>zip</code>包中需包含 <strong>promtail</strong>、<strong>promtail-config.yaml</strong>文件</p>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>启动后进入实例的app目录下查看是否存在<code>Promtail</code>目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 验证promtail 是否已经正常启动</span></span><br><span class="line">ps -ef | grep promtail</span><br></pre></td></tr></table></figure>

<div align=center><img src="../../../../images/2020/9-12/loki_result.jpg" algin="center"/></div>]]></content>
      <categories>
        <category>工具</category>
        <category>Linux</category>
        <category>安装</category>
      </categories>
      <tags>
        <tag>tips</tag>
        <tag>grafana</tag>
      </tags>
  </entry>
  <entry>
    <title>静态服务器搭建及前端知识点</title>
    <url>/%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>​    虽然是做后台开发，但是很多时候自己也兼顾了前台，并不是所有的项目都是前后台分离开发，所以在开发期间自己也总结和学习了前端了一些小知识，在这里进行总结，以便自己温习。</p>
<div align=center><img src="../../../../images/2017-9-13/%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7/%E5%89%8D%E7%AB%AF.jpg" algin="center"/></div>    

<h1 id="NodeJS搭建静态资源服务器"><a href="#NodeJS搭建静态资源服务器" class="headerlink" title="NodeJS搭建静态资源服务器"></a>NodeJS搭建静态资源服务器</h1><p>对<code>Node.js</code>只有浅显的认识，但是有时候又要自己搭建静态服务器进行测试。搭建静态服务器需要以下几个步骤：</p>
<ol>
<li>下载node.js，进入node.js官网下载<a href="http://nodejs.cn/"><em><strong>http://nodejs.cn</strong></em></a>对应的版本。</li>
<li>安装node.js。</li>
<li>启动node.js，在命令行输入命令安装需要的模块，依次执行命令。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">npm install express</span><br><span class="line">npm install request</span><br><span class="line">npm install http-server </span><br></pre></td></tr></table></figure>

<h2 id="简单的静态服务器"><a href="#简单的静态服务器" class="headerlink" title="简单的静态服务器"></a>简单的静态服务器</h2><p>新建server.js，内容为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">&#x27;request&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="comment">//启动端口为81</span></span><br><span class="line"><span class="keyword">var</span> port = process.env.PORT||<span class="number">81</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//静态资源存放的路径</span></span><br><span class="line"> app.use(express.static(<span class="string">&#x27;E:/SmallTools/StaticServer&#x27;</span>));</span><br><span class="line">http.createServer(app).listen(port);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;服务启动成功&quot;</span>);</span><br></pre></td></tr></table></figure>

<div align=center><img src="../../../../images/2017-9-13/%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7/file.png" algin="center"/>


</div>

<p>启动server.js</p>
<div align=center><img src="../../../../images/2017-9-13/%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7/cmd%E7%AE%80%E5%8D%95.png" algin="center"/>


</div>

<p>通过http请求访问a.html页面</p>
<div align=center><img width="600" height="200" src="../../../../images/2017-9-13/%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7/%E7%AE%80%E5%8D%95html.png" algin="center"/>

</div>

<p>可以访问说明搭建成功！</p>
<h2 id="带反向代理静态服务器搭建"><a href="#带反向代理静态服务器搭建" class="headerlink" title="带反向代理静态服务器搭建"></a>带反向代理静态服务器搭建</h2><p>新建server-kaow-school.js，内容为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> https = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">&#x27;request&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="comment">//app.disable(&#x27;x-powered-by&#x27;);</span></span><br><span class="line"><span class="keyword">var</span> port = process.env.PORT||<span class="number">81</span>;</span><br><span class="line"></span><br><span class="line">app.use(express.static(<span class="string">&#x27;E:/SmallTools/StaticServer&#x27;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params">app,route,remoteDomain</span>)</span>&#123;</span><br><span class="line">    app.use(route,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> url = remoteDomain+req.url;</span><br><span class="line">      req.pipe(request(url)).pipe(res);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//10.9.4.215:8380  测试服务器ip</span></span><br><span class="line">proxy(app,<span class="string">&#x27;/163&#x27;</span>,<span class="string">&#x27;http://www.163.com&#x27;</span>);</span><br><span class="line"><span class="comment">//proxy(app,&#x27;/MonitorService/&#x27;,&#x27;http://10.9.4.215:9192/MonitorService/&#x27;);</span></span><br><span class="line"> </span><br><span class="line">http.createServer(app).listen(port);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;服务器启动完成,请使用locahost:&quot;</span>+port+<span class="string">&quot;访问&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>启动<code>server-kaow-school.js</code></p>
<div align=center><img src="../../../../images/2017-9-13/%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7/cmd%E5%A4%8D%E6%9D%82.png" algin="center"/></div>

<p>通过http请求访问b.html页面</p>
<div align=center><img src="../../../../images/2017-9-13/%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7/%E5%A4%8D%E6%9D%82html.png" algin="center"/></div>

<p>访问/163</p>
<div align=center><img src="../../../../images/2017-9-13/%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7/%E5%A4%8D%E6%9D%82-163.png" algin="center"/></div>
可以访问说明带反向代理的静态服务器搭建成功！

<h1 id="前端知识点"><a href="#前端知识点" class="headerlink" title="前端知识点"></a>前端知识点</h1><div align=center><img src="../../../../images/2017-9-13/%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7/tips.png" algin="center"/></div>
## JS字符串截取空白trim()的原型实现

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.trim = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.replace( <span class="regexp">/(^\s*)|(\s*$)/g</span> , <span class="string">&#x27;&#x27;</span><span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="JS屏蔽键盘按键"><a href="#JS屏蔽键盘按键" class="headerlink" title="JS屏蔽键盘按键"></a>JS屏蔽键盘按键</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body oncontextmenu=<span class="string">&quot;return false&quot;</span> onselectstart=<span class="string">&quot;return false&quot;</span> ondragstart=<span class="string">&quot;return false&quot;</span> onbeforecopy=<span class="string">&quot;return false&quot;</span> onmouseup=<span class="built_in">document</span>.selection.empty() oncopy=<span class="built_in">document</span>.selection.empty() onselect=<span class="built_in">document</span>.selection.empty()&gt;&lt;/body&gt; </span><br><span class="line">讲上面红色显示的插入到网页中就可以实现鼠标右击无效</span><br><span class="line">禁止选择						onselectstart=<span class="string">&quot;return false&quot;</span>    			</span><br><span class="line">禁止拖放						ondragstart=<span class="string">&quot;return false&quot;</span>			</span><br><span class="line">禁止拷贝						ncopy=<span class="built_in">document</span>.selection.empty()		</span><br><span class="line">禁止保存(放在head里面)			&lt;noscript&gt;<span class="xml"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;*.htm&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span>&lt;/noscript&gt;</span><br><span class="line">禁止粘贴						&lt;input type=text onpaste=<span class="string">&quot;return false&quot;</span>&gt;</span><br><span class="line">关闭输入法					&lt;input style=<span class="string">&quot;ime-mode:disabled&quot;</span>&gt;</span><br><span class="line">屏蔽鼠标右键					 <span class="function"><span class="keyword">function</span> <span class="title">document</span>.<span class="title">oncontextmenu</span>(<span class="params"></span>)</span>&#123;event.returnValue=<span class="literal">false</span>;&#125;</span><br><span class="line">屏蔽F1帮助					<span class="function"><span class="keyword">function</span> <span class="title">window</span>.<span class="title">onhelp</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="literal">false</span>&#125; </span><br><span class="line"></span><br><span class="line">屏蔽其他键</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">document</span>.<span class="title">onkeydown</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">   <span class="keyword">if</span> ((<span class="built_in">window</span>.event.altKey)&amp;&amp; </span><br><span class="line">   	((<span class="built_in">window</span>.event.keyCode==<span class="number">37</span>)||	 <span class="comment">//屏蔽 Alt+ 方向键 ← </span></span><br><span class="line"> 	  (<span class="built_in">window</span>.event.keyCode==<span class="number">39</span>))) 		<span class="comment">//屏蔽 Alt+ 方向键 → &#123; </span></span><br><span class="line">   	 alert(<span class="string">&quot;不准你使用ALT+方向键前进或后退网页！&quot;</span>); </span><br><span class="line"> 	   event.returnValue=<span class="literal">false</span>; </span><br><span class="line">   &#125; </span><br><span class="line">    <span class="comment">/* 注：这还不是真正地屏蔽 Alt+ 方向键， </span></span><br><span class="line"><span class="comment">    因为 Alt+ 方向键弹出警告框时，按住 Alt 键不放， </span></span><br><span class="line"><span class="comment">    用鼠标点掉警告框，这种屏蔽方法就失效了。以后若 </span></span><br><span class="line"><span class="comment">    有哪位高手有真正屏蔽 Alt 键的方法，请告知。*/</span> </span><br><span class="line">   <span class="keyword">if</span> ((event.keyCode==<span class="number">8</span>)   ||                 <span class="comment">//屏蔽退格删除键 </span></span><br><span class="line"> 	  (event.keyCode==<span class="number">116</span>)||                 <span class="comment">//屏蔽 F5 刷新键 </span></span><br><span class="line"> 	  (event.ctrlKey &amp;&amp; event.keyCode==<span class="number">82</span>))&#123; <span class="comment">//Ctrl + R </span></span><br><span class="line"> 	  event.keyCode=<span class="number">0</span>; </span><br><span class="line">    	event.returnValue=<span class="literal">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line">屏蔽F11    <span class="keyword">if</span> (event.keyCode==<span class="number">122</span>)&#123;event.keyCode=<span class="number">0</span>;event.returnValue=<span class="literal">false</span>;&#125;</span><br><span class="line">屏蔽		 Ctrl+n    <span class="keyword">if</span> (event.ctrlKey &amp;&amp; event.keyCode==<span class="number">78</span>) event.returnValue=<span class="literal">false</span>; </span><br><span class="line">   <span class="keyword">if</span> (event.shiftKey &amp;&amp; event.keyCode==<span class="number">121</span>)   event.returnValue=<span class="literal">false</span>;   <span class="comment">//屏蔽 shift+F10 </span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">window</span>.event.srcElement.tagName == <span class="string">&quot;A&quot;</span> &amp;&amp; <span class="built_in">window</span>.event.shiftKey)  </span><br><span class="line">   <span class="built_in">window</span>.event.returnValue = <span class="literal">false</span>;          <span class="comment">//屏蔽 shift 加鼠标左键新开一网页 </span></span><br><span class="line">   <span class="keyword">if</span> ((<span class="built_in">window</span>.event.altKey)&amp;&amp;(<span class="built_in">window</span>.event.keyCode==<span class="number">115</span>))&#123;        <span class="comment">//屏蔽Alt+F4 </span></span><br><span class="line">   <span class="built_in">window</span>.showModelessDialog(<span class="string">&quot;about:blank&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;dialogWidth:1px;dialogheight:1px&quot;</span>); </span><br><span class="line">   		<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">屏蔽打印：</span><br><span class="line">&lt;style&gt; </span><br><span class="line">@media print&#123; </span><br><span class="line">* &#123;<span class="attr">display</span>:none&#125; </span><br><span class="line">&#125; </span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="HTML之间传值-通过解析url"><a href="#HTML之间传值-通过解析url" class="headerlink" title="HTML之间传值(通过解析url)"></a>HTML之间传值(通过解析url)</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hrefInfo = getUrlVars(<span class="built_in">window</span>.location.href); <span class="comment">// 得到参数信息</span></span><br><span class="line">	<span class="keyword">if</span> (hrefInfo.logId &amp;&amp; hrefInfo.logId != <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">		fillData(hrefInfo.logId);</span><br><span class="line">		logId = hrefInfo.logId;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析url中的参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrlVars</span>(<span class="params">hrf</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> vars = [], hash;</span><br><span class="line">	<span class="keyword">var</span> locationHref = !hrf ? <span class="built_in">window</span>.location.href : hrf;</span><br><span class="line">	locationHref = locationHref.replace(<span class="regexp">/#/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (locationHref.indexOf(<span class="string">&#x27;%&#x27;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		locationHref = <span class="built_in">unescape</span>(locationHref);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> hashes = locationHref.slice(locationHref.indexOf(<span class="string">&#x27;?&#x27;</span>) + <span class="number">1</span>).split(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; hashes.length; i++) &#123;</span><br><span class="line">		hash = hashes[i].split(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">		vars.push(hash[<span class="number">0</span>]);</span><br><span class="line">		vars[hash[<span class="number">0</span>]] = hash[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> vars;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Jquery获取radio-checkbox"><a href="#Jquery获取radio-checkbox" class="headerlink" title="Jquery获取radio,checkbox"></a>Jquery获取radio,checkbox</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取radio的id                          </span></span><br><span class="line">$(<span class="string">&quot;input[name=&#x27;r&#x27;]:checked&quot;</span>).attr(<span class="string">&quot;id&quot;</span>);  </span><br><span class="line"><span class="comment">//获得checkbox数目</span></span><br><span class="line">$(<span class="string">&quot;input[name=&#x27;c&#x27;]:checked&quot;</span>).length;</span><br><span class="line"><span class="comment">//遍历checkbox</span></span><br><span class="line">$(<span class="string">&quot;input[name=&#x27;c&#x27;]:check&quot;</span>).eq(i).attr(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="comment">//全选checkbox</span></span><br><span class="line">$(<span class="string">&quot;input[name=&#x27;c&#x27;]:checkbox&quot;</span>).attr(<span class="string">&quot;checked&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line"><span class="comment">//获取选中的checkbox  </span></span><br><span class="line">$(<span class="string">&quot;input[name=&#x27;c&#x27;]:checked&quot;</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> $(<span class="built_in">this</span>).val();&#125;).get().join(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="comment">//获取下拉框选中的id                     </span></span><br><span class="line">$(<span class="string">&quot;#s option:selected&quot;</span>).attr(<span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Jquery页面查询-数据量大时禁用"><a href="#Jquery页面查询-数据量大时禁用" class="headerlink" title="Jquery页面查询(数据量大时禁用)"></a>Jquery页面查询(数据量大时禁用)</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> nameSearch = $(<span class="string">&quot;#itemName&quot;</span>).val(); <span class="comment">//搜索框ID</span></span><br><span class="line">        <span class="keyword">var</span> tableObj = $(<span class="string">&quot;#itemList tr:gt(0)&quot;</span>); <span class="comment">// table的ID</span></span><br><span class="line">        <span class="keyword">if</span>(nameSearch.trim()!=<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">             tableObj.hide();</span><br><span class="line">             tableObj.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             	<span class="keyword">var</span> tr = $(<span class="built_in">this</span>);</span><br><span class="line">             	<span class="keyword">var</span> fuHe = tr.children(<span class="string">&quot;:eq(0)&quot;</span>).html();</span><br><span class="line">             	<span class="keyword">if</span>(fuHe.indexOf(nameSearch)==<span class="number">0</span>)&#123;</span><br><span class="line">                        tr.show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tableObj.show();</span><br><span class="line">            &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Jquery-回车-Enter-移到下一个输入框"><a href="#Jquery-回车-Enter-移到下一个输入框" class="headerlink" title="Jquery 回车(Enter)移到下一个输入框"></a>Jquery 回车(Enter)移到下一个输入框</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            $(<span class="string">&#x27;input:text:first&#x27;</span>).focus();</span><br><span class="line">            $(<span class="string">&#x27;input:text&#x27;</span>).bind(<span class="string">&quot;keydown&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (e.which == <span class="number">13</span>) &#123;       <span class="comment">//Enter key</span></span><br><span class="line">                    e.preventDefault();     <span class="comment">//to skip default behaviour of enter key</span></span><br><span class="line">                    <span class="keyword">var</span> nextinput = $(<span class="string">&#x27;input:text&#x27;</span>)[$(<span class="string">&#x27;input:text&#x27;</span>).index(<span class="built_in">this</span>) + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (nextinput != <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        nextinput.focus();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        alert(<span class="string">&quot;没有下一个输入框！&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="JS-Jquery获取各种屏幕的宽度和高度"><a href="#JS-Jquery获取各种屏幕的宽度和高度" class="headerlink" title="JS,Jquery获取各种屏幕的宽度和高度"></a>JS,Jquery获取各种屏幕的宽度和高度</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Javascript:</span></span><br><span class="line">网页可见区域宽： 	<span class="built_in">document</span>.body.clientWidth</span><br><span class="line">网页可见区域高： 	<span class="built_in">document</span>.body.clientHeight</span><br><span class="line">网页可见区域宽： 	<span class="built_in">document</span>.body.offsetWidth (包括边线的宽)</span><br><span class="line">网页可见区域高： 	<span class="built_in">document</span>.body.offsetHeight (包括边线的高)</span><br><span class="line">网页正文全文宽： 	<span class="built_in">document</span>.body.scrollWidth</span><br><span class="line">网页正文全文高： 	<span class="built_in">document</span>.body.scrollHeight</span><br><span class="line">网页被卷去的高： 	<span class="built_in">document</span>.body.scrollTop</span><br><span class="line">网页被卷去的左： 	<span class="built_in">document</span>.body.scrollLeft</span><br><span class="line">网页正文部分上： 	<span class="built_in">window</span>.screenTop</span><br><span class="line">网页正文部分左： 	<span class="built_in">window</span>.screenLeft</span><br><span class="line">屏幕分辨率的高： 	<span class="built_in">window</span>.screen.height</span><br><span class="line">屏幕分辨率的宽： 	<span class="built_in">window</span>.screen.width</span><br><span class="line">屏幕可用工作区高度： 	<span class="built_in">window</span>.screen.availHeight</span><br><span class="line">屏幕可用工作区宽度： 	<span class="built_in">window</span>.screen.availWidth</span><br><span class="line"> </span><br><span class="line"><span class="comment">//JQuery:</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert($(<span class="built_in">window</span>).height()); <span class="comment">//浏览器当前窗口可视区域高度</span></span><br><span class="line">	alert($(<span class="built_in">document</span>).height()); <span class="comment">//浏览器当前窗口文档的高度</span></span><br><span class="line">	alert($(<span class="built_in">document</span>.body).height());<span class="comment">//浏览器当前窗口文档body的高度</span></span><br><span class="line">	alert($(<span class="built_in">document</span>.body).outerHeight(<span class="literal">true</span>));<span class="comment">//浏览器当前窗口文档body的总高度 包括border padding margin</span></span><br><span class="line"></span><br><span class="line">	alert($(<span class="built_in">window</span>).width()); <span class="comment">//浏览器当前窗口可视区域宽度</span></span><br><span class="line">	alert($(<span class="built_in">document</span>).width());<span class="comment">//浏览器当前窗口文档对象宽度</span></span><br><span class="line">	alert($(<span class="built_in">document</span>.body).width());<span class="comment">//浏览器当前窗口文档body的宽度</span></span><br><span class="line">	alert($(<span class="built_in">document</span>.body).outerWidth(<span class="literal">true</span>));<span class="comment">//浏览器当前窗口文档body的总宽度 包括border padding margin</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Ajax-Get时请求异步缓存问题"><a href="#Ajax-Get时请求异步缓存问题" class="headerlink" title="Ajax,Get时请求异步缓存问题"></a>Ajax,Get时请求异步缓存问题</h2><p>用Ajax的Get方式请求同一个地址获取数据时，经常碰到回调函数成功执行，前台又有数据的情况，但是无法请求到后台获得最新的数据。原因是ajax存在<code>异步缓存</code>的问题。</p>
<p>因为ajax本身自带有实时异步请求的功能，而IE缓存导致请求时不会请求后台，会直接读取缓存的数据。</p>
<p>解决办法：</p>
<ol>
<li> ajax get请求时比较简单 只需将cache设置为false就好。</li>
</ol>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;  </span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;get&#x27;</span>,	<span class="comment">//get请求时  </span></span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;....&#x27;</span>,  </span><br><span class="line">        <span class="attr">cache</span>: <span class="literal">false</span>,	<span class="comment">//不缓存  </span></span><br><span class="line">        <span class="attr">data</span>: &#123; &#125;,  </span><br><span class="line">        <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;  </span><br><span class="line">              <span class="comment">//  </span></span><br><span class="line">         &#125;  </span><br><span class="line"> &#125;);  </span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>访问就在URL后面加上 URL?+new Date();[总之就是使每次访问的URL字符串不一样的]</p>
<p>设计WEB页面的时候 也应该遵守这个原则，因为请求同一个地址会直接读取缓存，所以可以在参数中加一个随机数数 让每次参数不一样就好。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>高可用计算架构</title>
    <url>/%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="多级缓存架构"><a href="#多级缓存架构" class="headerlink" title="多级缓存架构"></a><a href="https://www.mubucm.com/doc/2PGxjaaeQrp">多级缓存架构</a></h1><h2 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h2><ul>
<li>缓存内容</li>
<li>缓存时间</li>
<li>缓存系统</li>
<li>更新机制</li>
</ul>
<h2 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h2><ul>
<li>客户端缓存</li>
<li>CDN缓存</li>
<li>WEB容器缓存</li>
<li>应用缓存</li>
<li>分布式缓存</li>
</ul>
<div align=center><img src="../../../../images/2022/1-3/5.1_multilevel_cache.png" algin="center"/></div>

<h1 id="分布式缓存架构设计"><a href="#分布式缓存架构设计" class="headerlink" title="分布式缓存架构设计"></a><a href="https://www.mubucm.com/doc/5SyKwv7LGrp">分布式缓存架构设计</a></h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>数据缓存：实时性要求高，读多写少</li>
<li>结果缓存：计算量大实时性要求不高</li>
</ul>
<h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><ul>
<li>缓存穿透</li>
<li>缓存雪崩</li>
<li>缓存热点</li>
</ul>
<div align=center><img src="../../../../images/2022/1-3/5.2_distributed_cache.png" algin="center"/></div>

<h1 id="负载均衡架构"><a href="#负载均衡架构" class="headerlink" title="负载均衡架构"></a><a href="https://www.mubucm.com/doc/6rSJ5MVs4Hp">负载均衡架构</a></h1><div align=center><img src="../../../../images/2022/1-3/5.3_load_balancing_1.jpg" algin="center"/></div>

<ol>
<li>DNS</li>
<li>F5：100万~1000万</li>
<li>LVS：10万~100万</li>
<li>Nginx：5万~10万</li>
<li>服务路由(Gateway)：1000~5000</li>
</ol>
<div align=center><img src="../../../../images/2022/1-3/5.3_load_balancing.png" algin="center"/></div>

<h1 id="负载均衡技巧"><a href="#负载均衡技巧" class="headerlink" title="负载均衡技巧"></a><a href="https://www.mubucm.com/doc/1WhWFH8AMp">负载均衡技巧</a></h1><h2 id="通用算法"><a href="#通用算法" class="headerlink" title="通用算法"></a>通用算法</h2><ul>
<li>轮训</li>
<li>随机</li>
<li>加权轮训</li>
<li>负载有限</li>
<li>性能优先</li>
<li>hash</li>
</ul>
<h2 id="服务器性能估算"><a href="#服务器性能估算" class="headerlink" title="服务器性能估算"></a>服务器性能估算</h2><h3 id="接口性能"><a href="#接口性能" class="headerlink" title="接口性能"></a>接口性能</h3><ol>
<li>线上业务服务器接口处理时间分布为 20~100ms；</li>
<li>平均大约为 50ms；</li>
<li> 访问存储或者其它系统接口是主要的性能消耗点。</li>
</ol>
<h3 id="服务器性能"><a href="#服务器性能" class="headerlink" title="服务器性能"></a>服务器性能</h3><p>线上单个服务器（32核）性能大约为 300~1000 TPS/QPS</p>
<h3 id="服务器数量"><a href="#服务器数量" class="headerlink" title="服务器数量"></a>服务器数量</h3><p>服务器数量 = (总 TPS+QPS) / 单个服务器性能</p>
<div align=center><img src="../../../../images/2022/1-3/5.4_load_balancing_techniques.png" algin="center"/></div>

<h1 id="接口高可用"><a href="#接口高可用" class="headerlink" title="接口高可用"></a><a href="https://www.mubucm.com/doc/6eQCM4fSZwp">接口高可用</a></h1><ul>
<li>限流</li>
<li>排队</li>
<li>降级</li>
<li>熔断</li>
</ul>
<div align=center><img src="../../../../images/2022/1-3/5.5_interface_high_availability.png" algin="center"/></div>

]]></content>
      <categories>
        <category>架构</category>
        <category>设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA并发之锁</title>
    <url>/JAVA%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%94%81/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>锁作为并发共享数据，保证一致性的工具，数据库中有悲观锁、乐观锁等实现。在JAVA平台同样有多种实现(如 <code>synchronized</code>和<code>Lock</code>)。这些已经写好提供的锁为开发提供了便利，让我们有了更多的选择。<div align=center><img src="../../../../images/2018-5/JAVA%E2%80%94Lock/index.jpg"/></div><span id="more"></span></p>
<h1 id="JAVA中锁分类"><a href="#JAVA中锁分类" class="headerlink" title="JAVA中锁分类"></a>JAVA中锁分类</h1><h2 id="乐观-悲观锁"><a href="#乐观-悲观锁" class="headerlink" title="乐观/悲观锁"></a>乐观/悲观锁</h2><p><strong>乐观锁</strong>：乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据，乐观的认为不加锁的并发操作是没有事情的。<strong>适合读操作多的场景</strong>。</p>
<p>乐观锁在JAVA中的使用，是无锁编程，Java中<em>java.util.concurrent.atomic</em>包下面的原子变量类就是使用了乐观锁的一种实现方式CAS(<em>CompareAndSwap</em>)实现的。</p>
<blockquote>
<p>CAS是乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。　　　</p>
<p>CAS操作中包含三个操作数 —— *<em>内存值(V)<strong>、</strong>旧的的预期原值(A)<strong>和</strong>拟写入的新值(B)*<em>。如果内存值</em>V<em>的值与预期原值</em>A<em>相匹配，那么处理器会自动将该位置值更新为新值</em>B*，否则处理器不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值。(在CAS的一些特殊情况下将仅返回CAS是否成功，而不提取当前值)。CAS有效地说明了“我认为位置</em>V<em>应该包含值</em>A<em>；如果包含该值，则将</em>B*放到这个位置；否则，不要更改该值，只告诉我这个位置现在的值即可“。</p>
<p>CAS缺点：ABA问题。</p>
</blockquote>
<p><strong>悲观锁</strong>：悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。<strong>适合写操作多的场景</strong>。Java里面的同步语义<code>synchronized关键字的实现是悲观锁</code>。</p>
<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。JAVA中的<strong>synchronized与ReentrantLock都是可重入锁</strong>。可重入锁的一个好处是可一定程度避免死锁。</p>
<ul>
<li>对于Java <code>ReentrantLock</code>而言, 他的名字就可以看出是一个可重入锁，其名字是<code>ReentrantLock</code>重新进入锁。</li>
<li>对于<code>synchronized</code>而言，也是一个可重入锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    methodB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，<em>methodB</em>可能不会被当前线程执行，可能造成死锁。</p>
<h2 id="独占-共享锁"><a href="#独占-共享锁" class="headerlink" title="独占/共享锁"></a>独占/共享锁</h2><p><strong>独占锁</strong>：是指该锁一次只能被一个线程所持有。<br><strong>共享锁</strong>：是指该锁可被多个线程所持有。</p>
<ul>
<li>对于Java <code>ReentrantLock</code>而言，其是独占锁(互斥锁)。但是对于Lock的另一个实现类<code>ReadWriteLock</code>，其读锁是共享锁(读写锁)，其写锁是独占锁。</li>
<li>读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。</li>
<li>独占锁与共享锁也是通过AQS(<em>AbstractQueuedSynchronizer</em>[<em>队列同步器</em>])来实现的，通过实现不同的方法，来实现独占或者共享。</li>
<li>对于<code>synchronized</code>而言，是独占锁。</li>
</ul>
<h2 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h2><p>分段锁其实是一种锁的设计，并不是具体的一种锁，对于<code>ConcurrentHashMap</code>而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</p>
<p>以<code>ConcurrentHashMap</code>来说一下分段锁的含义以及设计思想，<code>ConcurrentHashMap</code>中的分段锁称为<em>Segment</em>，它即类似于HashMap(JDK7与JDK8中HashMap的实现)的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个<code>ReentrantLock</code>(<em>Segment</em>继承了<code>ReentrantLock</code>)。<br>当需要<em>put</em>元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在哪一个分段中，然后对这个分段进行加锁，所以当多线程<em>put</em>的时候，只要不是放在同一个分段中，就实现了真正的并行插入。<br>但是，在统计size的时候，就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。<br><strong>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作</strong>。</p>
<h1 id="synchronized锁"><a href="#synchronized锁" class="headerlink" title="synchronized锁"></a>synchronized锁</h1><p><code>synchronized</code>是Java的一个<strong>关键字</strong>，它能够将<strong>代码块(方法)锁起来</strong>，它是在软件层面依赖<code>JVM</code>实现同步。</p>
<ul>
<li>它使用起来是非常简单的，只要在代码块(方法)添加关键字<code>synchronized</code>，即可以实现同步的功能。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// doSomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>synchronized</code>是一种<strong>互斥锁</strong>。</p>
<ul>
<li><strong>一次只能允许一个线程进入被锁住的代码块</strong></li>
</ul>
<p><code>synchronized</code>是一种<strong>内置锁/监视器锁</strong>。</p>
<ul>
<li>Java中<strong>每个对象</strong>都有一个**内置锁(监视器,也可以理解成锁标记)<strong>，而<code>synchronized</code>就是使用</strong>对象的内置锁(监视器)**来将代码块(方法)锁定的。</li>
</ul>
<h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><ol>
<li><code>synchronized</code>保证了线程的<strong>原子性</strong>。(被保护的代码块是一次被执行的，没有任何线程会同时访问)。</li>
<li><code>synchronized</code>保证了<strong>可见性</strong>。(当执行完<code>synchronized</code>之后，修改后的变量对其他的线程是可见的)。</li>
</ol>
<p>Java中的<code>synchronized</code>，通过使用内置锁，来实现对变量的同步操作，进而实现了<strong>对变量操作的原子性和其他线程对变量的可见性</strong>，从而确保了并发情况下的线程安全。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>下面是<code>synchronized</code>修饰方法和代码块的代码实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="comment">//修饰方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">// 修饰代码块</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">		<span class="comment">// dosomething</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译结果如下图：</p>
<div align=center><img src="../../../../images/2018-5/JAVA%E2%80%94Lock/sync.png"/></div>

<ul>
<li><strong>同步代码块</strong>：<em>monitorenter</em>和<em>monitorexit</em>指令实现的。</li>
<li><strong>同步方法</strong>（在这看不出来需要看JVM底层实现）：方法修饰符上的<em>ACC_SYNCHRONIZED</em>实现。</li>
</ul>
<p><code>synchronized</code>底层是是<strong>通过monitor对象，对象有自己的对象头，存储了很多信息，其中一个信息标示是被哪个线程持有</strong>。</p>
<h2 id="synchronized的使用"><a href="#synchronized的使用" class="headerlink" title="synchronized的使用"></a>synchronized的使用</h2><p><code>synchronized</code>一般用来修饰三种东西：</p>
<ul>
<li>修饰普通方法</li>
<li>修饰代码块</li>
<li>修饰静态方法</li>
</ul>
<h3 id="修饰普通方法"><a href="#修饰普通方法" class="headerlink" title="修饰普通方法"></a>修饰普通方法</h3><p>用的锁是<strong>SyncTest对象(内置锁)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰普通方法，此时用的锁是SyncTest对象(内置锁)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// doSomething</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h3><p>用的锁是**SyncTest对象(内置锁) ** —&gt; this</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 修饰代码块，此时用的锁是SyncTest对象(内置锁)---&gt;this</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="comment">// doSomething</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修饰静态方法"><a href="#修饰静态方法" class="headerlink" title="修饰静态方法"></a>修饰静态方法</h3><p>用的锁是<strong>类锁</strong>，锁的是SyncTest类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.修饰代码块，此时用的锁是SyncTest类锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// doSomething</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 2.修饰类的class</span></span><br><span class="line">  	<span class="keyword">synchronized</span>(SyncTest.class) &#123;</span><br><span class="line">        <span class="comment">// doSomething</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类锁与对象锁"><a href="#类锁与对象锁" class="headerlink" title="类锁与对象锁"></a>类锁与对象锁</h2><p><code>synchronized</code>修饰静态方法获取的是<strong>类锁</strong>(类的字节码文件对象)，<code>synchronized</code>修饰普通方法或代码块获取的是<strong>对象锁</strong>。</p>
<p>一个锁的是类对象，一个锁的是实例对象。<br>若类对象被lock，则类对象的所有同步方法全被lock；<br>若实例对象被lock，则该实例对象的所有同步方法全被lock。</p>
<ul>
<li><em>synchronized static</em>是某个类的范围，防止<strong>多个线程中多个实例</strong>同时访问这个类中的<em>synchronized static</em>方法。它可以对类的所有对象实例起作用。</li>
<li><em>synchronized</em>是某实例的范围，<em>synchronized</em>防止<strong>多个线程中同一个实例</strong>同时访问这个类的<em>synchronized</em> 方法。</li>
</ul>
<p>它们互不冲突，也就是说：<strong>获取了类锁的线程和获取了对象锁的线程是不冲突的。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchoronizedDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// synchronized修饰非静态方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;function running...&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// synchronized修饰静态方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">staticFunction</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;Static function running...&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> SynchoronizedDemo demo = <span class="keyword">new</span> SynchoronizedDemo();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建线程执行静态方法</span></span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				staticFunction();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建线程执行实例方法</span></span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				demo.function();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="comment">// 启动</span></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果证明：<strong>类锁和对象锁是不会冲突的</strong>！</p>
<div align=center><img width="900" height="200" src="../../../../images/2018-5/JAVA%E2%80%94Lock/console.png"/>

</div>

<h2 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 加锁</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加锁</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(toString() + <span class="string">&quot;: calling doSomething&quot;</span>);</span><br><span class="line">		<span class="keyword">super</span>.doSomething();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>当线程A进入到<em>LoggingWidget</em>的<code>doSomething()</code>方法时，<strong>此时拿到了LoggingWidget实例对象的锁</strong>。</li>
<li>随后在方法上又调用了父类<em>Widget</em>的<code>doSomething()</code>方法，它<strong>又是被synchronized修饰</strong>。</li>
<li>那现在我们<em>LoggingWidget</em>实例对象的锁还没有释放，进入父类Widget的<code>doSomething()</code>方法<strong>还需要一把锁吗？</strong></li>
</ol>
<p><strong>不需要的！</strong></p>
<p>因为<strong>锁的持有者是“线程”，而不是“调用”</strong>。线程A已经是有了<em>LoggingWidget</em>实例对象的锁了，当再需要的时候可以继续<strong>“开锁”</strong>进去的！</p>
<p>这就是内置锁的<strong>可重入性</strong>。</p>
<h2 id="释放锁的时机"><a href="#释放锁的时机" class="headerlink" title="释放锁的时机"></a>释放锁的时机</h2><ol>
<li>当方法(代码块)执行完毕后会<strong>自动释放锁</strong>，不需要做任何的操作。</li>
<li><strong>当一个线程执行的代码出现异常时，其所持有的锁会自动释放</strong>。</li>
</ol>
<p>不会由于异常导致出现死锁现象。</p>
<h1 id="Lock显式锁"><a href="#Lock显式锁" class="headerlink" title="Lock显式锁"></a>Lock显式锁</h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>Lock显式锁是JDK1.5之后才有的，之前都是使用<code>synchronized</code>锁来使线程安全的。</p>
<p>Lock显式锁是一个接口</p>
<div align=center><img width="600" height="200" src="../../../../images/2018-5/JAVA%E2%80%94Lock/lock_1.png"/>

</div>

<div align=center><img width="900" height="1500" src="../../../../images/2018-5/JAVA%E2%80%94Lock/lock_2.png"/></div>

<ul>
<li>Lock方式来获取锁<strong>支持中断、超时不获取、是非阻塞的。</strong></li>
<li><strong>提高了语义化</strong>，哪里加锁，哪里解锁都得写出来。</li>
<li><strong>Lock显式锁可以给我们带来很好的灵活性，但同时必须手动释放锁</strong>。</li>
<li>支持Condition条件对象。</li>
<li><strong>允许多个读线程同时访问共享资源</strong>。</li>
</ul>
<h2 id="常用方式"><a href="#常用方式" class="headerlink" title="常用方式"></a>常用方式</h2><p>Lock接口，它提供了比<code>synchronized</code>更加广泛的锁定操作。Lock接口有3个实现它的类：<em>ReentrantLock</em>、<em>ReetrantReadWriteLock.ReadLock</em>和<em>ReetrantReadWriteLock.WriteLock</em>，即重入锁、读锁和写锁。</p>
<p>lock必须被显式地创建、锁定和释放，为了可以使用更多的功能，一般用<code>ReentrantLock</code>为其实例化。<strong>为了保证锁最终一定会被释放(可能会有异常发生)，要把互斥区放在try语句块内，并在finally语句块中释放锁，尤其当有return语句时，return语句必须放在try字句中，以确保unlock()不会过早发生，从而将数据暴露给第二个任务。</strong>因此，采用lock加锁和释放锁的一般形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认使用非公平锁，如果要使用公平锁，需要传入参数true  </span></span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">........  </span><br><span class="line">lock.lock();  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">     <span class="comment">// 更新对象的状态  </span></span><br><span class="line">     <span class="comment">// 捕获异常，必要时恢复到原来的不变约束  </span></span><br><span class="line">     <span class="comment">// 如果有return语句，放在这里  </span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="comment">// 锁必须在finally块中释放</span></span><br><span class="line">     lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现策略"><a href="#实现策略" class="headerlink" title="实现策略"></a>实现策略</h2><p>Lock基于冲突检测的<strong>乐观并发策略</strong>，如果没有其他线程争用共享数据，那操作就成功了，如果共享数据被争用，产生了冲突，那就再进行其他的补偿措施(最常见的补偿措施就是不断地重试，直到试成功为止)，这种乐观并发策略的许多实现都不需要把线程挂起，因此这种同步被称为<code>非阻塞同步</code>。<strong>ReetrantLock采用的便是这种并发策略。</strong></p>
<p>在乐观的并发策略中，需要操作和冲突检测这两个步骤具备原子性，它靠<strong>硬件指令来保证</strong>，这里用的是CAS操作(<em>Compare and Swap</em>)。JDK1.5之后，Java程序才可以使用CAS操作。进一步研究<code>ReentrantLock</code>的源代码，会发现其中比较重要的获得锁的一个方法是<em>compareAndSetState</em>，这里其实就是调用的CPU提供的特殊指令。现代的CPU提供了指令，可以自动更新共享数据，而且能够检测到其他线程的干扰，而<code>compareAndSet()</code>就用这些代替了锁定。这个算法称作非阻塞算法，意思是一个线程的失败或者挂起不应该影响其他线程的失败或挂起。</p>
<p>Java 5中引入了注入<em>AutomicInteger、AutomicLong、AutomicReference</em>等特殊的原子性变量类，它们提供的如：<code>compareAndSet()</code>、<code>incrementAndSet()</code>和<code>getAndIncrement()</code>等方法都使用了CAS操作。因此，它们都是由硬件指令来保证的原子方法。</p>
<h1 id="ReetrankLock与synchronized比较"><a href="#ReetrankLock与synchronized比较" class="headerlink" title="ReetrankLock与synchronized比较"></a>ReetrankLock与synchronized比较</h1><h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><p>在JDK1.5中，<code>synchronized</code>是性能低效的。因为这是一个重量级操作，它对性能最大的影响是阻塞的是实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性带来了很大的压力。相比之下使用Java提供的Lock对象，性能更高一些。</p>
<p>到了JDK1.6，对<code>synchronize</code>加入了很多优化措施，有自适应自旋、锁消除、锁粗化、轻量级锁、偏向锁等等。</p>
<p>在JDK1.8以后，对<code>synchronized</code>性能进行了优化，使其和<code>ReentrantLock</code>的性能相差不多。所以还是提倡在<code>synchronized</code>能实现需求的情况下，<strong>优先考虑使用<code>synchronized</code>来进行同步</strong>。</p>
<h2 id="实现策略-1"><a href="#实现策略-1" class="headerlink" title="实现策略"></a>实现策略</h2><p><code>synchronized</code>采用的是互斥同步，因而这种同步又称为阻塞同步，它属于一种<strong>悲观的并发策略</strong>，即线程获得的是<strong>独占锁</strong>。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁，<code>synchronized</code>是托管给JVM执行的。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。</p>
<p><code>Lock</code>基于乐观的并发策略，是Java写的控制锁的代码，基于CAS硬件指令保证。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>基本语法上，<code>ReentrantLock</code>与<code>synchronized</code>很相似，它们都具备一样的线程重入特性，只是代码写法上有点区别而已，一个表现为<strong>API层面的互斥锁</strong>(lock和unlock方法配合try/finally语句块来完成)，一个表现为<strong>原生语法层面的互斥锁(</strong><code>synchronized</code>)。<code>ReentrantLock</code>相对<code>synchronized</code>而言还是增加了一些高级功能，主要有以下三项：</p>
<h3 id="等待可中断"><a href="#等待可中断" class="headerlink" title="等待可中断"></a>等待可中断</h3><p>当持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待，改为处理其他事情，它对处理执行时间非常长的同步块很有帮助。而在等待由<code>synchronized</code>产生的互斥锁时，会一直阻塞，是不能被中断的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();  </span><br><span class="line">...........  </span><br><span class="line">lock.lockInterruptibly();<span class="comment">//获取响应中断锁  </span></span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">      <span class="comment">// 更新对象的状态  </span></span><br><span class="line">      <span class="comment">// 捕获异常，必要时恢复到原来的不变约束  </span></span><br><span class="line">      <span class="comment">// 如果有return语句，放在这里  </span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;  </span><br><span class="line">	<span class="comment">// 锁必须在finally块中释放</span></span><br><span class="line">    lock.unlock();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="可实现公平锁"><a href="#可实现公平锁" class="headerlink" title="可实现公平锁"></a>可实现公平锁</h3><p>多个线程在等待同一个锁时，必须按照申请锁的时间顺序排队等待，而非公平锁则不保证这点，在锁释放时，任何一个等待锁的线程都有机会获得锁。<code>synchronized</code>中的锁时非公平锁，<strong>ReentrantLock默认情况下也是非公平锁</strong>，但可以通过构造方法<code>ReentrantLock(ture)</code>来要求使用公平锁，公平锁会来带一些性能的消耗。</p>
<h3 id="锁绑定多个条件"><a href="#锁绑定多个条件" class="headerlink" title="锁绑定多个条件"></a>锁绑定多个条件</h3><p><code>ReentrantLock</code>对象可以同时绑定多个<em>Condition</em>对象(条件变量或条件队列)，而在<code>synchronized</code>中，锁对象的<em>wait()<em>和</em>notify()<em>或</em>notifyAll()<em>方法可以实现一个隐含条件，但如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而<code>ReentrantLock</code>则无需这么做，只需要多次调用</em>newCondition()<em>方法即可。还可以通过绑定</em>Condition</em>对象来判断当前线程通知的是哪些线程(即与<em>Condition</em>对象绑定在一起的其他线程)。</p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p><code>synchronized</code>获取的互斥锁不仅互斥读写操作、写写操作，还互斥读读操作，而读读操作是不会带来数据竞争的，因此对对读读操作也互斥的话，会降低性能。Java5中提供了读写锁，它将读锁和写锁分离，使得读读操作不互斥，获取读锁和写锁的一般形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();      </span><br><span class="line">rwl.writeLock().lock()  <span class="comment">//获取写锁  </span></span><br><span class="line">rwl.readLock().lock()   <span class="comment">//获取读锁  </span></span><br></pre></td></tr></table></figure>

<p>用读锁来锁定读操作，用写锁来锁定写操作，这样写操作和写操作之间会互斥，读操作和写操作之间会互斥，但读操作和读操作就不会互斥。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>介绍了<code>synchronized</code>内置锁和<code>Lock</code>显式锁，总得来说：</p>
<ul>
<li><strong>synchronized好用，简单，性能不差</strong></li>
<li>没有使用到Lock显式锁的特性就不要使用Lock锁了。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.im/post/5adf14dcf265da0b7b358d58"><em>Java锁机制了解一下</em></a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM入门</title>
    <url>/JVM%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>JVM（Java Virtual Machine）Java 虚拟机是整个 Java 平台的基石，是 Java 系统实现硬件无关与操作系统无关的关键部分，是保障用户机器免于恶意代码损害的屏障。Java开发人员不需要了解JVM是如何工作的，但是，了解 JVM 有助于我们更好的开发java 程序。近些天一直在看周志明的《深入理解Java虚拟机》这本书，这本书写的堪称经典，对于JVM的学习非常有帮助。<div align=center><img width="700" height="300" src="../../../../images/2017-12-04/JVM/jvm.png" algin="center"/></p>
</div><span id="more"></span>

<h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>JVM将内存主要划分为：方法区、虚拟机栈、本地方法栈、堆、程序计数器。JVM运行时数据区如下： </p>
<div align=center><img width="700" height="300" src="../../../../images/2017-12-04/JVM/jmm.png" algin="center"/>

</div>

<h2 id="程序计数器-线程私有"><a href="#程序计数器-线程私有" class="headerlink" title="程序计数器(线程私有)"></a><strong>程序计数器(线程私有)</strong></h2><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，<code>分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</code>。</p>
<p>由于Java虚拟机的虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，所以程序计数器是私有空间。</p>
<p>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h2 id="Java虚拟机栈-线程私有"><a href="#Java虚拟机栈-线程私有" class="headerlink" title="Java虚拟机栈(线程私有)"></a>Java虚拟机栈(线程私有)</h2><p>生命周期与线程相同。“栈”就是虚拟机栈，或者说是虚拟机栈中局部变量表部分。</p>
<p>局部变量表存放了编译期可知的基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress（指向了一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用一个。</p>
<p>这个区域可能出现的两种异常：</p>
<ul>
<li>一种是StackOverflowError，当前线程请求的栈深度大于虚拟机所允许的深度时，会抛出这个异常。制造这种异常很简单：将一个函数反复递归自己，最终会出现栈溢出错误（StackOverflowError）。</li>
<li>另一种异常是OutOfMemoryError异常，当虚拟机栈可以动态扩展时（当前大部分虚拟机都可以），如果无法申请足够多的内存就会抛出OutOfMemoryError，</li>
</ul>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与虚拟机所发挥的作用很相似，他们的区别在于虚拟机栈为执行Java代码方法服务，而<code>本地方法栈是为Native方法服务</code>。与虚拟机栈一样，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<h2 id="Java堆-线程共享区域"><a href="#Java堆-线程共享区域" class="headerlink" title="Java堆(线程共享区域)"></a>Java堆(线程共享区域)</h2><p>Java堆是Java虚拟机所管理内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此区域内存的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。在Java虚拟机规范中的描述就是：<strong>所有对象实例及数组都要在堆上分配</strong>。随着JIT编译器的发展，所有对象在堆上分配渐渐变得不那么“绝对”了。</p>
<p>Java堆是垃圾收集器管理的主要区域。由于现在的收集器基本上采用的都是分代收集算法，所有Java堆可以细分为：新生代和老年代。在细致分就是把新生代分为：Eden空间、From Survivor空间、To Survivor空间。</p>
<p>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像磁盘空间一样。</p>
<p>当堆无法再扩展时，会抛出OutOfMemoryError异常。</p>
<h2 id="方法区-线程共享区域"><a href="#方法区-线程共享区域" class="headerlink" title="方法区(线程共享区域)"></a><strong>方法区(线程共享区域)</strong></h2><p><strong>方法区存放的是类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。方法区是各个线程共享区域，我们在写Java代码时，每个线程度可以访问同一个类的静态变量对象。由于使用反射机制的原因，虚拟机很难推测那个类信息不再使用，因此这块区域的回收很难。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</span><br></pre></td></tr></table></figure>

<p>另外，对这块区域主要是针对常量池回收，值得注意的是JDK1.7已经把常量池转移到堆里面了。同样，当方法区无法满足内存分配需求时，会抛出OutOfMemoryError。 </p>
<h1 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h1><p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。</p>
<h2 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法(Mark-Sweep)"></a>标记-清除算法(Mark-Sweep)</h2><p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p>
<p>它的不足主要有两个：</p>
<ol>
<li>效率问题，标记和清除两个过程效率都不高；</li>
<li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ol>
<div align=center><img width="700" height="300" src="../../../../images/2017-12-04/JVM/Mark-Sweep.png" algin="center"/>

</div>

<h2 id="复制算法-Copy"><a href="#复制算法-Copy" class="headerlink" title="复制算法(Copy)"></a>复制算法(Copy)</h2><p>为了解决效率问题，复制算法是将内存分为大小相同的两块，每次只使用其中一块。当这块内存用完了，就将还存活的对象复制到另一块内存上面。然后再把已经使用过的内存一次清理掉。这使得每次只对半个区域进行垃圾回收，内存分配时也不用考虑内存碎片情况。</p>
<p>但是，这代价实在是让人无法接受，需要牺牲一般的内存空间。</p>
<p>研究发现，大部分对象(70%~95%)都是“朝生夕死”，所以不需要安装1:1比例划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和一块Survivor空间，默认比例为Eden：Survivor=8:1。新生代区域就是这么划分，每次实例在Eden和一块Survivor中分配，回收时，将存活的对象复制到剩下的另一块Survivor。这样只有10%的内存会被浪费，但是带来的效率却很高。</p>
<p>当剩下的Survivor内存不足时，可以去老年代内存进行分配担保。如何理解分配担保呢，其实就是，内存不足时，去老年代内存空间分配，然后等新生代内存缓过来了之后，把内存归还给老年代，保持新生代中的Eden：Survivor=8:1.另外，两个Survivor分别有自己的名称：From Survivor、To Survivor。二者身份经常调换，即有时这块内存与Eden一起参与分配，有时是另一块。因为他们之间经常相互复制。</p>
<div align=center><img width="700" height="300" src="../../../../images/2017-12-04/JVM/copy.png" algin="center"/>

</div>

<h2 id="标记整理-Mark-Compact"><a href="#标记整理-Mark-Compact" class="headerlink" title="标记整理(Mark-Compact)"></a>标记整理(Mark-Compact)</h2><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外打的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p>标记整理算法很简单，就是先标记需要回收的对象，然后把所有存活的对象移动到内存的一端，最后直接清理掉边界意外的内存。这样的好处是避免了内存碎片。</p>
<div align=center><img width="700" height="300" src="../../../../images/2017-12-04/JVM/gc_mark_compact.png" algin="center"/>

</div>

<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>当前商业虚拟机的垃圾收集都采用“分代收集”算法，这种算法只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
<p>在新生代中，每次垃圾收集时都发现有大批对象死去（70%-95%），只有少量存活，那就采用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外的空间对它进行分配担保，就必须使用“标记-清除”或“标记-整理”算法来进行回收。</p>
<h1 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h1><h2 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h2><p>可达性分析判断jvm对象是否存活。GCRoots的对象做为起点，从起点开始向下搜索，搜索走过路径叫引用链，当一个对象到GCRoots没有引用链时，判断对象死亡。<br>在jvm中，做为GCRoots的对象：</p>
<ol>
<li>虚拟机栈(栈桢中的本地变量表)中的引用的对象;</li>
<li>方法区中的类静态属性引用的对象;</li>
<li>方法区中的常量引用的对象;</li>
<li>本地方法栈中JNI的引用的对象 。</li>
</ol>
<div align=center><img width="700" height="300" src="../../../../images/2017-12-04/JVM/reachability.jpg" algin="center"/>

</div>

<p>从可达性分析中从GC Roots节点找引用链这个操作为例，可做为GC Roots的节点主要在全局性的引用（类如常量或类静态变量）与执行上下文（类如栈桢的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的应用，那么必然会逍遥很多的时间。</p>
<p>可达性分析对执行时间的敏感还体现在GC停顿上，因为分析工作必须要再一个能确保一致性的快照中进行这是导致GC进行时必须停顿所有Java线程（STW）的其中一个重要原因，<em>即使在号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</em></p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p>
<p>Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。</p>
<div align=center><img width="700" height="300" src="../../../../images/2017-12-04/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" algin="center"/>

</div>

<p>图中展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。</p>
<h3 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h3><ol>
<li><p><strong>并发和并行</strong><br>这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，它们可以解释如下。</p>
<ul>
<li><strong>并行（Parallel）</strong>：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</li>
</ul>
</li>
<li><p><strong>Minor GC 和 Full GC</strong></p>
<ul>
<li><strong>新生代GC（Minor GC）</strong>：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</li>
<li><strong>老年代GC（Major GC / Full GC）</strong>：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</li>
</ul>
</li>
<li><p><strong>吞吐量</strong></p>
<p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。<br>虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
</li>
</ol>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。</p>
<div align=center><img width="700" height="300" src="../../../../images/2017-12-04/JVM/serial.png" algin="center"/>

</div>

<ol>
<li><strong>特性：</strong><br>这个收集器是一个<code>单线程</code>的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。<code>Stop The World</code>(STW)</li>
<li><strong>应用场景：</strong><br>Serial收集器是虚拟机运行在Client模式下的默认新生代收集器。</li>
<li><strong>优势：</strong><br>简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</li>
</ol>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><div align=center><img width="700" height="300" src="../../../../images/2017-12-04/JVM/parnew.png" algin="center"/>

</div>

<ol>
<li><strong>特性：</strong><br>ParNew收集器其实就是Serial收集器的<strong>多线程版本</strong>，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。</li>
<li><strong>应用场景：</strong><br>ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器。</li>
</ol>
<p>很重要的原因是：<code>除了Serial收集器外，目前只有它能与CMS收集器配合工作。</code><br>在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器——CMS收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。<br>不幸的是，CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK 1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</p>
<p><strong>Serial收集器 VS ParNew收集器：</strong><br>ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越Serial收集器。<br>然而，随着可以使用的CPU的数量的增加，它对于GC时系统资源的有效利用还是很有好处的。</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><ol>
<li><strong>特性：</strong><br>Parallel Scavenge收集器是一个<strong>新生代收集器</strong>，它也是使用<strong>复制算法</strong>的收集器，又是<strong>并行</strong>的多线程收集器。</li>
<li><strong>应用场景：</strong><br>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</li>
<li><strong>对比分析：</strong></li>
</ol>
<ul>
<li><p><strong>Parallel Scavenge收集器 VS CMS等收集器：</strong><br>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个<strong>可控制的吞吐量</strong>（Throughput）。<br>由于与吞吐量关系密切，Parallel Scavenge收集器也经常称为“吞吐量优先”收集器。</p>
</li>
<li><p><strong>Parallel Scavenge收集器 VS ParNew收集器：</strong><br>Parallel Scavenge收集器与ParNew收集器的一个重要区别是它具有自适应调节策略。</p>
<p><strong>GC自适应的调节策略</strong>：<br>Parallel Scavenge收集器有一个参数-<code>XX:+UseAdaptiveSizePolicy</code>。当这个参数打开之后，就不需要手工指定新生代的大小、Eden与Survivor区的比例、晋升老年代对象年龄等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。</p>
</li>
</ul>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><div align=center><img width="700" height="300" src="../../../../images/2017-12-04/JVM/Serial-Old.png" algin="center"/>

</div>

<ol>
<li><strong>特性：</strong><br>Serial Old是Serial收集器的<strong>老年代版本</strong>，它同样是一个<strong>单线程收集器</strong>，使用<strong>标记－整理</strong>算法。</li>
<li><strong>应用场景：</strong></li>
</ol>
<ul>
<li><strong>Client模式</strong><br>Serial Old收集器的主要意义也是在于给Client模式下的虚拟机使用。</li>
<li><strong>Server模式</strong><br>如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</li>
</ul>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a><strong>Parallel Old收集器</strong></h3><div align=center><img width="700" height="300" src="../../../../images/2017-12-04/JVM/Parallel-Old.png" algin="center"/>

</div>

<ol>
<li><strong>特性：</strong><br>Parallel Old是Parallel Scavenge收集器的<strong>老年代版本</strong>，使用<strong>多线程</strong>和<strong>“标记－整理”</strong>算法。</li>
<li><strong>应用场景：</strong><br>在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。</li>
</ol>
<p>这个收集器是在JDK 1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old收集器外别无选择（Parallel Scavenge收集器无法与CMS收集器配合工作）。由于老年代Serial Old收集器在服务端应用性能上的“拖累”，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合“给力”。直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a><strong>CMS收集器</strong></h3><div align=center><img width="700" height="300" src="../../../../images/2017-12-04/JVM/CMS.png" algin="center"/>

</div>

<ol>
<li><p>特性：</p>
<p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。<code>CMS收集器是基于“标记—清除”算法实现的</code>，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤：</p>
</li>
</ol>
<ul>
<li><strong>初始标记（CMS initial mark）</strong><br>初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。</li>
<li><strong>并发标记（CMS concurrent mark）</strong><br>并发标记阶段就是进行GC Roots Tracing的过程。</li>
<li><strong>重新标记（CMS remark）</strong><br>重新标记阶段是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短，仍然需要“Stop The World”。</li>
<li><strong>并发清除（CMS concurrent sweep）</strong><br>并发清除阶段会清除对象。</li>
</ul>
<p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<ol>
<li><strong>优点：</strong><br>CMS是一款优秀的收集器，它的主要优点在名字上已经体现出来了：<strong>并发收集</strong>、<strong>低停顿</strong>。</li>
<li><strong>缺点：</strong></li>
</ol>
<ul>
<li><p><strong>CMS收集器对CPU资源非常敏感</strong><br>其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。<br>CMS默认启动的回收线程数是（CPU数量+3）/ 4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个（譬如2个）时，CMS对用户程序的影响就可能变得很大。</p>
</li>
<li><p><strong>CMS收集器无法处理浮动垃圾</strong><br>CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。</p>
<p>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。<br>也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p>
</li>
<li><p><strong>CMS收集器会产生大量空间碎片</strong><br>CMS是一款基于“标记—清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。</p>
<p>空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。</p>
</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a><strong>G1收集器</strong></h3><div align=center><img width="700" height="300" src="../../../../images/2017-12-04/JVM/G1.png" algin="center"/>

</div>

<ol>
<li><strong>特性：</strong><br>G1（Garbage-First）是一款面向<strong>服务端应用</strong>的垃圾收集器。HotSpot开发团队赋予它的使命是未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点。</li>
</ol>
<ul>
<li><strong>并行与并发</strong><br>G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li>
<li><strong>分代收集</strong><br>与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</li>
<li><strong>空间整合</strong><br>与CMS的“标记—清理”算法不同，G1从<strong>整体来看是基于“标记—整理”</strong>算法实现的收集器，从<strong>局部（两个Region之间）上来看是基于“复制”</strong>算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</li>
<li><strong>可预测的停顿</strong><br>这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</li>
</ul>
<p>在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p>
<p>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p>
<ol>
<li><strong>执行过程：</strong><br>G1收集器的运作大致可划分为以下几个步骤：</li>
</ol>
<ul>
<li><strong>初始标记（Initial Marking）</strong><br>初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。</li>
<li><strong>并发标记（Concurrent Marking）</strong><br>并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。</li>
<li><strong>最终标记（Final Marking）</strong><br>最终标记阶段是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程<code>Remembered Set Logs</code>里面，最终标记阶段需要把<code>Remembered Set Logs</code>的数据合并到<code>Remembered Set</code>中，这阶段需要停顿线程，但是可并行执行。</li>
<li><strong>筛选回收（Live Data Counting and Evacuation）</strong><br>筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</li>
</ul>
<p><strong>CMS收集器 VS G1收集器：</strong></p>
<p>G1收集器几乎可以说还没有经过实际应用的考验，网络上关于G1收集器的性能测试也非常贫乏，如果现在采用的收集器没有出现任何问题，那就没有理由现在去选择G1，如果应用追求低停顿，那G1现在已经可以作为一个可尝试的选择，如果应用追求吞吐量，那么G1并不会带来什么特别的好处。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>内存回收与垃圾收集器在很多时候都是影响系统性能、并发能力的主要因素之一，虚拟机之所以提供多种不同的收集器以及提供大量的调节参数，是因为只有根据实际应用需求，实现方式选择最优的收集方式才能获取最高的性能，没有固定收集器、参数组合，也就没有最优的调优方法，虚拟机也有没有什么必然的内存回收行为。</p>
<p>虽然我们是在对各个收集器进行比较，但并非为了挑选出一个最好的收集器。因为直到现在为止还没有最好的收集器出现，更加没有万能的收集器，所以我们选择的只是对具体应用最合适的收集器。这点不需要多加解释就能证明：如果有一种放之四海皆准、任何场景下都适用的完美收集器存在，那HotSpot虚拟机就没必要实现那么多不同的收集器了。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Java混淆工具-ProGuard</title>
    <url>/Java%E6%B7%B7%E6%B7%86%E5%B7%A5%E5%85%B7-ProGuard/</url>
    <content><![CDATA[<p>Java代码是非常容易反编译，比如使用<a href="http://java-decompiler.github.io/">Java Decompiler</a>很轻松可以反编译出源代码。所以为了很好的保护Java源代码，可以使用<strong>ProGuard</strong>进行Java编译后的class文件进行优化和混淆。</p>
<h1 id="ProGuard原理"><a href="#ProGuard原理" class="headerlink" title="ProGuard原理"></a>ProGuard原理</h1><p><strong>ProGuard</strong>能够通过移除无用代码，使用简短无意义的名称来重命名类，字段和方法。从而能够达到压缩、优化和混淆代码的目的。最终会获取一个较小的编译文件，并且这个通过<strong>ProGuard</strong>处理的编译文件更难于进行逆向工程。</p>
<div align=center><img src="../../../../images/2021/7-9/proguard_1.jpeg" algin="center"/></div>

<h2 id="压缩（Shrink）"><a href="#压缩（Shrink）" class="headerlink" title="压缩（Shrink）"></a>压缩（Shrink）</h2><p>在压缩处理中，用于检测和删除没有使用的类，字段，方法和属性。</p>
<h2 id="优化（Optimize）"><a href="#优化（Optimize）" class="headerlink" title="优化（Optimize）"></a>优化（Optimize）</h2><p>在优化处理中，对字节码进行优化，并且移除无用指令。</p>
<h2 id="混淆（Obfuscate）"><a href="#混淆（Obfuscate）" class="headerlink" title="混淆（Obfuscate）"></a>混淆（Obfuscate）</h2><p>在混淆处理中，使用a、b、c等无意义的名称，对类，字段和方法进行重命名。</p>
<h2 id="预检（Preveirfy）"><a href="#预检（Preveirfy）" class="headerlink" title="预检（Preveirfy）"></a>预检（Preveirfy）</h2><p>在预检中，主要是在Java平台上对处理后的代码进行预检。</p>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h2 id="ProGuard命令行"><a href="#ProGuard命令行" class="headerlink" title="ProGuard命令行"></a>ProGuard命令行</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar proguard.jar @config.pro -verbose</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般情况下把参数写在 config.pro中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-injars       ProguardApplication.jar </span><br><span class="line">-outjars      ProguardApplication_out.jar </span><br><span class="line">-libraryjars  &lt;java.home&gt;/lib/rt.jar </span><br><span class="line">-printmapping ProguardApplication.map </span><br><span class="line"></span><br><span class="line">-keep public class ProguardApplication &#123;</span><br><span class="line">    public static void main(String[] args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h2><p>下载地址：<a href="https://github.com/Guardsquare/proguard/releases">https://github.com/Guardsquare/proguard/releases</a></p>
<h2 id="Maven插件"><a href="#Maven插件" class="headerlink" title="Maven插件"></a>Maven插件</h2><p>插件地址：<a href="https://github.com/wvengen/proguard-maven-plugin">https://github.com/wvengen/proguard-maven-plugin</a></p>
<h1 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h1><h2 id="input-output"><a href="#input-output" class="headerlink" title="input/output"></a>input/output</h2><h3 id="injars"><a href="#injars" class="headerlink" title="-injars"></a>-injars</h3><p>要处理的应用程序。 可以是jar、war、ears、zips或者是个目录。</p>
<h3 id="outjars"><a href="#outjars" class="headerlink" title="-outjars"></a>-outjars</h3><p>指定要输出的jar、war、ears、zips或者是个目录。</p>
<h3 id="libraryjars"><a href="#libraryjars" class="headerlink" title="-libraryjars"></a>-libraryjars</h3><p>项目中使用到的jar类库。</p>
<h3 id="skipnonpubliclibraryclasses"><a href="#skipnonpubliclibraryclasses" class="headerlink" title="-skipnonpubliclibraryclasses"></a>-skipnonpubliclibraryclasses</h3><p>指定在读取库jar时跳过非公共类，以加快处理速度并减少ProGuard的内存使用量。 默认情况下，ProGuard会读取非公共类和公共库类。 但是，非公共类通常不相关，如果它们不影响输入jar中的实际程序代码。 忽略它们然后加速ProGuard，而不影响输出。 遗憾的是，某些库（包括最近的JSE运行时库）包含由公共库类扩展的非公共库类。 然后，您无法使用此选项。 如果由于设置了此选项而无法找到类，ProGuard将打印出警告。</p>
<h3 id="dontskipnonpubliclibraryclassmembers"><a href="#dontskipnonpubliclibraryclassmembers" class="headerlink" title="-dontskipnonpubliclibraryclassmembers"></a>-dontskipnonpubliclibraryclassmembers</h3><p>指定不忽略包可见库类成员（字段和方法），默认情况下，ProGuard会在解析库类时跳过这些类成员，因为程序类通常不会引用它们。 但有时，程序类与库类位于相同的包中，并且它们确实引用了它们的包可见类成员。 在这些情况下，实际读取类成员可能很有用，以确保处理后的代码保持一致。</p>
<h3 id="target"><a href="#target" class="headerlink" title="-target"></a>-target</h3><p>指定在已处理的类文件中设置的版本号</p>
<h3 id="forceprocessing"><a href="#forceprocessing" class="headerlink" title="-forceprocessing"></a>-forceprocessing</h3><p>强制使用最新的输入文件处理。</p>
<h2 id="Keep-Options"><a href="#Keep-Options" class="headerlink" title="Keep Options"></a>Keep Options</h2><h3 id="keep"><a href="#keep" class="headerlink" title="-keep"></a>-keep</h3><p>规则是 xxx.class 支持 ?、<em>或*</em>,比如: com.baidu.demo.* {*;} <a href="https://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/manual/usage.html#classspecification">参考</a></p>
<h3 id="keepclasseswithmembers"><a href="#keepclasseswithmembers" class="headerlink" title="-keepclasseswithmembers"></a>-keepclasseswithmembers</h3><p>保留一些特殊的类方法。</p>
<h3 id="keepclasseswithmembers-1"><a href="#keepclasseswithmembers-1" class="headerlink" title="-keepclasseswithmembers"></a>-keepclasseswithmembers</h3><p>指定要保留的类和类成员，条件是存在所有指定的类成员。 例如，您可能希望保留所有具有main方法的应用程序，而不必显式列出它们。</p>
<h3 id="keepnames"><a href="#keepnames" class="headerlink" title="-keepnames"></a>-keepnames</h3><p>指定要保留其名称的类和类成员（如果在shrinking阶段未删除它们）。</p>
<h3 id="keepclassmembernames"><a href="#keepclassmembernames" class="headerlink" title="-keepclassmembernames"></a>-keepclassmembernames</h3><p>指定要保留其名称的类成员。</p>
<h3 id="keepclasseswithmembernames"><a href="#keepclasseswithmembernames" class="headerlink" title="-keepclasseswithmembernames"></a>-keepclasseswithmembernames</h3><p>指定要保留其名称的类和类成员，条件是在shrinking阶段之后存在所有指定的类成员。</p>
<h3 id="printseeds"><a href="#printseeds" class="headerlink" title="-printseeds"></a>-printseeds</h3><p>指定详尽列出由各种-keep选项匹配的类和类成员。 列表将打印到标准输出或给定文件。该列表可用于验证是否确实找到了预期的类成员，尤其是在使用通配符时。例如，您可能希望列出您保留的所有应用程序或所有小程序。</p>
<h2 id="Shrinking-Options"><a href="#Shrinking-Options" class="headerlink" title="Shrinking Options"></a>Shrinking Options</h2><h3 id="dontshrink"><a href="#dontshrink" class="headerlink" title="dontshrink"></a>dontshrink</h3><p>指定不压缩输入文件。默认情况下压缩，所有类和类成员都被删除，除了各种-keep选项列出的那些，以及它们所依赖的那些，直接或间接。在每个优化步骤之后也会应用缩小步骤，因为某些优化可能会删除更多类和类成员。</p>
<h3 id="printusage-filename"><a href="#printusage-filename" class="headerlink" title="-printusage [filename]"></a>-printusage [filename]</h3><p>指定列出输入类文件的死代码。列表将打印到标准输出或给定文件。例如，您可以列出应用程序的未使用代码。仅适用于收缩时。</p>
<h3 id="whyareyoukeeping-class-specification"><a href="#whyareyoukeeping-class-specification" class="headerlink" title="-whyareyoukeeping class_specification"></a>-whyareyoukeeping class_specification</h3><p>指定打印有关为什么在缩小步骤中保留给定类和类成员的详细信息。如果您想知道为什么输出中存在某些给定元素，这可能很有用。通常，可能有许多不同的原因。对于每个指定的类和类成员，此选项将最短的方法链打印到指定的种子或入口点。在当前的实施中，打印出的最短链条有时可能包含循环扣除 - 这些不反映实际的收缩过程。如果指定了-verbose选项，则跟踪包括完整字段和方法签名。仅适用于收缩时。</p>
<h2 id="Optimization-Options"><a href="#Optimization-Options" class="headerlink" title="Optimization Options"></a>Optimization Options</h2><h3 id="dontoptimize"><a href="#dontoptimize" class="headerlink" title="-dontoptimize"></a>-dontoptimize</h3><p>指定不优化输入类文件。默认情况下，启用优化。所有方法都在字节码级别进行优化。</p>
<h3 id="optimizations-optimization-filter"><a href="#optimizations-optimization-filter" class="headerlink" title="-optimizations optimization_filter"></a>-optimizations optimization_filter</h3><p>指定要在更细粒度级别启用和禁用的优化。仅适用于优化时。这是一个专家选择。</p>
<h3 id="optimizationpasses-n"><a href="#optimizationpasses-n" class="headerlink" title="-optimizationpasses n"></a>-optimizationpasses n</h3><p>指定要执行的优化传递的数量。默认情况下，执行单次传递。多次通过可能会导致进一步的改进。如果在优化过程后未找到任何改进，则优化结束。仅适用于优化时。</p>
<h3 id="assumenosideeffects-class-specification"><a href="#assumenosideeffects-class-specification" class="headerlink" title="-assumenosideeffects class_specification"></a>-assumenosideeffects class_specification</h3><p>指定没有任何副作用的方法（除了可能返回值）。在优化步骤中，如果ProGuard可以确定不使用返回值，则会删除对此类方法的调用。请注意，ProGuard将分析您的程序代码以自动查找此类方法。它不会分析库代码，因此该选项对此有用。例如，您可以指定方法System.currentTimeMillis（），以便删除对它的任何空闲调用。请注意，ProGuard将该选项应用于指定方法的整个层次结构。仅适用于优化时。一般来说，做出假设可能是危险的;您可以轻松破坏已处理的代码。如果您知道自己在做什么，请仅使用此选项！</p>
<h3 id="allowaccessmodification"><a href="#allowaccessmodification" class="headerlink" title="-allowaccessmodification"></a>-allowaccessmodification</h3><p>指定在处理期间可以扩展类和类成员的访问修饰符。这可以改善优化步骤的结果。例如，在内联公共getter时，可能还需要公开访问的字段。尽管Java的二进制兼容性规范在形式上并不要求这样做（参见Java语言规范，第二版，第13.4.6节），否则一些虚拟机会遇到处理过的代码问题。仅在优化时（以及使用-repackageclasses选项进行模糊处理时）。<br>反指示：在处理要用作库的代码时，您可能不应该使用此选项，因为未设计为在API中公开的类和类成员可能会公开。</p>
<h3 id="mergeinterfacesaggressively"><a href="#mergeinterfacesaggressively" class="headerlink" title="-mergeinterfacesaggressively"></a>-mergeinterfacesaggressively</h3><p>指定可以合并接口，即使它们的实现类没有实现所有接口方法。这可以通过减少类的总数来减小输出的大小。请注意，Java的二进制兼容性规范允许这样的结构（参见Java语言规范，第二版，第13.5.3节），即使它们不被Java语言允许（参见Java语言规范，第二版，第8.1节）。 4）。仅适用于优化时。<br>反指示：设置此选项会降低某些JVM上已处理代码的性能，因为高级即时编译往往倾向于使用更少的实现类来实现更多接口。更糟糕的是，某些JVM可能无法处理生成的代码。值得注意的是：当遇到类中超过256种Miranda方法（没有实现的接口方法）时，Sun的JRE 1.3可能会抛出InternalError。</p>
<h2 id="Obfuscation-Options"><a href="#Obfuscation-Options" class="headerlink" title="Obfuscation Options"></a>Obfuscation Options</h2><h3 id="dontobfuscate"><a href="#dontobfuscate" class="headerlink" title="-dontobfuscate"></a>-dontobfuscate</h3><p>指定不混淆输入类文件。默认情况下，应用模糊处理;类和类成员接收新的短随机名称，但各种-keep选项列出的名称除外。将删除对调试有用的内部属性，例如源文件名，变量名和行号。</p>
<h3 id="printmapping-filename"><a href="#printmapping-filename" class="headerlink" title="-printmapping [filename]"></a>-printmapping [filename]</h3><p>指定为已重命名的类和类成员打印从旧名称到新名称的映射。映射将打印到标准输出或给定文件。例如，它是后续增量混淆所必需的，或者如果您想要再次理解混淆的堆栈跟踪。仅在混淆时适用。</p>
<h3 id="applymapping-filename"><a href="#applymapping-filename" class="headerlink" title="-applymapping filename"></a>-applymapping filename</h3><p>指定重用在先前的ProGuard混淆运行中打印出的给定名称映射。映射文件中列出的类和类成员将接收与其一起指定的名称。未提及的类和类成员会收到新名称。映射可以指输入类以及库类。此选项对于增量混淆非常有用，即处理现有代码段的附加组件或小补丁。在这种情况下，您应该考虑是否还需要选项-useuniqueclassmembernames。只允许一个映射文件。仅在混淆时适用。</p>
<h3 id="obfuscationdictionary-filename"><a href="#obfuscationdictionary-filename" class="headerlink" title="-obfuscationdictionary filename"></a>-obfuscationdictionary filename</h3><p>指定一个文本文件，所有有效单词都用作混淆的字段和方法名称。默认情况下，“a”，“b”等短名称用作混淆名称。使用混淆字典，您可以指定保留关键字列表或具有外来字符的标识符。忽略＃符号后的空格，标点字符，重复单词和注释。请注意，混淆字典几乎不会改善混淆。体面的编译器可以自动替换它们，并且通过使用更简单的名称再次混淆可以简单地解除效果。最有用的应用程序是指定通常已经存在于类文件中的字符串（例如“代码”），从而减少了类文件的大小。仅在混淆时适用。</p>
<h3 id="classobfuscationdictionary-filename"><a href="#classobfuscationdictionary-filename" class="headerlink" title="-classobfuscationdictionary filename"></a>-classobfuscationdictionary filename</h3><p>指定一个文本文件，所有有效的单词都用作混淆的类名。混淆字典类似于选项-obfuscationdictionary之一。仅在混淆时适用。</p>
<h3 id="packageobfuscationdictionary-filename"><a href="#packageobfuscationdictionary-filename" class="headerlink" title="-packageobfuscationdictionary filename"></a>-packageobfuscationdictionary filename</h3><p>指定一个文本文件，从该文本文件中将所有有效单词用作模糊处理的包名称。混淆字典类似于选项-obfuscationdictionary之一。仅在混淆时适用。</p>
<h3 id="overloadaggressively"><a href="#overloadaggressively" class="headerlink" title="-overloadaggressively"></a>-overloadaggressively</h3><p>指定在混淆时应用积极的重载。然后，多个字段和方法可以获得相同的名称，只要它们的参数和返回类型不同（不仅仅是它们的参数）。此选项可以使处理后的代码更小（并且更难以理解）。仅在混淆时适用。<br>反指示：生成的类文件属于Java字节码规范（参见Java虚拟机规范，第二版，第4.5节和第4.6节的第一段），即使Java语言中不允许这种重载（ cfr.Java语言规范，第二版，第8.3节和第8.4.7节）。但是，有些工具存在问题。值得注意的是：Sun的JDK 1.2.2 javac编译器在使用这样的库进行编译时会产生异常（cfr.Bug＃4216736）。您可能不应该使用此选项来处理库。<br>Sun的JRE 1.4及更高版本无法使用重载的原始字段序列化对象。<br>据报道，Sun的JRE 1.5 pack200工具存在重载类成员的问题。<br>谷歌的Dalvik VM无法处理超载的静态字段。</p>
<h3 id="useuniqueclassmembernames"><a href="#useuniqueclassmembernames" class="headerlink" title="-useuniqueclassmembernames"></a>-useuniqueclassmembernames</h3><p>指定将相同的模糊名称分配给具有相同名称的类成员，并将不同的模糊名称分配给具有不同名称的类成员（对于每个给定的类成员签名）。如果没有该选项，可以将更多类成员映射到相同的短名称，如“a”，“b”等。因此，该选项会稍微增加结果代码的大小，但它确保保存的混淆名称映射始终可以在随后的增量混淆步骤中受到尊重。<br>例如，考虑两个不同的接口，包含具有相同名称和签名的方法。如果没有此选项，这些方法可能会在第一个混淆步骤中获得不同的混淆名称。如果随后添加了包含实现两个接口的类的补丁，则ProGuard必须在增量混淆步骤中为这两个方法强制实施相同的方法名称。原始混淆代码已更改，以保持生成的代码一致。在初始混淆步骤中使用此选项，将永远不需要这种重命名。此选项仅在混淆时适用。事实上，如果您计划执行增量混淆，您可能希望完全避免收缩和优化，因为这些步骤可能会删除或修改代码中对以后添加必不可少的部分。</p>
<h3 id="dontusemixedcaseclassnames"><a href="#dontusemixedcaseclassnames" class="headerlink" title="-dontusemixedcaseclassnames"></a>-dontusemixedcaseclassnames</h3><p>指定在混淆时不生成混合大小写的类名。默认情况下，混淆的类名称可以包含大写字符和小写字符的混合。这创造了完全可接受和可用的罐子。只有在具有不区分大小写的文件系统（例如，Windows）的平台上解压缩jar时，解包工具才可以让类似命名的类文件相互覆盖。解包时自毁的代码！真正想在Windows上解压缩jar的开发人员可以使用此选项来关闭此行为。请注意，混淆的罐子会因此变大。仅在混淆时适用。</p>
<h3 id="keeppackagenames-package-filter"><a href="#keeppackagenames-package-filter" class="headerlink" title="-keeppackagenames [package_filter]"></a>-keeppackagenames [package_filter]</h3><p>指定不混淆给定的包名称。可选过滤器是以逗号分隔的包名列表。包名称可以包含？，*和**通配符，它们之前可以包含！否定器。仅在混淆时适用。</p>
<h3 id="flattenpackagehierarchy-package-name"><a href="#flattenpackagehierarchy-package-name" class="headerlink" title="-flattenpackagehierarchy [package_name]"></a>-flattenpackagehierarchy [package_name]</h3><p>指定通过将所有重命名的包移动到单个给定的父包中来重新打包它们。如果没有参数或空字符串（’’），包将被移动到根包中。此选项是进一步混淆包名称的一个示例。它可以使处理过的代码更小，更难以理解。仅在混淆时适用。</p>
<h3 id="repackageclasses-package-name"><a href="#repackageclasses-package-name" class="headerlink" title="-repackageclasses [package_name]"></a>-repackageclasses [package_name]</h3><p>指定通过将所有重命名的类文件移动到单个给定包中来重新打包它们。如果没有参数或空字符串（’’），则会完全删除包。此选项选项会覆盖-flattenpackagehierarchy选项。这是进一步混淆包名称的另一个例子。它可以使处理后的代码更小，更难以理解。它不推荐使用的名称是-defaultpackage。仅在混淆时适用。<br>反指示：在包目录中查找资源文件的类如果被移动到其他地方将不再正常工作。如有疑问，请不要使用此选项保持包装不受影响。</p>
<h3 id="keepattributes-attribute-filter"><a href="#keepattributes-attribute-filter" class="headerlink" title="-keepattributes [attribute_filter]"></a>-keepattributes [attribute_filter]</h3><p>指定要保留的任何可选属性。可以使用一个或多个-keepattributes指令指定属性。可选过滤器是以逗号分隔的属性名称列表。属性名称可以包含？，*和**通配符，它们之前可以包含！否定器。典型的可选属性是Exceptions，Signature，Deprecated，SourceFile，SourceDir，LineNumberTable，LocalVariableTable，LocalVariableTypeTable，Synthetic，EnclosingMethod，RuntimeVisibleAnnotations，RuntimeInvisibleAnnotations，RuntimeVisibleParameterAnnotations，RuntimeInvisibleParameterAnnotations和AnnotationDefault。也可以指定InnerClasses属性名称，引用此属性的源名称部分。例如，在处理库时，至少应保留Exceptions，InnerClasses和Signature属性。您还应该保留SourceFile和LineNumberTable属性，以生成有用的混淆堆栈跟踪。最后，如果您的代码依赖于它们，您可能希望保留注释。仅在混淆时适用。</p>
<h3 id="keepparameternames"><a href="#keepparameternames" class="headerlink" title="-keepparameternames"></a>-keepparameternames</h3><p>指定保留参数名称和保留的方法类型。此选项实际上保留了调试属性LocalVariableTable和LocalVariableTypeTable的修剪版本。它在处理库时很有用。某些IDE可以使用该信息来帮助使用该库的开发人员，例如使用工具提示或自动完成。仅在混淆时适用。</p>
<h3 id="renamesourcefileattribute-string"><a href="#renamesourcefileattribute-string" class="headerlink" title="-renamesourcefileattribute [string]"></a>-renamesourcefileattribute [string]</h3><p>指定要放在类文件的SourceFile属性（和SourceDir属性）中的常量字符串。请注意，必须首先存在该属性，因此还必须使用-keepattributes指令显式保留该属性。例如，您可能希望让已处理的库和应用程序生成有用的混淆堆栈跟踪。仅在混淆时适用。</p>
<h3 id="adaptclassstrings-class-filter"><a href="#adaptclassstrings-class-filter" class="headerlink" title="-adaptclassstrings [class_filter]"></a>-adaptclassstrings [class_filter]</h3><p>指定对应于类名的字符串常量也应进行模糊处理。如果没有过滤器，则会调整与类名对应的所有字符串常量。使用过滤器，只调整与过滤器匹配的类中的字符串常量。例如，如果您的代码包含大量引用类的硬编码字符串，并且您不想保留其名称，则可能需要使用此选项。在混淆时主要适用，但相应的类也会自动保留在收缩步骤中。</p>
<h3 id="adaptresourcefilenames-file-filter"><a href="#adaptresourcefilenames-file-filter" class="headerlink" title="-adaptresourcefilenames [file_filter]"></a>-adaptresourcefilenames [file_filter]</h3><p>根据相应类文件（如果有）的模糊名称指定要重命名的资源文件。如果没有过滤器，则会重命名与类文件对应的所有资源文件。使用过滤器，仅重命名匹配的文件。例如，请参阅处理资源文件。仅在混淆时适用。</p>
<h3 id="adaptresourcefilecontents-file-filter"><a href="#adaptresourcefilecontents-file-filter" class="headerlink" title="-adaptresourcefilecontents [file_filter]"></a>-adaptresourcefilecontents [file_filter]</h3><p>指定要更新其内容的资源文件。根据相应类的模糊名称（如果有），重命名资源文件中提到的任何类名。没有过滤器，所有资源文件的内容都会更新。使用过滤器，仅更新匹配的文件。使用平台的默认字符集解析和写入资源文件。您可以通过设置环境变量LANG或Java系统属性file.encoding来更改此默认字符集。有关示例，请参阅处理资源文件。仅在混淆时适用。</p>
<h2 id="Preverification-Options"><a href="#Preverification-Options" class="headerlink" title="Preverification Options"></a>Preverification Options</h2><h3 id="dontpreverify"><a href="#dontpreverify" class="headerlink" title="-dontpreverify"></a>-dontpreverify</h3><p>指定不预验证已处理的类文件。默认情况下，如果类文件针对Java Micro Edition或Java 6或更高版本，则会对其进行预验证。对于Java Micro Edition，需要进行预验证，因此如果指定此选项，则需要在已处理的代码上运行外部预验证程序。对于Java 6，（还）不需要预验证，但它提高了Java虚拟机中类加载的效率。</p>
<h3 id="microedition"><a href="#microedition" class="headerlink" title="-microedition"></a>-microedition</h3><p>指定已处理的类文件以Java Micro Edition为目标。然后，预处理器将添加适当的StackMap属性，这些属性与Java Standard Edition的默认StackMapTable属性不同。例如，如果要处理midlet，则需要此选项。</p>
<h2 id="General-Options"><a href="#General-Options" class="headerlink" title="General Options"></a>General Options</h2><h3 id="verbose"><a href="#verbose" class="headerlink" title="-verbose"></a>-verbose</h3><p>指定在处理期间写出更多信息。如果程序以异常终止，则此选项将打印出整个堆栈跟踪，而不仅仅是异常消息。</p>
<h3 id="dontnote-class-filter"><a href="#dontnote-class-filter" class="headerlink" title="-dontnote [class_filter]"></a>-dontnote [class_filter]</h3><p>指定不打印有关配置中可能存在的错误或遗漏的注释，例如类名中的拼写错误，或者缺少可能有用的缺失选项。可选过滤器是正则表达式; ProGuard不会打印有关匹配名称的类的注释。</p>
<h3 id="dontwarn-class-filter"><a href="#dontwarn-class-filter" class="headerlink" title="-dontwarn [class_filter]"></a>-dontwarn [class_filter]</h3><p>指定不要警告未解决的引用和其他重要问题。可选过滤器是正则表达式; ProGuard不会打印有关匹配名称的类的警告。忽略警告可能很危险。例如，如果确实需要处理未解析的类或类成员，则处理的代码将无法正常运行。如果您知道自己在做什么，请仅使用此选项！</p>
<h3 id="ignorewarnings"><a href="#ignorewarnings" class="headerlink" title="-ignorewarnings"></a>-ignorewarnings</h3><p>指定打印有关未解析的引用和其他重要问题的任何警告，但在任何情况下都要继续处理。忽略警告可能很危险。例如，如果确实需要处理未解析的类或类成员，则处理的代码将无法正常运行。如果您知道自己在做什么，请仅使用此选项！</p>
<h3 id="printconfiguration-filename"><a href="#printconfiguration-filename" class="headerlink" title="-printconfiguration [filename]"></a>-printconfiguration [filename]</h3><p>指定写出已解析的整个配置，包含已包含的文件和替换的变量。结构将打印到标准输出或给定文件。这有时可用于调试配置或将XML配置转换为更易读的格式。</p>
<h3 id="dump-filename"><a href="#dump-filename" class="headerlink" title="-dump [filename]"></a>-dump [filename]</h3><p>指定在任何处理之后写出类文件的内部结构。结构将打印到标准输出或给定文件。例如，您可能想要写出给定jar文件的内容，而根本不处理它。</p>
<h1 id="Maven插件使用方式"><a href="#Maven插件使用方式" class="headerlink" title="Maven插件使用方式"></a>Maven插件使用方式</h1><h2 id="新建Spring-Boot项目"><a href="#新建Spring-Boot项目" class="headerlink" title="新建Spring-Boot项目"></a>新建Spring-Boot项目</h2><div align=center><img width="420" height="500" src="../../../../images/2021/7-9/proguard_2.png" algin="center"/></div>

<h2 id="代码信息"><a href="#代码信息" class="headerlink" title="代码信息"></a>代码信息</h2><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.mx.proguard;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProguardApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ProguardApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.mx.proguard.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.mx.proguard.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">&quot;max&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">20</span>);</span><br><span class="line">        user.setHeight(<span class="number">180</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.mx.proguard.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5758407595463359076L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">private</span> Integer height;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNickName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nickName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNickName</span><span class="params">(String nickName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nickName = nickName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(Integer height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="POM配置"><a href="#POM配置" class="headerlink" title="POM配置"></a>POM配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.mx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>proguard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>proguard<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>proguard<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-boot.version</span>&gt;</span>2.3.7.RELEASE<span class="tag">&lt;/<span class="name">spring-boot.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Hoxton.SR9<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">proguard.version</span>&gt;</span>7.1.1<span class="tag">&lt;/<span class="name">proguard.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">proguard.maven.plugin.version</span>&gt;</span>2.5.1<span class="tag">&lt;/<span class="name">proguard.maven.plugin.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--   ProGuard开始         --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.wvengen<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>proguard-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;proguard.maven.plugin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>proguard<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">proguardVersion</span>&gt;</span>$&#123;proguard.version&#125;<span class="tag">&lt;/<span class="name">proguardVersion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">injar</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">injar</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">outjar</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">outjar</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">obfuscate</span>&gt;</span>true<span class="tag">&lt;/<span class="name">obfuscate</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">options</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>-dontshrink<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>-dontoptimize<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 此选项将用新的类名替换反射方法调用中的所有字符串。例如，调用Class.forName(&#x27;className&#x27;)--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>-adaptclassstrings<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 此选项将保存所有原始注解等。否则，将从文件中删除所有注解。--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>-keepattributes</span><br><span class="line">                            Exceptions,</span><br><span class="line">                            InnerClasses,</span><br><span class="line">                            Signature,</span><br><span class="line">                            Deprecated,</span><br><span class="line">                            SourceFile,</span><br><span class="line">                            LineNumberTable,</span><br><span class="line">                            *Annotation*,</span><br><span class="line">                            EnclosingMethod</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 此选项将保存接口中的所有原始名称（不混淆）--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>-keepnames interface **<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 此选项将保留所有原始方法参数--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>-keepparameternames<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 此选项将保存所有原始类文件（不混淆），一般是混淆领域或者服务包中的文件。--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>-keep</span><br><span class="line">                            class com.github.mx.proguard.ProguardApplication &#123;</span><br><span class="line">                            public static void main(java.lang.String[]);</span><br><span class="line">                            &#125;</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 此选项忽略警告，例如重复的类定义和命名不正确的文件中的类--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>-ignorewarnings<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 此选项将保存所有软件包中的所有原始接口文件（不进行混淆）--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>-keep interface * extends * &#123; *; &#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 此选项将保存所有包中所有类中的所有原始定义的注解--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>-keep class com.github.mx.proguard.entity.** &#123; *; &#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>-keep class com.fasterxml.jackson.** &#123; *; &#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>-keep class org.json.JSONObject.** &#123;** put(java.lang.String,java.util.Map);&#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>-keepclassmembers class * &#123;</span><br><span class="line">                            @org.springframework.context.annotation.Bean *;</span><br><span class="line">                            @org.springframework.beans.factory.annotation.Autowired *;</span><br><span class="line">                            @org.springframework.beans.factory.annotation.Value *;</span><br><span class="line">                            &#125;</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>-dontwarn com.fasterxml.jackson.databind.**<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>-dontwarn com.fasterxml.jackson.**<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">options</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">injarNotExistsSkip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">injarNotExistsSkip</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">libs</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--在此添加需要的类库--&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--&lt;lib&gt;$&#123;java.home&#125;/lib/rt.jar&lt;/lib&gt;--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">libs</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.guardsquare<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>proguard-base<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;proguard.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--   ProGuard结束      --&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.github.mx.proguard.ProguardApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>需要添加<code>proguard-maven-plugin</code>插件；</li>
<li>在<code>package</code>阶段，就会自动运行<code>proguard</code>；</li>
<li><strong>spring-boot-maven-plugin必须在proguard插件混淆后运行</strong>，这样它就会获取已经混淆的文件。也就是说混淆后的<code>proguard-0.0.1-SNAPSHOT.jar</code>会覆盖掉混淆前的<code>proguard-0.0.1-SNAPSHOT.jar</code>。</li>
</ul>
<h2 id="验证混淆"><a href="#验证混淆" class="headerlink" title="验证混淆"></a>验证混淆</h2><p>通过Java反编译工具<a href="http://java-decompiler.github.io/">Java Decompiler</a>验证编译后的class是否完成了混淆。</p>
<div align=center><img src="../../../../images/2021/7-9/proguard_3.png" algin="center"/></div>

<p>从 反编译的结果可以看出包名、类名、方法名都已经成功做了混淆。</p>
]]></content>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>Java生成PDF</title>
    <url>/Java%E7%94%9F%E6%88%90PDF/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在某些业务场景中，需要提供相关的电子凭证，比如网银/支付宝中转账的电子回单，签约的电子合同、证书等。方便用户查看，下载，打印。目前常用的解决方案是，把相关数据信息，生成对应的PDF文件返回给用户。之前有写过一篇博客关于<strong>JAVA实现HTML转PDF</strong>，不同场景下的业务不同，现在需要使用PDF生成证书，这篇博客主要介绍iText的使用。</p>
<p>本博客项目地址：<a href="https://github.com/mx-go/java_pdf_demo">https://github.com/mx-go/java_pdf_demo</a><div align=center><img width="600" height="200" src="../../../../images/2017-11-13/iText/0.png"/></p>
</div><span id="more"></span>

<h1 id="iText介绍"><a href="#iText介绍" class="headerlink" title="iText介绍"></a>iText介绍</h1><p>iText是著名的开放源码的站点sourceforge一个项目，是用于生成PDF文档的一个JAVA类库。通过iText不仅可以生成PDF或rtf的文档，而且可以将XML、HTML文件转化为PDF文件。</p>
<p>iText 官网：<a href="http://itextpdf.com/">http://itextpdf.com/</a></p>
<p>iText 开发文档： <a href="http://developers.itextpdf.com/developers-home">http://developers.itextpdf.com/developers-home</a></p>
<p>iText目前有两套版本iText5和iText7。iText5应该是网上用的比较多的一个版本。iText5因为是很多开发者参与贡献代码，因此在一些规范和设计上存在不合理的地方。iText7是后来官方针对iText5的重构，两个版本差别还是挺大的。不过在实际使用中，一般用到的都比较简单，所以不用特别拘泥于使用哪个版本。比如我们在<a href="http://mvnrepository.com/%E4%B8%AD%E6%90%9C%E7%B4%A2iText%EF%BC%8C%E5%87%BA%E6%9D%A5%E7%9A%84%E9%83%BD%E6%98%AFiText5%E7%9A%84%E4%BE%9D%E8%B5%96%E3%80%82">http://mvnrepository.com/中搜索iText，出来的都是iText5的依赖。</a></p>
<h1 id="iText简单使用"><a href="#iText简单使用" class="headerlink" title="iText简单使用"></a>iText简单使用</h1><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.itextpdf/itextpdf --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itextpdf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itextpdf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试代码：JavaToPdf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rainbowhorse.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.Document;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.DocumentException;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.Paragraph;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.pdf.PdfWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不支持中文</span></span><br><span class="line"><span class="comment"> * ClassName: JavaToPdf </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> max</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017年11月13日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaToPdf</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成PDF路径</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEST = <span class="string">&quot;target/HelloWorld.pdf&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException, DocumentException </span>&#123;</span><br><span class="line">		Document document = <span class="keyword">new</span> Document();</span><br><span class="line">		PdfWriter writer = PdfWriter.getInstance(document, <span class="keyword">new</span> FileOutputStream(DEST));</span><br><span class="line">		document.open();</span><br><span class="line">		document.add(<span class="keyword">new</span> Paragraph(<span class="string">&quot;hello world&quot;</span>));</span><br><span class="line">		document.close();</span><br><span class="line">		writer.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<div align=center><img width="800" height="200" src="../../../../images/2017-11-13/iText/1.png" algin="center"/>

</div>

<h1 id="iText中文支持"><a href="#iText中文支持" class="headerlink" title="iText中文支持"></a>iText中文支持</h1><p>iText默认是不支持中文的，因此需要添加对应的中文字体,比如黑体simhei.ttf</p>
<p>可参考文档：<a href="http://developers.itextpdf.com/examples/font-examples/using-fonts#1227-tengwarquenya1.java">http://developers.itextpdf.com/examples/font-examples/using-fonts#1227-tengwarquenya1.java</a></p>
<p>测试代码：JavaToPdfCN</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rainbowhorse.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.Document;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.DocumentException;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.Font;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.FontFactory;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.Paragraph;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.pdf.BaseFont;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.pdf.PdfWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 支持中文</span></span><br><span class="line"><span class="comment"> * ClassName: JavaToPdfCN </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> max</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017年11月13日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaToPdfCN</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成PDF路径</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEST = <span class="string">&quot;target/HelloWorld_CN.pdf&quot;</span>;</span><br><span class="line">	<span class="comment">// 中文字体（黑体）</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FONT = <span class="string">&quot;simhei.ttf&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException, DocumentException </span>&#123;</span><br><span class="line">		Document document = <span class="keyword">new</span> Document();</span><br><span class="line">		PdfWriter writer = PdfWriter.getInstance(document, <span class="keyword">new</span> FileOutputStream(DEST));</span><br><span class="line">		document.open();</span><br><span class="line">		Font font = FontFactory.getFont(FONT, BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED);</span><br><span class="line">		document.add(<span class="keyword">new</span> Paragraph(<span class="string">&quot;hello world，我是rainbowhorse。&quot;</span>, font));</span><br><span class="line">		document.close();</span><br><span class="line">		writer.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<div align=center><img width="800" height="200" src="../../../../images/2017-11-13/iText/2.png" algin="center"/>

</div>

<h1 id="iText-HTML渲染"><a href="#iText-HTML渲染" class="headerlink" title="iText-HTML渲染"></a>iText-HTML渲染</h1><p>在一些比较复杂的PDF布局中，我们可以通过HTML去生成PDF</p>
<p>可参考文档：<a href="http://developers.itextpdf.com/examples/xml-worker-itext5/xml-worker-examples">http://developers.itextpdf.com/examples/xml-worker-itext5/xml-worker-examples</a></p>
<p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.itextpdf.tool/xmlworker --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itextpdf.tool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xmlworker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加模板：template.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">	<span class="attribute">font-family</span>: SimHei;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.red</span> &#123;</span></span><br><span class="line"><span class="css">	<span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>你好，rainbowhorse<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试代码：JavaToPdfHtml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rainbowhorse.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.Document;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.DocumentException;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.pdf.PdfWriter;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.tool.xml.XMLWorkerFontProvider;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.tool.xml.XMLWorkerHelper;</span><br><span class="line"><span class="keyword">import</span> com.rainbowhorse.test.util.PathUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HTML转PDF</span></span><br><span class="line"><span class="comment"> * ClassName: JavaToPdfHtml </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> max</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017年11月13日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaToPdfHtml</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成PDF路径</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEST = <span class="string">&quot;target/HelloWorld_CN_HTML.pdf&quot;</span>;</span><br><span class="line">	<span class="comment">// 模板路径</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTML = PathUtil.getCurrentPath() + <span class="string">&quot;/template.html&quot;</span>;</span><br><span class="line">	<span class="comment">// 中文字体（黑体）</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FONT = <span class="string">&quot;simhei.ttf&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, DocumentException </span>&#123;</span><br><span class="line"></span><br><span class="line">		Document document = <span class="keyword">new</span> Document();</span><br><span class="line">		PdfWriter writer = PdfWriter.getInstance(document, <span class="keyword">new</span> FileOutputStream(DEST));</span><br><span class="line">		document.open();</span><br><span class="line">		XMLWorkerFontProvider fontImp = <span class="keyword">new</span> XMLWorkerFontProvider(XMLWorkerFontProvider.DONTLOOKFORFONTS);</span><br><span class="line">		fontImp.register(FONT);</span><br><span class="line">		XMLWorkerHelper.getInstance().parseXHtml(writer, document, <span class="keyword">new</span> FileInputStream(HTML), <span class="keyword">null</span>,</span><br><span class="line">				Charset.forName(<span class="string">&quot;UTF-8&quot;</span>), fontImp);</span><br><span class="line">		document.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<div align=center><img width="800" height="200" src="../../../../images/2017-11-13/iText/3.png" algin="center"/>

</div>

<p><strong>注意：</strong></p>
<ol>
<li>HTML中必须使用标准的语法，标签一定需要闭合。</li>
<li>HTML中如果有中文，需要在样式中添加对应字体的样式。</li>
</ol>
<h1 id="iText-HTML-Freemarker渲染"><a href="#iText-HTML-Freemarker渲染" class="headerlink" title="iText-HTML-Freemarker渲染"></a>iText-HTML-Freemarker渲染</h1><p>在实际使用中，HTML内容都是动态渲染的，因此我们需要加入模板引擎支持，可以使用FreeMarker/Velocity，这里使用FreeMarker举例。</p>
<p>添加FreeMarke依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.freemarker/freemarker --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.freemarker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加模板：template_freemarker.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">	<span class="attribute">font-family</span>: SimHei;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.blue</span> &#123;</span></span><br><span class="line"><span class="css">	<span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.pos</span> &#123;</span></span><br><span class="line"><span class="css">	<span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">	<span class="attribute">left</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">	<span class="attribute">top</span>: <span class="number">150px</span></span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;blue pos&quot;</span>&gt;</span>你好，$&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试代码：JavaToPdfHtmlFreeMarker</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rainbowhorse.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.StringWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.Document;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.DocumentException;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.pdf.PdfWriter;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.tool.xml.XMLWorkerFontProvider;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.tool.xml.XMLWorkerHelper;</span><br><span class="line"><span class="keyword">import</span> com.rainbowhorse.test.util.PathUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> freemarker.template.Configuration;</span><br><span class="line"><span class="keyword">import</span> freemarker.template.Template;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FreeMarker模板的HTML转PDF</span></span><br><span class="line"><span class="comment"> * ClassName: JavaToPdfHtmlFreeMarker </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> max</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017年11月13日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaToPdfHtmlFreeMarker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成PDF路径</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEST = <span class="string">&quot;target/HelloWorld_CN_HTML_FREEMARKER.pdf&quot;</span>;</span><br><span class="line">	<span class="comment">// 模板路径</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTML = <span class="string">&quot;template_freemarker.html&quot;</span>;</span><br><span class="line">	<span class="comment">// 中文字体（黑体）</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FONT = <span class="string">&quot;simhei.ttf&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Configuration freemarkerCfg = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		freemarkerCfg = <span class="keyword">new</span> Configuration();</span><br><span class="line">		<span class="comment">// freemarker的模板目录</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			freemarkerCfg.setDirectoryForTemplateLoading(<span class="keyword">new</span> File(PathUtil.getCurrentPath()));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, DocumentException </span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br><span class="line">		data.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;rainbowhorse&quot;</span>);</span><br><span class="line">		String content = JavaToPdfHtmlFreeMarker.freeMarkerRender(data, HTML);</span><br><span class="line">		JavaToPdfHtmlFreeMarker.createPdf(content, DEST);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createPdf</span><span class="params">(String content, String dest)</span> <span class="keyword">throws</span> IOException, DocumentException </span>&#123;</span><br><span class="line"></span><br><span class="line">		Document document = <span class="keyword">new</span> Document();</span><br><span class="line">		PdfWriter writer = PdfWriter.getInstance(document, <span class="keyword">new</span> FileOutputStream(dest));</span><br><span class="line">		document.open();</span><br><span class="line">		XMLWorkerFontProvider fontImp = <span class="keyword">new</span> XMLWorkerFontProvider(XMLWorkerFontProvider.DONTLOOKFORFONTS);</span><br><span class="line">		fontImp.register(FONT);</span><br><span class="line">		XMLWorkerHelper.getInstance().parseXHtml(writer, document, <span class="keyword">new</span> ByteArrayInputStream(content.getBytes()), <span class="keyword">null</span>,</span><br><span class="line">				Charset.forName(<span class="string">&quot;UTF-8&quot;</span>), fontImp);</span><br><span class="line">		document.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * freemarker渲染html</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">freeMarkerRender</span><span class="params">(Map&lt;String, Object&gt; data, String htmlTmp)</span> </span>&#123;</span><br><span class="line">		Writer out = <span class="keyword">new</span> StringWriter();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 获取模板,并设置编码方式</span></span><br><span class="line">			Template template = freemarkerCfg.getTemplate(htmlTmp);</span><br><span class="line">			template.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">			<span class="comment">// 合并数据模型与模板</span></span><br><span class="line">			template.process(data, out);</span><br><span class="line">			<span class="comment">// 将合并后的数据和模板写入到流中，这里使用的字符流</span></span><br><span class="line">			out.flush();</span><br><span class="line">			<span class="keyword">return</span> out.toString();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				out.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">				ex.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<div align=center><img width="800" height="200" src="../../../../images/2017-11-13/iText/4.png" algin="center"/>

</div>

<p>目前为止，我们已经实现了iText通过HTML模板生成PDF的功能，但是实际应用中，我们发现iText并不能对高级的CSS样式进行解析，比如CSS中的position属性等，因此我们要引入新的组件。</p>
<h1 id="Flying-Saucer-CSS高级特性支持"><a href="#Flying-Saucer-CSS高级特性支持" class="headerlink" title="Flying Saucer-CSS高级特性支持"></a>Flying Saucer-CSS高级特性支持</h1><p>Flying Saucer is a pure-Java library for rendering arbitrary well-formed XML (or XHTML) using CSS 2.1 for layout and formatting, output to Swing panels, PDF, and images.</p>
<p>Flying Saucer是基于iText的，支持对CSS高级特性的解析。</p>
<p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.xhtmlrenderer/flying-saucer-pdf --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xhtmlrenderer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flying-saucer-pdf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.xhtmlrenderer/flying-saucer-pdf-itext5 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xhtmlrenderer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flying-saucer-pdf-itext5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加模板：template_freemarker_fs.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"> <span class="keyword">@page</span> &#123;</span></span><br><span class="line"><span class="css"> 	size:<span class="number">297mm</span> <span class="number">230mm</span>;</span></span><br><span class="line"><span class="css">        <span class="keyword">@top-left</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">content</span>:<span class="built_in">element</span>(header-left);</span></span><br><span class="line"><span class="css">        &#125;;</span></span><br><span class="line"><span class="css">        <span class="keyword">@top-right</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">content</span>: <span class="built_in">element</span>(header-right)</span></span><br><span class="line"><span class="css">        &#125;;</span></span><br><span class="line"><span class="css">        <span class="keyword">@bottom-left</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">content</span>: <span class="built_in">element</span>(footer-left)</span></span><br><span class="line"><span class="css">        &#125;;</span></span><br><span class="line"><span class="css">        <span class="keyword">@bottom-right</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">content</span>: <span class="built_in">element</span>(footer-right)</span></span><br><span class="line"><span class="css">        &#125;;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">	<span class="attribute">font-family</span>: SimHei;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.color</span> &#123;</span></span><br><span class="line"><span class="css">	<span class="attribute">color</span>: green;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.pos</span> &#123;</span></span><br><span class="line"><span class="css">	<span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">	<span class="attribute">left</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">	<span class="attribute">top</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">	<span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">	<span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;logo.jpg&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;color pos&quot;</span>&gt;</span>你好，$&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试代码：JavaToPdfHtmlFreeMarker：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rainbowhorse.test.flyingsaucer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.StringWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.xhtmlrenderer.pdf.ITextFontResolver;</span><br><span class="line"><span class="keyword">import</span> org.xhtmlrenderer.pdf.ITextRenderer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.DocumentException;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.pdf.BaseFont;</span><br><span class="line"><span class="keyword">import</span> com.rainbowhorse.test.util.PathUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> freemarker.template.Configuration;</span><br><span class="line"><span class="keyword">import</span> freemarker.template.Template;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FreeMarker模板的HTML转PDF Flying Saucer</span></span><br><span class="line"><span class="comment"> * ClassName: JavaToPdfHtmlFreeMarker </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> max</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017年11月13日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaToPdfHtmlFreeMarker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成PDF路径</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEST = <span class="string">&quot;target/HelloWorld_CN_HTML_FREEMARKER_FS.pdf&quot;</span>;</span><br><span class="line">	<span class="comment">// 模板路径</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTML = <span class="string">&quot;template_freemarker_fs.html&quot;</span>;</span><br><span class="line">	<span class="comment">// 中文字体（黑体）</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FONT = <span class="string">&quot;simhei.ttf&quot;</span>;</span><br><span class="line">	<span class="comment">// 图片路径</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOGO_PATH = <span class="string">&quot;file:/&quot;</span> + PathUtil.getCurrentPath() + <span class="string">&quot;/&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Configuration freemarkerCfg = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		freemarkerCfg = <span class="keyword">new</span> Configuration();</span><br><span class="line">		<span class="comment">// freemarker的模板目录</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			freemarkerCfg.setDirectoryForTemplateLoading(<span class="keyword">new</span> File(PathUtil.getCurrentPath()));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, DocumentException, com.lowagie.text.DocumentException </span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br><span class="line">		data.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;rainbowhorse&quot;</span>);</span><br><span class="line">		String content = JavaToPdfHtmlFreeMarker.freeMarkerRender(data, HTML);</span><br><span class="line">		JavaToPdfHtmlFreeMarker.createPdf(content, DEST);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * freemarker渲染html</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">freeMarkerRender</span><span class="params">(Map&lt;String, Object&gt; data, String htmlTmp)</span> </span>&#123;</span><br><span class="line">		Writer out = <span class="keyword">new</span> StringWriter();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 获取模板,并设置编码方式</span></span><br><span class="line">			Template template = freemarkerCfg.getTemplate(htmlTmp);</span><br><span class="line">			template.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">			<span class="comment">// 合并数据模型与模板</span></span><br><span class="line">			template.process(data, out); <span class="comment">// 将合并后的数据和模板写入到流中，这里使用的字符流</span></span><br><span class="line">			out.flush();</span><br><span class="line">			<span class="keyword">return</span> out.toString();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				out.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">				ex.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createPdf</span><span class="params">(String content, String dest)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException, DocumentException, com.lowagie.text.DocumentException </span>&#123;</span><br><span class="line">		ITextRenderer render = <span class="keyword">new</span> ITextRenderer();</span><br><span class="line">		ITextFontResolver fontResolver = render.getFontResolver();</span><br><span class="line">		fontResolver.addFont(FONT, BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED);</span><br><span class="line">		<span class="comment">// 解析html生成pdf</span></span><br><span class="line">		render.setDocumentFromString(content);</span><br><span class="line">		<span class="comment">// 解决图片相对路径的问题</span></span><br><span class="line">		render.getSharedContext().setBaseURL(LOGO_PATH);</span><br><span class="line">		render.layout();</span><br><span class="line">		render.createPDF(<span class="keyword">new</span> FileOutputStream(dest));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<div align=center><img width="800" height="200" src="../../../../images/2017-11-13/iText/5.png" algin="center"/>

</div>

<p>在某些场景下，HTML中的静态资源是在本地，我们可以使用render.getSharedContext().setBaseURL()加载文件资源,注意资源URL需要使用文件协议 “file://”。</p>
<p><strong>对于生成的pdf页面大小，可以用css的@page属性设置。</strong></p>
<h1 id="PDF转图片"><a href="#PDF转图片" class="headerlink" title="PDF转图片"></a>PDF转图片</h1><p>在某些场景中，我们可能只需要返回图片格式的电子凭证，我们可以使用Jpedal组件，把PDF转成图片。</p>
<p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.jpedal/jpedal-lgpl --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jpedal<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jpedal-lgpl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.74b27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试代码：JavaToPdfImgHtmlFreeMarker</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rainbowhorse.test.flyingsaucer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.StringWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jpedal.PdfDecoder;</span><br><span class="line"><span class="keyword">import</span> org.jpedal.exception.PdfException;</span><br><span class="line"><span class="keyword">import</span> org.jpedal.fonts.FontMappings;</span><br><span class="line"><span class="keyword">import</span> org.xhtmlrenderer.pdf.ITextFontResolver;</span><br><span class="line"><span class="keyword">import</span> org.xhtmlrenderer.pdf.ITextRenderer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.DocumentException;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.pdf.BaseFont;</span><br><span class="line"><span class="keyword">import</span> com.rainbowhorse.test.util.PathUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> freemarker.template.Configuration;</span><br><span class="line"><span class="keyword">import</span> freemarker.template.Template;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Jpedal把pdf转成图片 </span></span><br><span class="line"><span class="comment"> * ClassName: JavaToPdfImgHtmlFreeMarker</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> max</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017年11月13日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaToPdfImgHtmlFreeMarker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEST = <span class="string">&quot;target/HelloWorld_CN_HTML_FREEMARKER_FS_IMG.png&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTML = <span class="string">&quot;template_freemarker_fs.html&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FONT = <span class="string">&quot;simhei.ttf&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOGO_PATH = <span class="string">&quot;file://&quot;</span> + PathUtil.getCurrentPath() + <span class="string">&quot;/logo.png&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IMG_EXT = <span class="string">&quot;png&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Configuration freemarkerCfg = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		freemarkerCfg = <span class="keyword">new</span> Configuration();</span><br><span class="line">		<span class="comment">// freemarker的模板目录</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			freemarkerCfg.setDirectoryForTemplateLoading(<span class="keyword">new</span> File(PathUtil.getCurrentPath()));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, DocumentException, com.lowagie.text.DocumentException </span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br><span class="line">		data.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;rainbowhorse&quot;</span>);</span><br><span class="line"></span><br><span class="line">		String content = JavaToPdfImgHtmlFreeMarker.freeMarkerRender(data, HTML);</span><br><span class="line">		ByteArrayOutputStream pdfStream = JavaToPdfImgHtmlFreeMarker.createPdf(content);</span><br><span class="line">		ByteArrayOutputStream imgSteam = JavaToPdfImgHtmlFreeMarker.pdfToImg(pdfStream.toByteArray(), <span class="number">2</span>, <span class="number">1</span>, IMG_EXT);</span><br><span class="line"></span><br><span class="line">		FileOutputStream fileStream = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(DEST));</span><br><span class="line">		fileStream.write(imgSteam.toByteArray());</span><br><span class="line">		fileStream.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * freemarker渲染html</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">freeMarkerRender</span><span class="params">(Map&lt;String, Object&gt; data, String htmlTmp)</span> </span>&#123;</span><br><span class="line">		Writer out = <span class="keyword">new</span> StringWriter();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 获取模板,并设置编码方式</span></span><br><span class="line">			Template template = freemarkerCfg.getTemplate(htmlTmp);</span><br><span class="line">			template.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">			<span class="comment">// 合并数据模型与模板</span></span><br><span class="line">			template.process(data, out); <span class="comment">// 将合并后的数据和模板写入到流中，这里使用的字符流</span></span><br><span class="line">			out.flush();</span><br><span class="line">			<span class="keyword">return</span> out.toString();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				out.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">				ex.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据模板生成pdf文件流</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteArrayOutputStream <span class="title">createPdf</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">		ByteArrayOutputStream outStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">		ITextRenderer render = <span class="keyword">new</span> ITextRenderer();</span><br><span class="line">		ITextFontResolver fontResolver = render.getFontResolver();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			fontResolver.addFont(FONT, BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (com.lowagie.text.DocumentException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 解析html生成pdf</span></span><br><span class="line">		render.setDocumentFromString(content);</span><br><span class="line">		<span class="comment">// 解决图片相对路径的问题</span></span><br><span class="line">		render.getSharedContext().setBaseURL(LOGO_PATH);</span><br><span class="line">		render.layout();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			render.createPDF(outStream);</span><br><span class="line">			<span class="keyword">return</span> outStream;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (com.lowagie.text.DocumentException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				outStream.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据pdf二进制文件 生成图片文件</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">	 *            pdf二进制</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> scaling</span></span><br><span class="line"><span class="comment">	 *            清晰度</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> pageNum</span></span><br><span class="line"><span class="comment">	 *            页数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteArrayOutputStream <span class="title">pdfToImg</span><span class="params">(<span class="keyword">byte</span>[] bytes, <span class="keyword">float</span> scaling, <span class="keyword">int</span> pageNum, String formatName)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 推荐的方法打开PdfDecoder</span></span><br><span class="line">		PdfDecoder pdfDecoder = <span class="keyword">new</span> PdfDecoder(<span class="keyword">true</span>);</span><br><span class="line">		FontMappings.setFontReplacements();</span><br><span class="line">		<span class="comment">// 修改图片的清晰度</span></span><br><span class="line">		pdfDecoder.scaling = scaling;</span><br><span class="line">		ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 打开pdf文件，生成PdfDecoder对象</span></span><br><span class="line">			pdfDecoder.openPdfArray(bytes); <span class="comment">// bytes is byte[] array with PDF</span></span><br><span class="line">			<span class="comment">// 获取第pageNum页的pdf</span></span><br><span class="line">			BufferedImage img = pdfDecoder.getPageAsImage(pageNum);</span><br><span class="line"></span><br><span class="line">			ImageIO.write(img, formatName, out);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (PdfException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<div align=center><img width="800" height="200" src="../../../../images/2017-11-13/iText/6.png" algin="center"/>

</div>

<p>Jpedal支持将指定页PDF生成图片，pdfDecoder.scaling设置图片的分辨率(不同分辨率下文件大小不同) ，支持多种图片格式，具体更多可自行研究。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于电子凭证的技术方案，总结如下:</p>
<ol>
<li>HTML模板+model数据，通过freemarker进行渲染，便于维护和修改。</li>
<li>渲染后的HTML流，可通过Flying Saucer组件生成HTML文件流，或者生成HTML后再转成jpg文件流。</li>
<li>在Web项目中，对应的文件流，可以通过ContentType设置，在线查看/下载，不需通过附件服务。</li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ(一)—角色与术语</title>
    <url>/RocketMQ-%E4%B8%80-%E2%80%94%E2%80%94%E8%A7%92%E8%89%B2%E4%B8%8E%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>我们通过缓存和消息队列来化解海量的读请求和写请求对后端数据库服务造成的压力。RocketMQ作为阿里巴巴开源的消息队列中间件，得到不少企业的青睐。在RocketMQ中有四大角色 <strong>NameServer</strong>、<strong>Broker</strong>、<strong>Producer</strong>和<strong>Consumer</strong>。<div align=center><img width="700" height="300" src="../../../../images/2019/4-6/overview.png" algin="center"/></div></p>
<h1 id="RocketMQ-特点"><a href="#RocketMQ-特点" class="headerlink" title="RocketMQ 特点"></a>RocketMQ 特点</h1><h2 id="灵活可扩展性"><a href="#灵活可扩展性" class="headerlink" title="灵活可扩展性"></a>灵活可扩展性</h2><p>RocketMQ天然支持集群，其核心四组件（<strong>NameServer</strong>、<strong>Broker</strong>、<strong>Producer</strong>、<strong>Consumer</strong>）每一个都可以在没有单点故障的情况下进行水平扩展。</p>
<h2 id="海量消息堆积能力"><a href="#海量消息堆积能力" class="headerlink" title="海量消息堆积能力"></a>海量消息堆积能力</h2><p>RocketMQ采用零拷贝原理实现超大的消息的堆积能力，据说单机已可以支持亿级消息堆积，而且在堆积了这么多消息后依然保持写入低延迟。</p>
<h2 id="支持顺序消息"><a href="#支持顺序消息" class="headerlink" title="支持顺序消息"></a>支持顺序消息</h2><p>可以保证消息消费者按照消息发送的顺序对消息进行消费。顺序消息分为全局有序和局部有序，一般推荐使用局部有序，即生产者通过将某一类消息按顺序发送至同一个队列来实现。</p>
<h2 id="多种消息过滤方式"><a href="#多种消息过滤方式" class="headerlink" title="多种消息过滤方式"></a>多种消息过滤方式</h2><p>消息过滤分为在服务器端过滤和在消费端过滤。服务器端过滤时可以按照消息消费者的要求做过滤，优点是减少不必要消息传输，缺点是增加了消息服务器的负担，实现相对复杂。消费端过滤则完全由具体应用自定义实现，这种方式更加灵活，缺点是很多无用的消息会传输给消息消费者。</p>
<h2 id="支持事务消息"><a href="#支持事务消息" class="headerlink" title="支持事务消息"></a>支持事务消息</h2><p>RocketMQ除了支持普通消息，顺序消息之外还支持事务消息，这个特性对于分布式事务来说提供了又一种解决思路。</p>
<h2 id="回溯消费"><a href="#回溯消费" class="headerlink" title="回溯消费"></a>回溯消费</h2><p>回溯消费是指消费者已经消费成功的消息，由于业务上需求需要重新消费，RocketMQ支持按照时间回溯消费，时间维度精确到毫秒，可以向前回溯，也可以向后回溯。</p>
<h1 id="Name-Server"><a href="#Name-Server" class="headerlink" title="Name Server"></a>Name Server</h1><p><code>NameServer</code>用来保存<code>Broker</code>相关元信息并提供给<code>Producer</code>和<code>Consumer</code>查找<code>Broker</code>信息。<code>NameServer</code>被设计成无状态的，可以横向扩展，节点之间相互之间无通信，通过部署多台机器来标记自己是一个伪集群。每个<code>Broker</code>在启动的时候会到<code>NameServer</code>注册，<code>Producer</code>在发送消息前会根据<code>Topic</code>到<code>NameServer</code>获取到<code>Broker</code>的路由信息，<code>Consumer</code>也会定时获取<code>Topic</code>的路由信息。</p>
<ul>
<li>Name Server是一个无状态的结点，Name Server之间采取share-nothing的设计，互不通信。</li>
<li>Name Server所有状态都从Broker上报而来，本身不存储任何状态，所有数据均在内存。</li>
<li>Name Server不会有频繁的读写，所以性能开销非常小，稳定性很高。</li>
<li>如果所有Name Server全都挂了，只会影响到Topic到Broker路由信息的更新，不会影响Topic和Broker的通信。</li>
</ul>
<h1 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h1><p><code>Broker</code>是消息存储中心，主要作用是接收来自<code>Producer</code>的消息并存储，<code>Consumer</code>从这里取得消息。它还存储与消息相关的元数据，包括用户组、消费进度偏移量、队列信息等。</p>
<ul>
<li>Broker向所有的NameServer结点建立长连接，注册Topic信息。</li>
<li>Broker分为master和slave。只有master才能进行写入操作，slave不允许。</li>
<li>slave从master中同步数据。同步策略取决于master的配置，可以采用同步刷盘，异步刷盘两种。</li>
<li>客户端消费可以从master和slave消费。在默认情况下，Consumer都从master消费，在master挂后，客户端由于从Name Server中感知到Broker挂机，就会从slave消费。</li>
</ul>
<h2 id="与Name-Server关系"><a href="#与Name-Server关系" class="headerlink" title="与Name Server关系"></a>与Name Server关系</h2><ul>
<li><strong>连接。</strong>单个Broker和所有NameServer保持长连接。</li>
<li><strong>心跳。</strong>每隔30秒（此时间无法更改）向所有NameServer发送心跳，心跳包含了自身的Topic配置信息。</li>
<li><strong>断开。</strong>当Broker挂掉时，心跳超时导致NameServer主动关闭连接。一旦连接断开，NameServer会立即感知，更新Topic与队列的对应关系，但不会通知生产者和消费者。</li>
</ul>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><ul>
<li>一个Topic分布在多个Broker上，一个Broker可以配置多个Topic，它们是多对多的关系。</li>
<li>如果某个Topic消息量很大，应该多配置几个队列，并尽量分布在不同Broker上，减轻某个Broker的压力。</li>
<li>Topic消息量比较均匀的情况下，如果某个Broker上的队列越多，则该Broker压力越大。</li>
</ul>
<h2 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h2><p>由于消息分布在各个Broker上，一旦某个Broker宕机，则该Broker上的消息读写都会受到影响。所以RocketMQ提供了master/slave的结构，salve定时从master同步数据。如果master宕机，则slave提供消费服务，但是不能写入消息，此过程对应用透明，由RocketMQ内部解决。</p>
<ul>
<li>一旦某个Broker master宕机，受限于RocketMQ的网络连接机制，默认情况下，生产者和消费者最多需要30秒会发现，但这个时间可由应用设定参数来缩短时间。这个时间段内，发往该Broker的消息都是失败的，而且该Broker的消息无法消费，因为此时消费者不知道该Broker已经挂掉。</li>
<li>消费者得到master宕机通知后，转向slave消费，但是slave不能保证master的消息100%都同步过来了，因此会有少量的消息丢失。但是消息最终不会丢的，一旦master恢复，未同步过去的消息会被消费掉。</li>
</ul>
<h1 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h1><p><code>Producer</code>负责产生消息，生产者向消息服务器发送由业务应用程序系统生成的消息。</p>
<h2 id="与Name-Server关系-1"><a href="#与Name-Server关系-1" class="headerlink" title="与Name Server关系"></a>与Name Server关系</h2><ul>
<li><strong>连接。</strong>单个生产者者和一台NameServer保持长连接，定时查询Topic配置信息，如果该NameServer挂掉，Producer会自动连接下一个NameServer，直到有可用连接为止，并能自动重连。</li>
<li><strong>轮询时间。</strong>生产者每30秒从NameServer获取Topic跟Broker的映射关系，更新到本地内存中。再跟Topic涉及的所有Broker建立长连接，每隔30秒发一次心跳。在Broker端也会每10秒扫描一次当前注册的Producer，如果发现某个Producer超过2分钟都没有发心跳，则断开连接。</li>
</ul>
<h2 id="与broker关系"><a href="#与broker关系" class="headerlink" title="与broker关系"></a>与broker关系</h2><ul>
<li><strong>连接。</strong>单个生产者和该生产者关联的所有Broker保持长连接。</li>
<li><strong>心跳。</strong>默认情况下，生产者每隔30秒向所有Broker发送心跳，该时间由DefaultMQProducer的<code>heartbeatBrokerInterval</code>参数决定，可手动配置。Broker每隔10秒钟（此时间无法更改），扫描所有还存活的连接，若某个连接2分钟内（当前时间与最后更新时间差值超过2分钟，此时间无法更改）没有发送心跳数据，则关闭连接。</li>
<li><strong>连接断开。</strong>移除Broker上的生产者信息。</li>
</ul>
<blockquote>
<p>假如某个Broker宕机，意味生产者最长需要30秒才能感知到。在这期间会向宕机的Broker发送消息。当一条消息发送到某个Broker失败后，会往该Broker自动再重发2次，假如还是发送失败，则抛出发送失败异常。业务捕获异常，重新发送即可。客户端里会自动轮询另外一个Broker重新发送，这个对于用户是透明的。</p>
</blockquote>
<h2 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>生产者发送时，会自动轮询当前所有可发送的Broker，一条消息发送成功，下次换另外一个Broker发送，以达到消息平均落到所有的Broker上。</p>
<h1 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h1><p>消费消息的客户端角色。通常是后台处理异步消费的系统。 </p>
<blockquote>
<p>RocketMQ中Consumer有两种实现：PushConsumer和PullConsumer。</p>
<p>消费者有两种模式消费：集群消费(clustering)，广播消费(broadcast)。</p>
</blockquote>
<h2 id="与NameServer关系"><a href="#与NameServer关系" class="headerlink" title="与NameServer关系"></a>与NameServer关系</h2><ul>
<li><strong>连接。</strong>单个消费者和一台NameServer保持长连接，定时查询Topic配置信息，如果该NameServer挂掉，消费者会自动连接下一个NameServer，直到有可用连接为止，并能自动重连。</li>
<li><strong>轮询时间。</strong>消费者每隔30秒从NameServer获取所有Topic的最新队列情况，这意味着某个Broker如果宕机，客户端最多要30秒才能感知。连接建立后，从NameServer中获取当前消费Topic所涉及的Broker，直连Broker。</li>
</ul>
<h2 id="与broker关系-1"><a href="#与broker关系-1" class="headerlink" title="与broker关系"></a>与broker关系</h2><ul>
<li><strong>连接。</strong>单个消费者和该消费者关联的所有Broker保持长连接。</li>
<li><strong>心跳。</strong>Consumer跟Broker是长连接，会每隔30秒发心跳信息到Broker。Broker端每10秒检查一次当前存活的Consumer，若发现某个Consumer 2分钟内没有心跳，就断开与该Consumer的连接，并且向该消费组的其他实例发送通知，触发该消费者集群的负载均衡。</li>
<li><strong>断开。</strong>一旦连接断开，Broker会立即感知到，并向该消费者分组的所有消费者发出通知，分组内消费者重新分配队列继续消费。</li>
</ul>
<h2 id="负载均衡-2"><a href="#负载均衡-2" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>集群消费模式下，一个消费者集群多台机器共同消费一个Topic的多个队列，一个队列只会被一个消费者消费。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。</p>
<h1 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h1><ul>
<li>客户端的公共配置类：<strong>ClientConfig</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">NamesrvAddr</td>
<td align="left">无</td>
<td align="left">NameServer地址列表，多个nameServer地址用分号隔开</td>
</tr>
<tr>
<td align="left">clientIP</td>
<td align="left">本机IP</td>
<td align="left">客户端本机IP地址，某些机器会发生无法识别客户端IP地址情况，需要应用在代码中强制指定</td>
</tr>
<tr>
<td align="left">instanceName</td>
<td align="left">DEFAULT</td>
<td align="left">客户端实例名称，客户端创建的多个Producer，Consumer实际是共用一个内部实例（这个实例包含网络连接，线程资源等）</td>
</tr>
<tr>
<td align="left">clientCallbackExecutorThreads</td>
<td align="left">4</td>
<td align="left">通信层异步回调线程数</td>
</tr>
<tr>
<td align="left">pollNameServerInteval</td>
<td align="left">30000</td>
<td align="left">轮询Name Server 间隔时间，单位毫秒</td>
</tr>
<tr>
<td align="left">heartbeatBrokerInterval</td>
<td align="left">30000</td>
<td align="left">向Broker发送心跳间隔时间，单位毫秒</td>
</tr>
<tr>
<td align="left">persistConsumerOffsetInterval</td>
<td align="left">5000</td>
<td align="left">持久化Consumer消费进度间隔时间，单位毫秒</td>
</tr>
</tbody></table>
<ul>
<li>Producer配置</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">producerGroup</td>
<td align="left">DEFAULT_PRODUCER</td>
<td align="left">Producer组名，多个Producer如果属于一个应用，发送同样的消息，则应该将它们归为同一组。标识发送同一类消息的Producer，通常发送逻辑一致。发送普通消息的时候，仅标识使用，并无特别用处。若事务消息，如果某条发送某条消息的producer-A宕机，使得事务消息一直处于PREPARED状态并超时，则broker会回查同一个group的其 他producer，确认这条消息应该commit还是rollback。</td>
</tr>
<tr>
<td align="left">createTopicKey</td>
<td align="left">TBW102</td>
<td align="left">在发送消息时，自动创建服务器不存在的topic，需要指定key</td>
</tr>
<tr>
<td align="left">defaultTopicQueueNums</td>
<td align="left">4</td>
<td align="left">在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</td>
</tr>
<tr>
<td align="left">sendMsgTimeout</td>
<td align="left">10000</td>
<td align="left">发送消息超时时间，单位毫秒</td>
</tr>
<tr>
<td align="left">compressMsgBodyOverHowmuch</td>
<td align="left">4096</td>
<td align="left">消息Body超过多大开始压缩（Consumer收到消息会自动解压缩），单位字节</td>
</tr>
<tr>
<td align="left">retryAnotherBrokerWhenNotStoreOK</td>
<td align="left">FALSE</td>
<td align="left">如果发送消息返回sendResult,但是sendStatus!=SEND_OK,是否重试发送</td>
</tr>
<tr>
<td align="left">maxMessageSize</td>
<td align="left">131072</td>
<td align="left">客户端限制的消息大小，超过报错，同时服务端也会限制（默认128K）</td>
</tr>
<tr>
<td align="left">transactionCheckListener</td>
<td align="left">无</td>
<td align="left">事物消息回查监听器，如果发送事务消息，必须设置</td>
</tr>
<tr>
<td align="left">checkThreadPoolMinSize</td>
<td align="left">1</td>
<td align="left">Broker回查Producer事务状态时，线程池大小</td>
</tr>
<tr>
<td align="left">checkThreadPoolMaxSize</td>
<td align="left">1</td>
<td align="left">Broker回查Producer事务状态时，线程池大小</td>
</tr>
<tr>
<td align="left">checkRequestHoldMax</td>
<td align="left">2000</td>
<td align="left">Broker回查Producer事务状态时，Producer本地缓冲请求队列大小</td>
</tr>
</tbody></table>
<ul>
<li>PushConsumer配置</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">consumerGroup</td>
<td align="left">DEFAULT_CONSUMER</td>
<td align="left">Consumer组名，多个Consumer如果属于一个应用，订阅同样的消息，且消费逻辑一致，则应将它们归为同一组。消费进度以Consumer Group为粒度管理，不同Consumer Group之间消费进度彼此不受影响，即消息A被Consumer Group1消费过，也会再给Consumer Group2消费</td>
</tr>
<tr>
<td align="left">messageModel</td>
<td align="left">CLUSTERING</td>
<td align="left">消息模型，支持以下两种1.集群消费2.广播消费</td>
</tr>
<tr>
<td align="left">consumeFromWhere</td>
<td align="left">CONSUME_FROM_LAST_OFFSET</td>
<td align="left">Consumer启动后，默认从什么位置开始消费</td>
</tr>
<tr>
<td align="left">allocateMessageQueueStrategy</td>
<td align="left">AllocateMessageQueueAveragely</td>
<td align="left">Rebalance算法实现策略</td>
</tr>
<tr>
<td align="left">Subscription</td>
<td align="left">{}</td>
<td align="left">订阅关系</td>
</tr>
<tr>
<td align="left">messageListener</td>
<td align="left">无</td>
<td align="left">消息监听器</td>
</tr>
<tr>
<td align="left">offsetStore</td>
<td align="left">无</td>
<td align="left">消费进度存储</td>
</tr>
<tr>
<td align="left">consumeThreadMin</td>
<td align="left">20</td>
<td align="left">消费线程池数量</td>
</tr>
<tr>
<td align="left">consumeThreadMax</td>
<td align="left">64</td>
<td align="left">消费线程池数量</td>
</tr>
<tr>
<td align="left">consumeConcurrentlyMaxSpan</td>
<td align="left">2000</td>
<td align="left">单队列并行消费允许的最大跨度</td>
</tr>
<tr>
<td align="left">pullThresholdForQueue</td>
<td align="left">1000</td>
<td align="left">拉消息本地队列缓存消息最大数</td>
</tr>
<tr>
<td align="left">Pullinterval</td>
<td align="left">0</td>
<td align="left">拉消息间隔，由于是长轮询，所以为0，但是如果应用了流控，也可以设置大于0的值，单位毫秒</td>
</tr>
<tr>
<td align="left">consumeMessageBatchMaxSize</td>
<td align="left">1</td>
<td align="left">批量消费，一次消费多少条消息</td>
</tr>
<tr>
<td align="left">pullBatchSize</td>
<td align="left">32</td>
<td align="left">批量拉消息，一次最多拉多少条</td>
</tr>
</tbody></table>
<ul>
<li>PullConsumer配置</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">consumerGroup</td>
<td align="left">无</td>
<td align="left">Conusmer组名，多个Consumer如果属于一个应用，订阅同样的消息，且消费逻辑一致，则应该将它们归为同一组</td>
</tr>
<tr>
<td align="left">brokerSuspendMaxTimeMillis</td>
<td align="left">20000</td>
<td align="left">长轮询，Consumer拉消息请求在Broker挂起最长时间，单位毫秒</td>
</tr>
<tr>
<td align="left">consumerPullTimeoutMillis</td>
<td align="left">10000</td>
<td align="left">非长轮询，拉消息超时时间，单位毫秒</td>
</tr>
<tr>
<td align="left">consumerTimeoutMillisWhenSuspend</td>
<td align="left">30000</td>
<td align="left">长轮询，Consumer拉消息请求咋broker挂起超过指定时间，客户端认为超时，单位毫秒</td>
</tr>
<tr>
<td align="left">messageModel</td>
<td align="left">BROADCASTING</td>
<td align="left">消息模型，支持以下两种：1集群消费 2广播模式</td>
</tr>
<tr>
<td align="left">messageQueueListener</td>
<td align="left">无</td>
<td align="left">监听队列变化</td>
</tr>
<tr>
<td align="left">offsetStore</td>
<td align="left">无</td>
<td align="left">消费进度存储</td>
</tr>
<tr>
<td align="left">registerTopics</td>
<td align="left">无</td>
<td align="left">注册的topic集合</td>
</tr>
<tr>
<td align="left">allocateMessageQueueStrategy</td>
<td align="left">无</td>
<td align="left">Rebalance算法实现策略</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring+Mybatis之Mapper热部署</title>
    <url>/Spring-Mybatis%E4%B9%8BMapper%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>​    Spring+Mybatis经常用，在项目中最痛苦的就是修改mapper文件的时候需要重启一下项目，每修改一次就需要重启一次项目。项目小还好，如果项目大，重启一次项目简直是要命。所以，去网上查资料看有没有办法让mybatis热部署，每次更新mapper文件不需要重启项目。</p>
<p>​    功夫不负有心人，终于找到了，这玩意只要发现mapper文件被修改，就会重新加载被修改的mapper文件。且<strong>只加载被修改的mapper文件</strong>！这个可省事了，效率又高，简直爽到爆。<div align=center><img width="700" height="300" src="../../../../images/2017-9-15/mybatis-mapper/relationship-with-mybatis.png" algin="center"/></div><span id="more"></span></p>
<h1 id="创建MapperRefresh刷新类"><a href="#创建MapperRefresh刷新类" class="headerlink" title="创建MapperRefresh刷新类"></a>创建MapperRefresh刷新类</h1><p>在src下创建一个util包，包下面创建一个类，类名为：<strong>MapperRefresh</strong></p>
<div align=center><img width="700" height="300" src="../../../../images/2017-9-15/mybatis-mapper/refresh.png" algin="center"/>

</div>

<p>代码为下面的一串，注意修改下<strong>mybatis-refresh.properties</strong> 的路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.talkweb.nets.netsTestLib.data.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;  </span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;  </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;  </span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;  </span><br><span class="line"><span class="keyword">import</span> java.util.List;  </span><br><span class="line"><span class="keyword">import</span> java.util.Map;  </span><br><span class="line"><span class="keyword">import</span> java.util.Properties;  </span><br><span class="line"><span class="keyword">import</span> java.util.Set;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;  </span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.builder.xml.XMLMapperBuilder;  </span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.executor.ErrorContext;  </span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.Configuration;  </span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.core.NestedIOException;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Sets;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 刷新MyBatis Mapper XML 线程 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ThinkGem 这个是原著的作者，我只是直接拿来用了，原著莫怪</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2016-5-29 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperRefresh</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Runnable</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Logger log = Logger.getLogger(MapperRefresh.class);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String filename = <span class="string">&quot;mybatis-refresh.properties&quot;</span>;  <span class="comment">//注意修改路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties prop = <span class="keyword">new</span> Properties();  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> enabled;         <span class="comment">// 是否启用Mapper刷新线程功能  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> refresh;         <span class="comment">// 刷新启用后，是否启动了刷新线程  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; location;         <span class="comment">// Mapper实际资源路径  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Resource[] mapperLocations;     <span class="comment">// Mapper资源路径  </span></span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;        <span class="comment">// MyBatis配置对象  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long beforeTime = <span class="number">0L</span>;           <span class="comment">// 上一次刷新时间  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> delaySeconds;        <span class="comment">// 延迟刷新秒数  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sleepSeconds;        <span class="comment">// 休眠时间  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String mappingPath;      <span class="comment">// xml文件夹匹配字符串，需要根据需要修改  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            prop.load(MapperRefresh.class.getResourceAsStream(filename));  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">            System.out.println(<span class="string">&quot;Load mybatis-refresh “&quot;</span>+filename+<span class="string">&quot;” file error.&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        enabled = <span class="string">&quot;true&quot;</span>.equalsIgnoreCase(getPropString(<span class="string">&quot;enabled&quot;</span>));  </span><br><span class="line"></span><br><span class="line">        delaySeconds = getPropInt(<span class="string">&quot;delaySeconds&quot;</span>);  </span><br><span class="line">        sleepSeconds = getPropInt(<span class="string">&quot;sleepSeconds&quot;</span>);  </span><br><span class="line">        mappingPath = getPropString(<span class="string">&quot;mappingPath&quot;</span>);  </span><br><span class="line"></span><br><span class="line">        delaySeconds = delaySeconds == <span class="number">0</span> ? <span class="number">50</span> : delaySeconds;  </span><br><span class="line">        sleepSeconds = sleepSeconds == <span class="number">0</span> ? <span class="number">3</span> : sleepSeconds;  </span><br><span class="line">        mappingPath = StringUtils.isBlank(mappingPath) ? <span class="string">&quot;mappings&quot;</span> : mappingPath;  </span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;[enabled] &quot;</span> + enabled);  </span><br><span class="line">        log.debug(<span class="string">&quot;[delaySeconds] &quot;</span> + delaySeconds);  </span><br><span class="line">        log.debug(<span class="string">&quot;[sleepSeconds] &quot;</span> + sleepSeconds);  </span><br><span class="line">        log.debug(<span class="string">&quot;[mappingPath] &quot;</span> + mappingPath);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRefresh</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> refresh;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapperRefresh</span><span class="params">(Resource[] mapperLocations, Configuration configuration)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.mapperLocations = mapperLocations;  </span><br><span class="line">        <span class="keyword">this</span>.configuration = configuration;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">        beforeTime = System.currentTimeMillis();  </span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;[location] &quot;</span> + location);  </span><br><span class="line">        log.debug(<span class="string">&quot;[configuration] &quot;</span> + configuration);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (enabled) &#123;  </span><br><span class="line">            <span class="comment">// 启动刷新线程  </span></span><br><span class="line">            <span class="keyword">final</span> MapperRefresh runnable = <span class="keyword">this</span>;  </span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> java.lang.Runnable() &#123;  </span><br><span class="line">                <span class="meta">@Override</span>  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (location == <span class="keyword">null</span>)&#123;  </span><br><span class="line">                        location = Sets.newHashSet();  </span><br><span class="line">                        log.debug(<span class="string">&quot;MapperLocation&#x27;s length:&quot;</span> + mapperLocations.length);  </span><br><span class="line">                        <span class="keyword">for</span> (Resource mapperLocation : mapperLocations) &#123;  </span><br><span class="line">                            String s = mapperLocation.toString().replaceAll(<span class="string">&quot;\\\\&quot;</span>, <span class="string">&quot;/&quot;</span>);  </span><br><span class="line">                            s = s.substring(<span class="string">&quot;file [&quot;</span>.length(), s.lastIndexOf(mappingPath) + mappingPath.length());  </span><br><span class="line">                            <span class="keyword">if</span> (!location.contains(s)) &#123;  </span><br><span class="line">                                location.add(s);  </span><br><span class="line">                                log.debug(<span class="string">&quot;Location:&quot;</span> + s);  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        log.debug(<span class="string">&quot;Locarion&#x27;s size:&quot;</span> + location.size());  </span><br><span class="line">                    &#125;  </span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;  </span><br><span class="line">                        Thread.sleep(delaySeconds * <span class="number">1000</span>);  </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e2) &#123;  </span><br><span class="line">                        e2.printStackTrace();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    refresh = <span class="keyword">true</span>;  </span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;========= Enabled refresh mybatis mapper =========&quot;</span>);  </span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">                        <span class="keyword">try</span> &#123;  </span><br><span class="line">                            <span class="keyword">for</span> (String s : location) &#123;  </span><br><span class="line">                                runnable.refresh(s, beforeTime);  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e1) &#123;  </span><br><span class="line">                            e1.printStackTrace();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        <span class="keyword">try</span> &#123;  </span><br><span class="line">                            Thread.sleep(sleepSeconds * <span class="number">1000</span>);  </span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                            e.printStackTrace();  </span><br><span class="line">                        &#125;  </span><br><span class="line"></span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;, <span class="string">&quot;MyBatis-Mapper-Refresh&quot;</span>).start();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 执行刷新 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath 刷新目录 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beforeTime 上次刷新时间 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NestedIOException 解析异常 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> FileNotFoundException 文件未找到 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> ThinkGem </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">(String filePath, Long beforeTime)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本次刷新时间  </span></span><br><span class="line">        Long refrehTime = System.currentTimeMillis();  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取需要刷新的Mapper文件列表  </span></span><br><span class="line">        List&lt;File&gt; fileList = <span class="keyword">this</span>.getRefreshFile(<span class="keyword">new</span> File(filePath), beforeTime);  </span><br><span class="line">        <span class="keyword">if</span> (fileList.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            log.debug(<span class="string">&quot;Refresh file: &quot;</span> + fileList.size());  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fileList.size(); i++) &#123;  </span><br><span class="line">            InputStream inputStream = <span class="keyword">new</span> FileInputStream(fileList.get(i));  </span><br><span class="line">            String resource = fileList.get(i).getAbsolutePath();  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 清理原有资源，更新为自己的StrictMap方便，增量重新加载  </span></span><br><span class="line">                String[] mapFieldNames = <span class="keyword">new</span> String[]&#123;  </span><br><span class="line">                    <span class="string">&quot;mappedStatements&quot;</span>, <span class="string">&quot;caches&quot;</span>,  </span><br><span class="line">                    <span class="string">&quot;resultMaps&quot;</span>, <span class="string">&quot;parameterMaps&quot;</span>,  </span><br><span class="line">                    <span class="string">&quot;keyGenerators&quot;</span>, <span class="string">&quot;sqlFragments&quot;</span>  </span><br><span class="line">                &#125;;  </span><br><span class="line">                <span class="keyword">for</span> (String fieldName : mapFieldNames)&#123;  </span><br><span class="line">                    Field field = configuration.getClass().getDeclaredField(fieldName);  </span><br><span class="line">                    field.setAccessible(<span class="keyword">true</span>);  </span><br><span class="line">                    Map map = ((Map)field.get(configuration));  </span><br><span class="line">                    <span class="keyword">if</span> (!(map <span class="keyword">instanceof</span> StrictMap))&#123;  </span><br><span class="line">                        Map newMap = <span class="keyword">new</span> StrictMap(StringUtils.capitalize(fieldName) + <span class="string">&quot;collection&quot;</span>);  </span><br><span class="line">                        <span class="keyword">for</span> (Object key : map.keySet())&#123;  </span><br><span class="line">                            <span class="keyword">try</span> &#123;  </span><br><span class="line">                                newMap.put(key, map.get(key));  </span><br><span class="line">                            &#125;<span class="keyword">catch</span>(IllegalArgumentException ex)&#123;  </span><br><span class="line">                                newMap.put(key, ex.getMessage());  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        field.set(configuration, newMap);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 清理已加载的资源标识，方便让它重新加载。  </span></span><br><span class="line">                Field loadedResourcesField = configuration.getClass().getDeclaredField(<span class="string">&quot;loadedResources&quot;</span>);  </span><br><span class="line">                loadedResourcesField.setAccessible(<span class="keyword">true</span>);  </span><br><span class="line">                Set loadedResourcesSet = ((Set)loadedResourcesField.get(configuration));  </span><br><span class="line">                loadedResourcesSet.remove(resource);  </span><br><span class="line"></span><br><span class="line">                <span class="comment">//重新编译加载资源文件。  </span></span><br><span class="line">                XMLMapperBuilder xmlMapperBuilder = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration,   </span><br><span class="line">                        resource, configuration.getSqlFragments());  </span><br><span class="line">                xmlMapperBuilder.parse();  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">&quot;Failed to parse mapping resource: &#x27;&quot;</span> + resource + <span class="string">&quot;&#x27;&quot;</span>, e);  </span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">                ErrorContext.instance().reset();  </span><br><span class="line">            &#125;  </span><br><span class="line">            System.out.println(<span class="string">&quot;Refresh file: &quot;</span> + mappingPath + StringUtils.substringAfterLast(fileList.get(i).getAbsolutePath(), mappingPath));  </span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;  </span><br><span class="line">                log.debug(<span class="string">&quot;Refresh file: &quot;</span> + fileList.get(i).getAbsolutePath());  </span><br><span class="line">                log.debug(<span class="string">&quot;Refresh filename: &quot;</span> + fileList.get(i).getName());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 如果刷新了文件，则修改刷新时间，否则不修改  </span></span><br><span class="line">        <span class="keyword">if</span> (fileList.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">this</span>.beforeTime = refrehTime;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 获取需要刷新的文件列表 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dir 目录 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beforeTime 上次刷新时间 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 刷新文件列表 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;File&gt; <span class="title">getRefreshFile</span><span class="params">(File dir, Long beforeTime)</span> </span>&#123;  </span><br><span class="line">        List&lt;File&gt; fileList = <span class="keyword">new</span> ArrayList&lt;File&gt;();  </span><br><span class="line"></span><br><span class="line">        File[] files = dir.listFiles();  </span><br><span class="line">        <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;  </span><br><span class="line">                File file = files[i];  </span><br><span class="line">                <span class="keyword">if</span> (file.isDirectory()) &#123;  </span><br><span class="line">                    fileList.addAll(<span class="keyword">this</span>.getRefreshFile(file, beforeTime));  </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isFile()) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.checkFile(file, beforeTime)) &#123;  </span><br><span class="line">                        fileList.add(file);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    System.out.println(<span class="string">&quot;Error file.&quot;</span> + file.getName());  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> fileList;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 判断文件是否需要刷新 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file 文件 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beforeTime 上次刷新时间 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 需要刷新返回true，否则返回false </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkFile</span><span class="params">(File file, Long beforeTime)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (file.lastModified() &gt; beforeTime) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 获取整数属性 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getPropInt</span><span class="params">(String key)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            i = Integer.parseInt(getPropString(key));  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> i;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 获取字符串属性 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getPropString</span><span class="params">(String key)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> prop == <span class="keyword">null</span> ? <span class="keyword">null</span> : prop.getProperty(key);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 重写 org.apache.ibatis.session.Configuration.StrictMap 类 </span></span><br><span class="line"><span class="comment">     * 来自 MyBatis3.4.0版本，修改 put 方法，允许反复 put更新。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StrictMap</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">String</span>, <span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4950446264854982944L</span>;  </span><br><span class="line">        <span class="keyword">private</span> String name;  </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StrictMap</span><span class="params">(String name, <span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">super</span>(initialCapacity, loadFactor);  </span><br><span class="line">            <span class="keyword">this</span>.name = name;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StrictMap</span><span class="params">(String name, <span class="keyword">int</span> initialCapacity)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">super</span>(initialCapacity);  </span><br><span class="line">            <span class="keyword">this</span>.name = name;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StrictMap</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">super</span>();  </span><br><span class="line">            <span class="keyword">this</span>.name = name;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StrictMap</span><span class="params">(String name, Map&lt;String, ? extends V&gt; m)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">super</span>(m);  </span><br><span class="line">            <span class="keyword">this</span>.name = name;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(String key, V value)</span> </span>&#123;  </span><br><span class="line">            <span class="comment">// ThinkGem 如果现在状态为刷新，则刷新(先删除后添加)  </span></span><br><span class="line">            <span class="keyword">if</span> (MapperRefresh.isRefresh()) &#123;  </span><br><span class="line">                remove(key);  </span><br><span class="line">                MapperRefresh.log.debug(<span class="string">&quot;refresh key:&quot;</span> + key.substring(key.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>));  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// ThinkGem end  </span></span><br><span class="line">            <span class="keyword">if</span> (containsKey(key)) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(name + <span class="string">&quot; already contains value for &quot;</span> + key);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (key.contains(<span class="string">&quot;.&quot;</span>)) &#123;  </span><br><span class="line">                <span class="keyword">final</span> String shortKey = getShortName(key);  </span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">super</span>.get(shortKey) == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    <span class="keyword">super</span>.put(shortKey, value);  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    <span class="keyword">super</span>.put(shortKey, (V) <span class="keyword">new</span> Ambiguity(shortKey));  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.put(key, value);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;  </span><br><span class="line">            V value = <span class="keyword">super</span>.get(key);  </span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(name + <span class="string">&quot; does not contain value for &quot;</span> + key);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Ambiguity) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(((Ambiguity) value).getSubject() + <span class="string">&quot; is ambiguous in &quot;</span> + name  </span><br><span class="line">                        + <span class="string">&quot; (try using the full name including the namespace, or rename one of the entries)&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> value;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">getShortName</span><span class="params">(String key)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">final</span> String[] keyparts = key.split(<span class="string">&quot;\\.&quot;</span>);  </span><br><span class="line">            <span class="keyword">return</span> keyparts[keyparts.length - <span class="number">1</span>];  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ambiguity</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">private</span> String subject;  </span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Ambiguity</span><span class="params">(String subject)</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">this</span>.subject = subject;  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getSubject</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">return</span> subject;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="重写SqlSessionFactoryBean"><a href="#重写SqlSessionFactoryBean" class="headerlink" title="重写SqlSessionFactoryBean"></a>重写SqlSessionFactoryBean</h1><p>MyBatis有几个不太好的地方，是当实体类别名重名的时候，Mapper XML有错误的时候，系统启动时会一直等待无法正常启动（其实是加载失败后又重新加载，进入了死循环），这里重写下SqlSessionFactoryBean.java文件，解决这个问题，在这个文件里也加入启动上面写的线程类：</p>
<p>1、修改实体类重名的时候抛出并打印异常，否则系统会一直递归造成无法启动。<br>2、MapperXML有错误的时候抛出并打印异常，否则系统会一直递归造成无法启动。<br>3、加入启动MapperRefresh.java线程服务。</p>
<p>思路就是用我们<strong>自己重写的SqlSessionFactoryBean.class替换mybatis-spring-1.2.2.jar中的SqlSessionFactoryBean.class</strong>。</p>
<ol>
<li><p>在当前项目下新建一个包：右键 <em>src &gt; new Package &gt;</em> <em>org.mybatis.spring</em>，创建SqlSessionFactoryBean.java类。</p>
<div align=center><img width="700" height="300" src="../../../../images/2017-9-15/mybatis-mapper/sqlSessionfactory-java.png" algin="center"/>

</div></li>
<li><p>复制下面一串代码到SqlSessionFactoryBean.java，注意导入<code>MapperRefresh</code>正确的包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mybatis.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.builder.xml.XMLConfigBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.builder.xml.XMLMapperBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.executor.ErrorContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.logging.LogFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.mapping.DatabaseIdProvider;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.mapping.Environment;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.plugin.Interceptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.factory.ObjectFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.wrapper.ObjectWrapperFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.transaction.TransactionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.type.TypeAliasRegistry;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.type.TypeHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.type.TypeHandlerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.transaction.SpringManagedTransactionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEvent;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.event.ContextRefreshedEvent;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.NestedIOException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.ObjectUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.talkweb.nets.netsTestLib.data.util.MapperRefresh;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionFactoryBean</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">SqlSessionFactory</span>&gt;, <span class="title">InitializingBean</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(SqlSessionFactoryBean.class);</span><br><span class="line">    <span class="keyword">private</span> Resource configLocation;</span><br><span class="line">    <span class="keyword">private</span> Resource[] mapperLocations;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    <span class="keyword">private</span> TransactionFactory transactionFactory;</span><br><span class="line">    <span class="keyword">private</span> Properties configurationProperties;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">private</span> String environment = SqlSessionFactoryBean.class.getSimpleName();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> failFast;</span><br><span class="line">    <span class="keyword">private</span> Interceptor[] plugins;</span><br><span class="line">    <span class="keyword">private</span> TypeHandler&lt;?&gt;[] typeHandlers;</span><br><span class="line">    <span class="keyword">private</span> String typeHandlersPackage;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] typeAliases;</span><br><span class="line">    <span class="keyword">private</span> String typeAliasesPackage;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; typeAliasesSuperType;</span><br><span class="line">    <span class="keyword">private</span> DatabaseIdProvider databaseIdProvider;</span><br><span class="line">    <span class="keyword">private</span> ObjectFactory objectFactory;</span><br><span class="line">    <span class="keyword">private</span> ObjectWrapperFactory objectWrapperFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObjectFactory</span><span class="params">(ObjectFactory objectFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objectFactory = objectFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObjectWrapperFactory</span><span class="params">(ObjectWrapperFactory objectWrapperFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objectWrapperFactory = objectWrapperFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DatabaseIdProvider <span class="title">getDatabaseIdProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.databaseIdProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDatabaseIdProvider</span><span class="params">(DatabaseIdProvider databaseIdProvider)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.databaseIdProvider = databaseIdProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPlugins</span><span class="params">(Interceptor[] plugins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.plugins = plugins;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTypeAliasesPackage</span><span class="params">(String typeAliasesPackage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.typeAliasesPackage = typeAliasesPackage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTypeAliasesSuperType</span><span class="params">(Class&lt;?&gt; typeAliasesSuperType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.typeAliasesSuperType = typeAliasesSuperType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTypeHandlersPackage</span><span class="params">(String typeHandlersPackage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.typeHandlersPackage = typeHandlersPackage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTypeHandlers</span><span class="params">(TypeHandler&lt;?&gt;[] typeHandlers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.typeHandlers = typeHandlers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTypeAliases</span><span class="params">(Class&lt;?&gt;[] typeAliases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.typeAliases = typeAliases;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFailFast</span><span class="params">(<span class="keyword">boolean</span> failFast)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.failFast = failFast;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocation</span><span class="params">(Resource configLocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configLocation = configLocation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMapperLocations</span><span class="params">(Resource[] mapperLocations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mapperLocations = mapperLocations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigurationProperties</span><span class="params">(Properties sqlSessionFactoryProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configurationProperties = sqlSessionFactoryProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((dataSource <span class="keyword">instanceof</span> TransactionAwareDataSourceProxy)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource();</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSessionFactoryBuilder</span><span class="params">(SqlSessionFactoryBuilder sqlSessionFactoryBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlSessionFactoryBuilder = sqlSessionFactoryBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransactionFactory</span><span class="params">(TransactionFactory transactionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.transactionFactory = transactionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(String environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Assert.notNull(<span class="keyword">this</span>.dataSource, <span class="string">&quot;Property &#x27;dataSource&#x27; is required&quot;</span>);</span><br><span class="line">        Assert.notNull(<span class="keyword">this</span>.sqlSessionFactoryBuilder, <span class="string">&quot;Property &#x27;sqlSessionFactoryBuilder&#x27; is required&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.sqlSessionFactory = buildSqlSessionFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SqlSessionFactory <span class="title">buildSqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        XMLConfigBuilder xmlConfigBuilder = <span class="keyword">null</span>;</span><br><span class="line">        Configuration configuration;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.configLocation != <span class="keyword">null</span>) &#123;</span><br><span class="line">            xmlConfigBuilder = <span class="keyword">new</span> XMLConfigBuilder(<span class="keyword">this</span>.configLocation.getInputStream(), <span class="keyword">null</span>,</span><br><span class="line">                    <span class="keyword">this</span>.configurationProperties);</span><br><span class="line">            configuration = xmlConfigBuilder.getConfiguration();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Property &#x27;configLocation&#x27; not specified, using default MyBatis Configuration&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">            configuration.setVariables(<span class="keyword">this</span>.configurationProperties);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.objectFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            configuration.setObjectFactory(<span class="keyword">this</span>.objectFactory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.objectWrapperFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            configuration.setObjectWrapperFactory(<span class="keyword">this</span>.objectWrapperFactory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(<span class="keyword">this</span>.typeAliasesPackage)) &#123;</span><br><span class="line">            String[] typeAliasPackageArray = StringUtils.tokenizeToStringArray(<span class="keyword">this</span>.typeAliasesPackage, <span class="string">&quot;,; \t\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (String packageToScan : typeAliasPackageArray) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 修改处：ThinkGem 修改实体类重名的时候抛出并打印异常，否则系统会一直递归造成无法启动</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    configuration.getTypeAliasRegistry().registerAliases(packageToScan,</span><br><span class="line">                            typeAliasesSuperType == <span class="keyword">null</span> ? Object.class : typeAliasesSuperType);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;Scanned package: &#x27;&quot;</span> + packageToScan + <span class="string">&quot;&#x27; for aliases&quot;</span>, ex);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">&quot;Scanned package: &#x27;&quot;</span> + packageToScan + <span class="string">&quot;&#x27; for aliases&quot;</span>, ex);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ErrorContext.instance().reset();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 修改处：ThinkGem end</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Scanned package: &#x27;&quot;</span> + packageToScan + <span class="string">&quot;&#x27; for aliases&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="keyword">this</span>.typeAliases)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Class typeAlias : <span class="keyword">this</span>.typeAliases) &#123;</span><br><span class="line">                configuration.getTypeAliasRegistry().registerAlias(typeAlias);</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Registered type alias: &#x27;&quot;</span> + typeAlias + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="keyword">this</span>.plugins)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Interceptor plugin : <span class="keyword">this</span>.plugins) &#123;</span><br><span class="line">                configuration.addInterceptor(plugin);</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Registered plugin: &#x27;&quot;</span> + plugin + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(<span class="keyword">this</span>.typeHandlersPackage)) &#123;</span><br><span class="line">            String[] typeHandlersPackageArray = StringUtils.tokenizeToStringArray(<span class="keyword">this</span>.typeHandlersPackage, <span class="string">&quot;,; \t\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (String packageToScan : typeHandlersPackageArray) &#123;</span><br><span class="line">                configuration.getTypeHandlerRegistry().register(packageToScan);</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Scanned package: &#x27;&quot;</span> + packageToScan + <span class="string">&quot;&#x27; for type handlers&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="keyword">this</span>.typeHandlers)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (TypeHandler typeHandler : <span class="keyword">this</span>.typeHandlers) &#123;</span><br><span class="line">                configuration.getTypeHandlerRegistry().register(typeHandler);</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Registered type handler: &#x27;&quot;</span> + typeHandler + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (xmlConfigBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                xmlConfigBuilder.parse();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled())</span><br><span class="line">                    logger.debug(<span class="string">&quot;Parsed configuration file: &#x27;&quot;</span> + <span class="keyword">this</span>.configLocation + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">&quot;Failed to parse config resource: &quot;</span> + <span class="keyword">this</span>.configLocation, ex);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ErrorContext.instance().reset();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.transactionFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.transactionFactory = <span class="keyword">new</span> SpringManagedTransactionFactory();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Environment environment = <span class="keyword">new</span> Environment(<span class="keyword">this</span>.environment, <span class="keyword">this</span>.transactionFactory, <span class="keyword">this</span>.dataSource);</span><br><span class="line">        configuration.setEnvironment(environment);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.databaseIdProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                configuration.setDatabaseId(<span class="keyword">this</span>.databaseIdProvider.getDatabaseId(<span class="keyword">this</span>.dataSource));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">&quot;Failed getting a databaseId&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="keyword">this</span>.mapperLocations)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Resource mapperLocation : <span class="keyword">this</span>.mapperLocations) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mapperLocation == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    XMLMapperBuilder xmlMapperBuilder = <span class="keyword">new</span> XMLMapperBuilder(mapperLocation.getInputStream(),</span><br><span class="line">                            configuration, mapperLocation.toString(), configuration.getSqlFragments());</span><br><span class="line"></span><br><span class="line">                    xmlMapperBuilder.parse();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 修改处：ThinkGem MapperXML有错误的时候抛出并打印异常，否则系统会一直递归造成无法启动</span></span><br><span class="line">                    logger.error(<span class="string">&quot;Failed to parse mapping resource: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">&quot;Failed to parse mapping resource: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ErrorContext.instance().reset();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Parsed mapper file: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改处：ThinkGem 启动刷新MapperXML定时器（有助于开发者调试）。</span></span><br><span class="line">            <span class="keyword">new</span> MapperRefresh(<span class="keyword">this</span>.mapperLocations, configuration).run();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Property &#x27;mapperLocations&#x27; was not specified or no matching resources found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sqlSessionFactoryBuilder.build(configuration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            afterPropertiesSet();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? extends SqlSessionFactory&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sqlSessionFactory == <span class="keyword">null</span> ? SqlSessionFactory.class : <span class="keyword">this</span>.sqlSessionFactory.getClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>.failFast) &amp;&amp; ((event <span class="keyword">instanceof</span> ContextRefreshedEvent))) &#123;</span><br><span class="line">            <span class="keyword">this</span>.sqlSessionFactory.getConfiguration().getMappedStatementNames();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>接下来我们就需要把这个SqlSessionFactoryBean.java文件编译成class文件，然后再复制到mybatis-spring-1.2.2.jar包里面 。<strong>重新部署当前项目</strong> Servers &gt; Tomcat 8.x &gt; 右键你的项目 Remove deployment 然后再 Add Deployment…你的项目。</p>
</li>
<li><p>去Tomcat 8的根目录找到对应的SqlSessionFactoryBean.class文件复制出来。</p>
<div align=center><img width="700" height="300" src="../../../../images/2017-9-15/mybatis-mapper/sqlsessionfactory-class.jpg" algin="center"/>

</div></li>
<li><p>这里记得检查一下编译过的class文件是否正确，将你编译好的SqlSessionFactoryBean.class文件再次拖入，用<a href="http://pan.baidu.com/s/1skKW2st"><em>jd-gui.exe(一款JAVA反编译工具)</em></a>比较是不是和上面写的代码对应！！！！</p>
<p><strong>检查无误之后，把SqlSessionFactoryBean.class复制到mybatis-spring-1.2.2.jar(是你本地项目中的jar)包中，替换原来的class文件</strong>。</p>
<div align=center><img width="700" height="300" src="../../../../images/2017-9-15/mybatis-mapper/%E6%9B%BF%E6%8D%A2class%E6%96%87%E4%BB%B6.png" algin="center"/>

</div>



<h1 id="创建mybatis-refresh-properties文件"><a href="#创建mybatis-refresh-properties文件" class="headerlink" title="创建mybatis-refresh.properties文件"></a>创建mybatis-refresh.properties文件</h1><p>一切准备就绪，还剩下最后一个属性文件， 创建<strong>mybatis-refresh.properties</strong>文件，记得把文件格式改成<strong>UTF-8</strong>。</p>
<div align=center><img width="700" height="300" src="../../../../images/2017-9-15/mybatis-mapper/properties%E6%96%87%E4%BB%B6.png" algin="center"/>

</div>

<p><strong>mybatis-refresh.properties文件内容为：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#是否开启刷新线程</span><br><span class="line">enabled=<span class="literal">true</span></span><br><span class="line">#延迟启动刷新程序的秒数</span><br><span class="line">delaySeconds=<span class="number">60</span>  </span><br><span class="line">#刷新扫描间隔的时长秒数</span><br><span class="line">sleepSeconds=<span class="number">3</span></span><br><span class="line">#扫描Mapper文件的资源路径</span><br><span class="line">mappingPath=mapper</span><br></pre></td></tr></table></figure>

<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ol>
<li><p>删除org.mybatis.spring包及下面的SqlSessionFactoryBean.java文件。</p>
</li>
<li><p>启动项目，然后随便修改一个mapper.xml文件，然后稍等片刻，在控制台出现如下输出，就表示你成功啦！<strong>这样就不用重启项目，也能加载到你修改的mapper.xml文件了</strong> 。</p>
<div align=center><img width="700" height="300" src="../../../../images/2017-9-15/mybatis-mapper/success.png" algin="center"/>

</div></li>
</ol>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ol>
<li>注意各个文件的位置和名称。</li>
<li>注意<strong>MapperRefresh.java</strong>文件中<strong>mybatis-refresh.properties</strong>的路径。</li>
<li>注意用jd-gui.exe<strong>检查编译后的SqlSessionFactoryBean.class文件</strong>。</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tips</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置文件详解</title>
    <url>/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>之前介绍了Linux下安装Nginx，Nginx 专为性能优化而开发，性能是其最重要的考量,实现上非常注重效率 。它支持内核 Poll 模型，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数。<div align=center></p>
<p><img src="../../../../images/2018-01/nginx/index.png" algin="center"/></div></p>
<h1 id="Nginx特点"><a href="#Nginx特点" class="headerlink" title="Nginx特点"></a>Nginx特点</h1><p>Nginx 具有很高的稳定性。其它 HTTP 服务器，当遇到访问的峰值，或者有人恶意发起慢速连接时，也很可能会导致服务器物理内存耗尽频繁交换，失去响应，只能重启服务器。例如当前 apache 一旦上到 200 个以上进程，web响应速度就明显非常缓慢了。而 Nginx 采取了分阶段资源分配技术，使得它的 CPU 与内存占用率非常低。Nginx 官方表示保持 10,000 个没有活动的连接，它只占 2.5M 内存，所以类似 DOS 这样的攻击对 Nginx 来说基本上是毫无用处的。就稳定性而言，Nginx 比 lighthttpd 更胜一筹。</p>
<p>Nginx 支持热部署。启动特别容易，并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动。还能够在不间断服务的情况下，对软件版本进行进行升级。</p>
<h1 id="Nginx的用处"><a href="#Nginx的用处" class="headerlink" title="Nginx的用处"></a>Nginx的用处</h1><p>说了这么多Nginx的优点，Nginx在开发中最常用作反向代理服务器，但是Nginx的用处可不止这一点。</p>
<h2 id="Nginx配置虚拟主机"><a href="#Nginx配置虚拟主机" class="headerlink" title="Nginx配置虚拟主机"></a>Nginx配置虚拟主机</h2><p>虚拟主机是一种特殊的软硬件技术，它可以将网络上的每一台计算机分成多个虚拟主机，每个虚拟主机可以独立对外提供www服务，这样就可以实现一台主机对外提供多个web服务，每个虚拟主机之间是独立的，互不影响的。</p>
<div align=center><img src="../../../../images/2018-01/nginx/1.png" algin="center"/></div>

<p>1、 基于ip的虚拟主机</p>
<p>2、基于端口的虚拟主机</p>
<p>3、基于域名的虚拟主机</p>
<h2 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h2><p>通常的代理服务器，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器,并将本来要直接发送到Web服务器上的http请求发送到代理服务器中由代理服务器向Internet上的web服务器发起请求，最终达到客户机上网的目的。</p>
<p>​    而反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<div align=center><img src="../../../../images/2018-01/nginx/2.png" algin="center"/></div>

<h1 id="Nginx配置详解"><a href="#Nginx配置详解" class="headerlink" title="Nginx配置详解"></a>Nginx配置详解</h1><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用户</span></span><br><span class="line"><span class="attribute">user</span> nginx ;</span><br><span class="line"></span><br><span class="line"><span class="comment">#工作进程，根据硬件调整，大于等于cpu核数</span></span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#错误日志</span></span><br><span class="line"><span class="attribute">error_log</span> logs/nginx_error.log <span class="literal">crit</span>;</span><br><span class="line"><span class="comment">#pid放置的位置</span></span><br><span class="line"><span class="attribute">pid</span> logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定进程可以打开的最大描述符</span></span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">204800</span>;</span><br><span class="line">这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文</span><br><span class="line">件数（<span class="attribute">ulimit</span> -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。</span><br><span class="line">现在在linux <span class="number">2</span>.<span class="number">6</span>内核下开启文件打开数为<span class="number">65535</span>，worker_rlimit_nofile就相应应该填写<span class="number">65535</span>。</span><br><span class="line">这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写<span class="number">10240</span>，总并发量达到<span class="number">3</span>-<span class="number">4</span>万时就有进程可能超过<span class="number">10240</span>了，这时会返回<span class="number">502</span>错误。</span><br><span class="line"></span><br><span class="line">events</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">#使用epoll的I/O 模型</span></span><br><span class="line">	<span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line">    补充说明:</span><br><span class="line">    与apache相类，nginx针对不同的操作系统，有不同的事件模型</span><br><span class="line">    A）标准事件模型</span><br><span class="line">    Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或<span class="attribute">poll</span></span><br><span class="line">    B）高效事件模型</span><br><span class="line">    Kqueue：使用于FreeBSD <span class="number">4</span>.<span class="number">1</span>+, OpenBSD <span class="number">2</span>.<span class="number">9</span>+, NetBSD <span class="number">2</span>.<span class="number">0</span> 和 MacOS X.使用双处理器的MacOS X系统使用<span class="literal">kqueue</span>可能会造成内核崩溃。</span><br><span class="line">    E<span class="literal">poll</span>:使用于Linux内核<span class="number">2</span>.<span class="number">6</span>版本及以后的系统。</span><br><span class="line">    <span class="literal">/dev/poll</span>：使用于Solaris <span class="number">7</span> <span class="number">11</span>/<span class="number">99</span>+, HP/UX <span class="number">11</span>.<span class="number">22</span>+ (eventport), IRIX <span class="number">6</span>.<span class="number">5</span>.<span class="number">15</span>+ 和 Tru64 UNIX <span class="number">5</span>.1A+。</span><br><span class="line">    Eventport：使用于Solaris <span class="number">10</span>. 为了防止出现内核崩溃的问题， 有必要安装安全补丁</span><br><span class="line"></span><br><span class="line">    <span class="comment">#工作进程的最大连接数量，根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行</span></span><br><span class="line">	worker_connections <span class="number">204800</span>;</span><br><span class="line">	每个进程允许的最多连接数， 理论上每台nginx服务器的最大连接数为worker_processes*<span class="attribute">worker_connections</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">#keepalive超时时间。</span></span><br><span class="line">	keepalive_timeout <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">#这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</span></span><br><span class="line">	<span class="attribute">open_file_cache</span> max=<span class="number">65535</span> inactive=<span class="number">60s</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">#这个是指多长时间检查一次缓存的有效信息。</span></span><br><span class="line">	<span class="attribute">open_file_cache_valid</span> <span class="number">80s</span>;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">#open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。</span></span><br><span class="line">	<span class="attribute">open_file_cache_min_uses</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span></span><br><span class="line"><span class="section">http</span></span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">#设定mime类型,类型由mime.type文件定义</span></span><br><span class="line">	<span class="attribute">include</span> mime.types;</span><br><span class="line">	<span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">log_format</span> main <span class="string">&#x27;$host $status [$time_local] $remote_addr [$time_local] $request_uri &#x27;</span></span><br><span class="line"><span class="string">&#x27;&quot;$http_referer&quot; &quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &#x27;</span><span class="string">&#x27;$bytes_sent $request_time $sent_http_x_cache_hit&#x27;</span>;</span><br><span class="line"><span class="attribute">log_format</span> log404 <span class="string">&#x27;$status [$time_local] $remote_addr $host$request_uri $sent_http_location&#x27;</span>;</span><br><span class="line"></span><br><span class="line">$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；</span><br><span class="line">$remote_user：用来记录客户端用户名称；</span><br><span class="line">$time_local： 用来记录访问时间与时区；</span><br><span class="line">$request： 用来记录请求的url与http协议；</span><br><span class="line">$status： 用来记录请求状态；成功是200，</span><br><span class="line">$<span class="attribute">body_bytes_s</span> ent ：记录发送给客户端文件主体内容大小；</span><br><span class="line">$http_referer：用来记录从那个页面链接访问过来的；</span><br><span class="line">$http_user_agent：记录客户毒啊浏览器的相关信息；</span><br><span class="line">通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址；</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 用了log_format指令设置了日志格式之后，需要用access_log指令指定日志文件的存放路径；</span></span><br><span class="line">  <span class="comment"># access_log /usr/local/nginx/logs/access_log main;</span></span><br><span class="line">	access_log /dev/null;</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">#保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.</span></span><br><span class="line">	<span class="attribute">server_names_hash_bucket_size</span> <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">#客户端请求头部的缓冲区大小，这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。</span></span><br><span class="line">	<span class="attribute">client_header_buffer_size</span> <span class="number">128k</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">#客户请求头缓冲大小</span></span><br><span class="line">  n<span class="comment">#ginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取如果设置过小HTTP头/Cookie过大 会报400 错误nginx 400 bad request求行如果超过buffer，就会报HTTP 414错误(URI Too Long)nginx接受最长的HTTP头部大小必须比其中一个buffer大，否则就会报400的</span></span><br><span class="line">	<span class="attribute">large_client_header_buffers</span> <span class="number">8</span> <span class="number">128k</span>;</span><br><span class="line"></span><br><span class="line">HTTP错误(<span class="attribute">Bad</span> Request)。</span><br><span class="line"><span class="comment">#使用字段:http, server, location 这个指令指定缓存是否启用,如果启用,将记录文件以下信息: ·打开的文件描述符,大小信息和修改时间. ·存在的目录信息. ·在搜索文件过程中的错误信息 --没有这个文件,无法正确读取,参考open_file_cache_errors指令选项:·max -指定缓存的最大数目,如果缓存溢出,最长使用过的文件(LRU)将被移除</span></span><br><span class="line"><span class="comment">#例: open_file_cache max=1000 inactive=20s; open_file_cache_valid 30s; open_file_cache_min_uses 2; open_file_cache_errors on;</span></span><br><span class="line">	open_file_cache max <span class="number">102400</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">#语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.</span></span><br><span class="line">	open_file_cache_errors</span><br><span class="line"></span><br><span class="line">	<span class="comment">#语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location 这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如 果使用更大的值,文件描述符在cache中总是打开状态.</span></span><br><span class="line">	open_file_cache_min_uses</span><br><span class="line">	</span><br><span class="line">    <span class="comment">#语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.</span></span><br><span class="line">	open_file_cache_valid</span><br><span class="line">    </span><br><span class="line">	<span class="comment">#设定通过nginx上传文件的大小</span></span><br><span class="line">	client_max_body_size <span class="number">300m</span>;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">#sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，</span></span><br><span class="line">	<span class="comment">#对于普通应用，必须设为on。</span></span><br><span class="line">	<span class="comment">#如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。</span></span><br><span class="line">	<span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">#此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用</span></span><br><span class="line">	<span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line">  </span><br><span class="line">	<span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br><span class="line">  	</span><br><span class="line">	<span class="comment">#后端服务器连接的超时时间_发起握手等候响应超时时间</span></span><br><span class="line">	<span class="attribute">proxy_connect_timeout</span> <span class="number">90</span>; </span><br><span class="line">	</span><br><span class="line">  <span class="comment">#连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）</span></span><br><span class="line">	<span class="attribute">proxy_read_timeout</span> <span class="number">180</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">#后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据</span></span><br><span class="line">	<span class="attribute">proxy_send_timeout</span> <span class="number">180</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">#设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小</span></span><br><span class="line">	<span class="attribute">proxy_buffer_size</span> <span class="number">256k</span>;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">#设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k</span></span><br><span class="line">	<span class="attribute">proxy_buffers</span> <span class="number">8</span> <span class="number">256k</span>;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">proxy_busy_buffers_size</span> <span class="number">256k</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">#设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长</span></span><br><span class="line">	<span class="attribute">proxy_temp_file_write_size</span> <span class="number">256k</span>;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">#proxy_temp_path和proxy_cache_path指定的路径必须在同一分区</span></span><br><span class="line">	<span class="attribute">proxy_temp_path</span> /data0/proxy_temp_dir;</span><br><span class="line">	<span class="comment">#设置内存缓存空间大小为200MB，1天没有被访问的内容自动清除，硬盘缓存空间大小为30GB。</span></span><br><span class="line">	<span class="attribute">proxy_cache_path</span> /data0/proxy_cache_dir levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=cache_one:<span class="number">200m</span> inactive=<span class="number">1d</span> max_size=<span class="number">30g</span>;</span><br><span class="line">	</span><br><span class="line">  <span class="attribute">client_header_timeout</span> <span class="number">5</span>;</span><br><span class="line">  <span class="attribute">client_body_timeout</span> <span class="number">5</span>;</span><br><span class="line">  <span class="attribute">send_timeout</span> <span class="number">5</span>;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">#keepalive超时时间。</span></span><br><span class="line">	<span class="attribute">keepalive_timeout</span> <span class="number">120</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">#如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。</span></span><br><span class="line"><span class="comment">#无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误</span></span><br><span class="line">	<span class="attribute">client_body_buffer_size</span> <span class="number">512k</span>;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">#表示使nginx阻止HTTP应答代码为400或者更高的应答。</span></span><br><span class="line">	<span class="attribute">proxy_intercept_errors</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">  	 <span class="comment">#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。</span></span><br><span class="line">    <span class="attribute">fastcgi_connect_timeout</span> <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">fastcgi_send_timeout</span> <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">fastcgi_read_timeout</span> <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">fastcgi_buffer_size</span> <span class="number">64k</span>;</span><br><span class="line">    <span class="attribute">fastcgi_buffers</span> <span class="number">4</span> <span class="number">64k</span>;</span><br><span class="line">    <span class="attribute">fastcgi_busy_buffers_size</span> <span class="number">128k</span>;</span><br><span class="line">    <span class="attribute">fastcgi_temp_file_write_size</span> <span class="number">128k</span>;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">#gzip模块设置</span></span><br><span class="line">    <span class="attribute">gzip</span> <span class="literal">on</span>; <span class="comment">#开启gzip压缩输出</span></span><br><span class="line">    <span class="attribute">gzip_min_length</span> <span class="number">1k</span>;    <span class="comment">#最小压缩文件大小</span></span><br><span class="line">    <span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">16k</span>;    <span class="comment">#压缩缓冲区</span></span><br><span class="line">    <span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">0</span>;    <span class="comment">#压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span></span><br><span class="line">    <span class="attribute">gzip_comp_level</span> <span class="number">2</span>;    <span class="comment">#压缩等级</span></span><br><span class="line">    <span class="attribute">gzip_types</span> text/plain application/x-javascript text/css application/xml;    <span class="comment">#压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span></span><br><span class="line">    <span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">#开启限制IP连接数的时候需要使用</span></span><br><span class="line">    <span class="comment">#limit_zone crawler $binary_remote_addr 10m;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">upstream</span> img_relay &#123;</span><br><span class="line">       <span class="attribute">server</span> <span class="number">127.0.0.1:8027</span>;</span><br><span class="line">       <span class="attribute">server</span> <span class="number">127.0.0.1:8028</span>;</span><br><span class="line">       <span class="attribute">server</span> <span class="number">127.0.0.1:8029</span>;</span><br><span class="line">       <span class="attribute">hash</span> $request_uri;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"> 	<span class="comment">#如果请求为img_relay:80,则交给名称为img_relay的Nginx集群来处理</span></span><br><span class="line">	server&#123;</span><br><span class="line">         <span class="attribute">listen</span>  <span class="number">80</span>;</span><br><span class="line">         <span class="attribute">server_name</span>  img_relay;</span><br><span class="line"><span class="comment">#		 limit_req   zone=req_one  burst=5 nodelay;</span></span><br><span class="line"></span><br><span class="line">		  <span class="attribute">location</span> <span class="regexp">~ .*.jsp$</span>  &#123;</span><br><span class="line">				   <span class="attribute">proxy_ignore_client_abort</span>   <span class="literal">on</span>;</span><br><span class="line">				   <span class="attribute">proxy_pass</span>		http://img_relay;	<span class="comment">#http:// + upstream名称</span></span><br><span class="line">				   <span class="attribute">proxy_set_header</span>   Host             $host;</span><br><span class="line">				   <span class="attribute">proxy_set_header</span>   X-Real-IP        $remote_addr;</span><br><span class="line">				   <span class="attribute">proxy_set_header</span>   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">				   <span class="attribute">proxy_connect_timeout</span>       <span class="number">60</span>; 	 <span class="comment">#nginx跟后端服务器连接超时时间(代理连接超时)</span></span><br><span class="line">				   <span class="attribute">proxy_read_timeout</span>          <span class="number">600</span>;  <span class="comment">#连接成功后，后端服务器响应时间(代理接收超时)</span></span><br><span class="line">				   <span class="attribute">proxy_send_timeout</span>          <span class="number">60</span>;	 <span class="comment">#后端服务器数据回传时间(代理发送超时)</span></span><br><span class="line">				   <span class="attribute">proxy_buffer_size</span> <span class="number">128k</span>;          <span class="comment">#设置代理服务器（nginx）保存用户头信息的缓冲区大小</span></span><br><span class="line">				   <span class="attribute">proxy_buffers</span>   <span class="number">32</span> <span class="number">128k</span>;           <span class="comment">#proxy_buffers缓冲区，网页平均在32k以下的话，这样设置</span></span><br><span class="line">				   <span class="attribute">proxy_busy_buffers_size</span> <span class="number">128k</span>;   <span class="comment">#高负荷下缓冲大小（proxy_buffers*2）</span></span><br><span class="line">		  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nginx的upstream目前支持4种方式的分配</span><br><span class="line">1、轮询（默认）</span><br><span class="line">每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</span><br><span class="line">    </span><br><span class="line">2、<span class="attribute">weight</span></span><br><span class="line">指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</span><br><span class="line">例如：</span><br><span class="line">upstream bakend &#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.0.14</span> weight=<span class="number">10</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.0.15</span> weight=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3、<span class="attribute">ip_hash</span></span><br><span class="line">每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</span><br><span class="line">例如：</span><br><span class="line">upstream bakend &#123;</span><br><span class="line">	ip_hash;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.0.14:88</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.0.15:80</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4、fair（第三方）</span><br><span class="line">按后端服务器的响应时间来分配请求，响应时间短的优先分配。</span><br><span class="line"><span class="attribute">upstream</span> backend &#123;</span><br><span class="line">	<span class="attribute">server</span> server1;</span><br><span class="line">	<span class="attribute">server</span> server2;</span><br><span class="line">	fair;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">5、url_hash（第三方）</span><br><span class="line">按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</span><br><span class="line"><span class="attribute">upstream</span> backend &#123;</span><br><span class="line">	<span class="attribute">server</span> squid1:<span class="number">3128</span>;</span><br><span class="line">	<span class="attribute">server</span> squid2:<span class="number">3128</span>;</span><br><span class="line">	<span class="attribute">hash</span> $request_uri;</span><br><span class="line">	<span class="attribute">hash_method</span> crc32;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tips:</span><br><span class="line"><span class="attribute">upstream</span> bakend&#123;<span class="comment">#定义负载均衡设备的Ip及设备状态</span></span><br><span class="line">    ip_hash;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:9090</span> down;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span> weight=<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:6060</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:7070</span> backup;</span><br><span class="line">&#125;</span><br><span class="line">在需要使用负载均衡的server中增加</span><br><span class="line"><span class="attribute">proxy_pass</span> http://bakend/;</span><br><span class="line"></span><br><span class="line">每个设备的状态设置为:</span><br><span class="line">1.down表示单前的server暂时不参与负载</span><br><span class="line">2.weight默认为1.weight越大，负载的权重就越大。</span><br><span class="line">3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误</span><br><span class="line">4.fail_timeout:max_fails次失败后，暂停的时间。</span><br><span class="line">5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</span><br><span class="line"></span><br><span class="line">nginx支持同时设置多组的负载均衡，用来给不用的server来使用。</span><br><span class="line"></span><br><span class="line">client_body_in_file_only设置为<span class="attribute">On</span> 可以讲client post过来的数据记录到文件中用来做<span class="literal">debug</span></span><br><span class="line">client_body_temp_path设置记录文件的目录 可以设置最多<span class="number">3</span>层目录</span><br><span class="line"></span><br><span class="line">location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring之循环依赖</title>
    <url>/Spring%E4%B9%8B%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在Spring框架中，针对Bean之间的循环依赖，Spring通过<strong>三级缓存</strong>的机制已经解决和规避了部分场景Bean的循环依赖。但是仍需了解Spring解决循环依赖的原理和注意Spring无法解决循环依赖的场景，避免出现此类问题。<div align=center><img src="../../../../images/2020/5-8/spring-dependency1.jpg" algin="center"/></div><span id="more"></span></p>
<h1 id="循环依赖示例"><a href="#循环依赖示例" class="headerlink" title="循环依赖示例"></a>循环依赖示例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServiceImpl</span> <span class="keyword">implements</span> <span class="title">AService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BService bService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BServiceImpl</span> <span class="keyword">implements</span> <span class="title">BService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AService aService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子是非常经典的Spring Bean循环依赖的场景，在这种循环依赖场景，Spring已经帮我们解决了循环依赖的问题，所以服务可以正常启动和运行。</p>
<h1 id="Spring循环依赖的场景"><a href="#Spring循环依赖的场景" class="headerlink" title="Spring循环依赖的场景"></a>Spring循环依赖的场景</h1><h2 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServiceImpl</span> <span class="keyword">implements</span> <span class="title">AService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BService bService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AServiceImpl</span><span class="params">(BService bService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bService = bService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BServiceImpl</span> <span class="keyword">implements</span> <span class="title">BService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AService aService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BServiceImpl</span><span class="params">(AService aService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.aService = aService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：项目启动失败并抛出<code>BeanCurrentlyInCreationException</code>异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name <span class="string">&#x27;AServiceImpl&#x27;</span>: Requested bean is currently in creation: Is there an unresolvable circular reference?</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.beforeSingletonCreation(DefaultSingletonBeanRegistry.java:<span class="number">347</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:<span class="number">223</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:<span class="number">308</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:<span class="number">202</span>)</span><br></pre></td></tr></table></figure>

<p><strong>构造器注入无法解决循环依赖问题</strong>，Spring只能抛出<code>BeanCurrentlyInCreationException</code>依赖表示循环依赖。</p>
<blockquote>
<p>Spring解决循环依赖是依靠Bean的“中间态“的概念，”中间态“是指Bean已经实例化，但还没有初始化的状态，而构造器注入的是初始化后的对象，所以不能解决循环依赖。</p>
<p>Spring解决循环依赖的理论依据基于Java的引用传递，当获得对象的引用时，对象的属性是可以延后设置的。但是构造器必须是在获取引用之前，毕竟引用是靠构造器生成的。</p>
</blockquote>
<h2 id="注解注入-field属性注入"><a href="#注解注入-field属性注入" class="headerlink" title="注解注入(field属性注入)"></a>注解注入(field属性注入)</h2><p>这个是最常见的注入方式，通过<code>@Autowired</code>或<code>@Resource</code>注入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServiceImpl</span> <span class="keyword">implements</span> <span class="title">AService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BService bService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BServiceImpl</span> <span class="keyword">implements</span> <span class="title">BService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AService aService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>项目可以正常启动，说明循环依赖被解决。</p>
<h2 id="prototype-field属性注入"><a href="#prototype-field属性注入" class="headerlink" title="prototype field属性注入"></a><code>prototype</code> field属性注入</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServiceImpl</span> <span class="keyword">implements</span> <span class="title">AService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BService bService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BServiceImpl</span> <span class="keyword">implements</span> <span class="title">BService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AService aService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动没有报错，因为非单例的Bean默认不会初始化，只有在第一次使用时才会初始化。需要手动调用<code>getBean()</code>或者在一个单例Bean内<code>@Autowired</code>就可以触发初始化。此时同样会抛出异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="string">&#x27;AServiceImpl&#x27;</span>: Unsatisfied dependency expressed through field <span class="string">&#x27;bService&#x27;</span>; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="string">&#x27;BServiceImpl&#x27;</span>: Unsatisfied dependency expressed through field <span class="string">&#x27;aService&#x27;</span>; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name <span class="string">&#x27;AServiceImpl&#x27;</span>: Requested bean is currently in creation: Is there an unresolvable circular reference?</span><br><span class="line">	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:<span class="number">586</span>)</span><br><span class="line">	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:<span class="number">87</span>)</span><br><span class="line">	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:<span class="number">364</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:<span class="number">1269</span>)</span><br></pre></td></tr></table></figure>

<p>对于<code>prototype</code>作用域的bean, Spring容器无法完成依赖注入，因为Spring 容器不进行缓存<code>prototype</code>作用域的bean ，因此无法提前暴露一个创建中的bean。</p>
<p>网上有的说法是使用<code>@Lazy</code>注解解决。这样做启动确实不报错了，但是实际这样是解决不了问题的，<code>@Lazy</code>只是延迟初始化，当真正使用到的时候还是会报异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">private</span> AService aService;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="可解决循环依赖场景"><a href="#可解决循环依赖场景" class="headerlink" title="可解决循环依赖场景"></a>可解决循环依赖场景</h3><ol>
<li>注解注入(field属性)注入循环依赖</li>
<li>setter注入</li>
</ol>
<h3 id="无法解决循环依赖场景"><a href="#无法解决循环依赖场景" class="headerlink" title="无法解决循环依赖场景"></a>无法解决循环依赖场景</h3><ol>
<li>构造器注入循环依赖</li>
<li><code>prototype</code> field属性注入循环依赖</li>
</ol>
<h1 id="Spring解决循环依赖原理"><a href="#Spring解决循环依赖原理" class="headerlink" title="Spring解决循环依赖原理"></a>Spring解决循环依赖原理</h1><p>Spring创建单例Bean流程可以简化如下图：</p>
<div align=center><img width="800" height="200" src="../../../../images/2020/5-8/spring-dependency2.jpg" algin="center"/></div>

<p>其中比较核心的方法为：</p>
<ul>
<li><strong>createBeanInstance</strong>：实例化，其实是调用对象的构造方法实例化对象。</li>
<li><strong>populateBean</strong>：填充Bean属性，主要对Bean的依赖属性进行注入(<code>@Autowired</code>、<code>@Resource</code>)</li>
</ul>
<p>其中Spring解决循环依赖主要发生在<code>populateBean</code>这一步。</p>
<h2 id="Spring容器的”三级缓存“"><a href="#Spring容器的”三级缓存“" class="headerlink" title="Spring容器的”三级缓存“"></a>Spring容器的”三级缓存“</h2><p>在Spring容器中大量使用了缓存来加速访问，其中单例Bean也利用了这种手段。其中Spring采用了”三级缓存“来解决循环依赖问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 一级缓存 */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cache of singleton objects: bean name --&gt; bean instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">256</span>);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 二级缓存 */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cache of early singleton objects: bean name --&gt; bean instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 三级缓存 */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cache of singleton factories: bean name --&gt; ObjectFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 正在创建中的Bean。Bean开始创建时存入,创建完成时移除。 */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Names of beans that are currently in creation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation =</span><br><span class="line">            Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;String, Boolean&gt;(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 创建完成的Bean集合 */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set of registered singletons, containing the bean names in registration order</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; registeredSingletons = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(<span class="number">256</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractBeanFactory</code>继承自<code>DefaultSingletonBeanRegistry</code></p>
<ol>
<li><code>singletonObjects(一级缓存)</code>：存放完全初始化好的Bean，从该缓存中取出的bean可以直接使用。</li>
<li><code>earlySingletonObjects(二级缓存)</code>：提前曝光的单例对象的cache，存放原始的Bean对象(已实例化，尚未初始化)，用于解决循环依赖。</li>
<li><code>singletonFactories(三级缓存)</code>：单例对象工厂的cache，存放Bean工厂对象，用于解决循环依赖。</li>
</ol>
<h2 id="获取单例Bean的流程"><a href="#获取单例Bean的流程" class="headerlink" title="获取单例Bean的流程"></a>获取单例Bean的流程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.从一级缓存singletonObjects中去获取(如果获取到就直接return)</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 2.如果获取不到或者对象正在创建中(isSingletonCurrentlyInCreation(),</span></span><br><span class="line"><span class="comment">     * 那就再从二级缓存earlySingletonObjects中获取(如果获取到就直接return）</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 3.如果还是获取不到,且允许singletonFactories(allowEarlyReference=true)通过getObject()获取。</span></span><br><span class="line"><span class="comment">     * 就从三级缓存singletonFactory.getObject()获取。如果获取到了就从singletonFactories中移除，并且放进earlySingletonObjects。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="comment">// 检查一级缓存中是否存在实例。isSingletonCurrentlyInCreation判断该实例是否在创建中</span></span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="comment">// 如果缓存中实例为null，则锁定全局变量singletonObjects并进行处理</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">                <span class="comment">// 尝试从二级缓存earlySingletonObjects(创建中提早曝光的beanFactory) 获取bean</span></span><br><span class="line">                singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                    <span class="comment">// 尝试从三级缓存singletonFactories获取beanFactory</span></span><br><span class="line">                    ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 返回获取到的bean</span></span><br><span class="line">                        singletonObject = singletonFactory.getObject();</span><br><span class="line">                        <span class="comment">// 增加二级缓存</span></span><br><span class="line">                        <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                        <span class="comment">// 删除三级缓存</span></span><br><span class="line">                        <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bean是否正在创建中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingletonCurrentlyInCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.singletonsCurrentlyInCreation.contains(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring利用<code>singletonFactories</code>这个三级缓存将创建对象的步骤封装到<code>ObjectFactory</code>中，交给自定义的<code>Scope</code>来选择是否需要创建对象来灵活的实现<code>scope</code>。 <strong>经过<code>ObjectFactory.getObject()</code>后，此时放进了二级缓存<code>earlySingletonObjects</code>内。这个时候对象已经实例化了，虽然还没有初始化完成，但该对象已经可以被其它对象引用了。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加锁，全局变量需要同步</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 查看单例bean是否已经创建</span></span><br><span class="line">            Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 调用getObject方法创建bean实例</span></span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                newSingleton = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                    addSingleton(beanName, singletonObject);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> singletonObject;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 添加一级缓存</span></span><br><span class="line">            <span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">            <span class="comment">// 移除二三级缓存</span></span><br><span class="line">            <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">            <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建Bean可以简单分为三个流程：</p>
<ol>
<li>创建原始<code>bean</code>实例 → <code>createBeanInstance(beanName, mbd, args)</code></li>
<li>添加原始对象工厂对象到 <code>singletonFactories</code> 缓存中 → <code>addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;&#123;...&#125;)</code></li>
<li> 填充属性，解析依赖 → <code>populateBean(beanName, mbd, instanceWrapper)</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">implements</span> <span class="title">AutowireCapableBeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Instantiate the bean.</span></span><br><span class="line">        BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 创建bean对象，并将bean对象包裹在 eanWrapper对象中返回</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否需要提前暴露。单例&amp;允许循环依赖&amp;当前bean正在创建中。</span></span><br><span class="line">        <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">            <span class="comment">// 在bean未实例化之前加入到三级缓存singletonFactories中</span></span><br><span class="line">            addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object exposedObject = bean;</span><br><span class="line">        <span class="comment">// 对bean进行填充，属性注入，bean依赖</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 调用相关初始化方法</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> exposedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 将singletonFactory添加到singletonFactories缓存中</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">                <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">                <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>Spring通过三级缓存可以解决部分场景下Bean循环依赖的问题，但是不能解决 1)构造器注入; 2)非单例Bean的循环依赖的问题。</p>
<p>Spring解决循环依赖的流程可以简化如下图所示：</p>
<div align=center><img src="../../../../images/2020/5-8/spring-dependency3.jpg" algin="center"/></div>

<p>以A、B类使用注解注入为例，对整个流程描述如下：</p>
<ol>
<li>获取A：调用<code>getBean(beanA)</code>，获取容器内的单例A对象，但此时容器内不存在A的实例，即走创建A的流程。</li>
<li>实例化A(<code>createBeanInstance</code>)：此处仅仅是实例化，并将A放入三级缓存<code>singletonFactories</code>中(此时A已实例化完成，可以被引用)。</li>
<li>初始化A(<code>populateBean</code>)：<code>@Autowired</code>依赖注入B(需要到容器内获取B)。</li>
<li>获取B：为了完成依赖注入B，会通过<code>getBean(B)</code>去容器内寻找B。但此时B在容器内不存在，即走B的创建流程。</li>
<li>实例化B(<code>createBeanInstance</code>)：并将其放入三级缓存<code>singletonFactories</code>中(此时B也能够被引用)。</li>
<li>初始化B(<code>populateBean</code>)：<code>@Autowired</code>依赖注入A(此时需要去容器内获取A)</li>
<li><strong>重要流程</strong>：初始化B时会调用<code>getBean(A)</code>去容器内寻找A，而此时候A已经实例化完成了并且在三级缓存中，此时可以通过A的<code>ObjectFactory</code> Bean工厂创建A对象，所以<code>getBean(A)</code>能够正常返回。</li>
<li>B初始化成功：此时B已经注入A成功，已成功持有A的引用了。return(此处return相当于返回最上面的<code>getBean(B)</code>这句代码，回到了初始化A的流程中)。</li>
<li>A初始化成功：因为B实例已经成功返回了，因此最终A也初始化成功。</li>
<li>结束：此时，B持有的已经是初始化完成的A，A持有的也是初始化完成的B。</li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat入门</title>
    <url>/tomcat%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器。说是经常用到，也只是熟悉，还没没有真正达到了解其中的原理和其中配置的意义，最近也找了一些书籍来看，先入门。<div align=center><img width="600" height="200" src="../../../../images/2017-12-27/tomcat%E5%85%A5%E9%97%A8/tomcat.jpg"/></div><span id="more"></span></p>
<h1 id="Tomcat简介"><a href="#Tomcat简介" class="headerlink" title="Tomcat简介"></a>Tomcat简介</h1><p>Tomcat的下载包解压之后的目录</p>
<div align=center><img width="600" height="200" src="../../../../images/2017-12-27/tomcat%E5%85%A5%E9%97%A8/tomcat%E7%9B%AE%E5%BD%95.jpg"/>

</div>

<p>Tomcat根目录在Tomcat中叫<code>&lt;CATALINA_HOME&gt;</code></p>
<p><strong><code>&lt;CATALINA_HOME&gt;</code>/bin：</strong>存放各种平台下启动和关闭Tomcat的脚本文件。其中有个是catalina.bat，打开这个windows配置文件，在非注释行加入JDK路径,例如 : SET  JAVA_HOME=C:\Program Files\Java\jdk1.8.0_141，其中对JDK的优化也在catalina.bat中配置，保存后就配置好Tomcat环境了。 startup.bat是windows下启动Tomcat的脚本文件，shutdown.bat是关闭Tomcat的脚本文件。</p>
<p><strong><code>&lt;CATALINA_HOME&gt;</code>/conf</strong>：<em>存放不同的配置文件（如：server.xml和web.xml）</em></p>
<p>　　server.xml文件：该文件用于配置和server相关的信息，比如tomcat启动的端口号、配置host主机、配置Context，接下来会重点讲述。</p>
<p>　　web.xml文件：部署描述文件，这个web.xml中描述了一些默认的servlet，部署每个webapp时，都会调用这个文件，配置该web应用的默认servlet。</p>
<p>　　tomcat-users.xml文件：配置tomcat的用户密码与权限。</p>
<p>　　context.xml：定义web应用的默认行为。<br><strong><code>&lt;CATALINA_HOME&gt;</code>/lib：</strong>存放Tomcat运行需要的库文件（Jars）；<br><strong><code>&lt;CATALINA_HOME&gt;</code>/logs：</strong>存放Tomcat执行时的log文件；<br><strong><code>&lt;CATALINA_HOME&gt;</code>/temp：</strong> 存放Tomcat运行时产生的文件，如缓存等；<br><strong><code>&lt;CATALINA_HOME&gt;</code>/webapps：</strong>Tomcat的主要Web发布目录（包括应用程序示例）；</p>
<p><strong><code>&lt;CATALINA_HOME&gt;</code>/work</strong>：存放jsp编译后产生的class文件； </p>
<p><strong>【Tomcat的启动过程】</strong>Tomcat 先根据**/conf/server.xml** 下的配置启动Server，再加载Service，对于与Engine相匹配的Host，每个Host 下面都有一个或多个Context。</p>
<p>　　注意：Context 既可配置在server.xml 下，也可配置成一单独的文件，放在conf\Catalina\localhost 下，简称应用配置文件。</p>
<p>　　Web Application 对应一个Context，每个Web Application 由一个或多个Servlet 组成。当一个Web Application 被初始化的时候，它将用自己的ClassLoader 对象载入部署配置文件web.xml 中定义的每个Servlet 类：它首先载入在$CATALINA_HOME/conf/web.xml中部署的Servlet 类，然后载入在自己的Web Application 根目录下WEB-INF/web.xml 中部署的Servlet 类。</p>
<p>web.xml 文件有两部分：Servlet 类定义和Servlet 映射定义。每个被载入的Servlet 类都有一个名字，且被填入该Context 的映射表(mapping table)中，和某种URL 路径对应。当该Context 获得请求时，将查询mapping table，找到被请求的Servlet，并执行以获得请求响应。</p>
<h1 id="Tomcat一个server实例"><a href="#Tomcat一个server实例" class="headerlink" title="Tomcat一个server实例"></a>Tomcat一个server实例</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">&quot;8005&quot;</span> <span class="attr">shutdown</span>=<span class="string">&quot;SHUTDOWN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.startup.VersionLoggerListener&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.AprLifecycleListener&quot;</span> <span class="attr">SSLEngine</span>=<span class="string">&quot;on&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.JasperListener&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">&quot;UserDatabase&quot;</span> <span class="attr">auth</span>=<span class="string">&quot;Container&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">&quot;org.apache.catalina.UserDatabase&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">description</span>=<span class="string">&quot;User database that can be updated and saved&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">factory</span>=<span class="string">&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">pathname</span>=<span class="string">&quot;conf/tomcat-users.xml&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8009&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;AJP/1.3&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span> <span class="attr">defaultHost</span>=<span class="string">&quot;localhost&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.realm.LockOutRealm&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">resourceName</span>=<span class="string">&quot;UserDatabase&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;localhost&quot;</span>  <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.valves.AccessLogValve&quot;</span> <span class="attr">directory</span>=<span class="string">&quot;logs&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">prefix</span>=<span class="string">&quot;localhost_access_log.&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;.txt&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">pattern</span>=<span class="string">&quot;%h %l %u %t <span class="symbol">&amp;quot;</span>%r<span class="symbol">&amp;quot;</span> %s %b&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="server-xml文档的元素分类和整体结构"><a href="#server-xml文档的元素分类和整体结构" class="headerlink" title="server.xml文档的元素分类和整体结构"></a>server.xml文档的元素分类和整体结构</h1><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p>server.xml的整体结构如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Service</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Connector</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Connector</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Engine</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Host</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Context</span>/&gt;</span><span class="comment">&lt;!-- 现在常常使用自动部署，不推荐配置Context元素，Context小节有详细说明 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>该结构中只给出了Tomcat的核心组件，除了核心组件外，Tomcat还有一些其他组件，下面介绍一下组件的分类。</p>
<h3 id="元素分类"><a href="#元素分类" class="headerlink" title="元素分类"></a>元素分类</h3><p>server.xml文件中的元素可以分为以下4类：</p>
<p>（1）顶层元素：<code>&lt;Server&gt;</code>和<code>&lt;Service&gt;</code></p>
<p><code>&lt;Server&gt;</code>元素是整个配置文件的根元素，<code>&lt;Service&gt;</code>元素则代表一个Engine元素以及一组与之相连的Connector元素。</p>
<p>（2）连接器：<code>&lt;Connector&gt;</code></p>
<p><code>&lt;Connector&gt;</code>代表了外部客户端发送请求到特定Service的接口；同时也是外部客户端从特定Service接收响应的接口。</p>
<p>（3）容器：<code>&lt;Engine&gt;&lt;Host&gt;&lt;Context&gt;</code></p>
<p>容器的功能是处理Connector接收进来的请求，并产生相应的响应。Engine、Host和Context都是容器，但它们不是平行的关系，而是父子关系：Engine包含Host，Host包含Context。一个Engine组件可以处理Service中的所有请求，一个Host组件可以处理发向一个特定虚拟主机的所有请求，一个Context组件可以处理一个特定Web应用的所有请求。</p>
<p>（4）内嵌组件：可以内嵌到容器中的组件。实际上，Server、Service、Connector、Engine、Host和Context是最重要的最核心的Tomcat组件，其他组件都可以归为内嵌组件。</p>
<h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><p><strong>1、Server</strong></p>
<p>Server元素在最顶层，代表整个Tomcat容器，因此它必须是server.xml中唯一一个最外层的元素。一个Server元素中可以有一个或多个Service元素。</p>
<p>在第一部分的例子中，在最外层有一个<code>&lt;Server&gt;</code>元素，shutdown属性表示关闭Server的指令；port属性表示Server接收shutdown指令的端口号，设为-1可以禁掉该端口。</p>
<p>Server的主要任务，就是提供一个接口让客户端能够访问到这个Service集合，同时维护它所包含的所有的Service的声明周期，包括如何初始化、如何结束服务、如何找到客户端要访问的Service。</p>
<p><strong>2、Service</strong></p>
<p>Service的作用，是在Connector和Engine外面包了一层，把它们组装在一起，对外提供服务。一个Service可以包含多个Connector，但是只能包含一个Engine；其中Connector的作用是从客户端接收请求，Engine的作用是处理接收进来的请求。</p>
<p>在第一部分的例子中，Server中包含一个名称为“Catalina”的Service。实际上，Tomcat可以提供多个Service，不同的Service监听不同的端口。</p>
<p><strong>3、Connector</strong></p>
<p>Connector的主要功能，是接收连接请求，<strong>创建Request和Response对象用于和请求端交换数据</strong>；然后分配线程让Engine来处理这个请求，并把产生的Request和Response对象传给Engine。</p>
<p>通过配置Connector，可以控制请求Service的协议及端口号。在第一部分的例子中，Service包含两个Connector：</p>
<blockquote>
<p><code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;</code></p>
<p><code>&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</code></p>
</blockquote>
<p>（1）通过配置第1个Connector，客户端可以通过8080端口号使用http协议访问Tomcat。其中，protocol属性规定了请求的协议，port规定了请求的端口号，redirectPort表示当强制要求https而请求是http时，重定向至端口号为8443的Connector，connectionTimeout表示连接的超时时间。</p>
<p>在这个例子中，Tomcat监听HTTP请求，使用的是8080端口，而不是正式的80端口；实际上，在正式的生产环境中，Tomcat也常常监听8080端口，而不是80端口。这是因为在生产环境中，很少将Tomcat直接对外开放接收请求，而是在Tomcat和客户端之间加一层代理服务器(如nginx)，用于请求的转发、负载均衡、处理静态文件等；通过代理服务器访问Tomcat时，是在局域网中，因此一般仍使用8080端口。</p>
<p>（2）通过配置第2个Connector，客户端可以通过8009端口号使用AJP协议访问Tomcat。AJP协议负责和其他的HTTP服务器(如Apache)建立连接；在把Tomcat与其他HTTP服务器集成时，就需要用到这个连接器。之所以使用Tomcat和其他服务器集成，是因为Tomcat可以用作Servlet/JSP容器，但是对静态资源的处理速度较慢，不如Apache和IIS等HTTP服务器；因此常常将Tomcat与Apache等集成，前者作Servlet容器，后者处理静态资源，而AJP协议便负责Tomcat和Apache的连接。Tomcat与Apache等集成的原理如下图：</p>
<div align=center><img width="600" height="200" src="../../../../images/2017-12-27/tomcat%E5%85%A5%E9%97%A8/tomcat-Apache.png"/>

</div>

<p><strong>4、Engine</strong></p>
<p>Engine组件在Service组件中有且只有一个；Engine是Service组件中的请求处理组件。Engine组件从一个或多个Connector中接收请求并处理，并将完成的响应返回给Connector，最终传递给客户端。</p>
<p>前面已经提到过，Engine、Host和Context都是容器，但它们不是平行的关系，而是父子关系：Engine包含Host，Host包含Context。</p>
<p>在第一部分的例子中，Engine的配置语句如下：</p>
<blockquote>
<p><code>&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;</code></p>
</blockquote>
<p>其中，name属性用于日志和错误信息，在整个Server中应该唯一。defaultHost属性指定了默认的host名称，当发往本机的请求指定的host名称不存在时，一律使用defaultHost指定的host进行处理；因此，defaultHost的值，必须与Engine中的一个Host组件的name属性值匹配。</p>
<p><strong>5、Host</strong></p>
<p>（1）Engine与Host</p>
<p>Host是Engine的子容器。Engine组件中可以内嵌1个或多个Host组件，每个Host组件代表Engine中的一个虚拟主机。Host组件至少有一个，且其中一个的name必须与Engine组件的defaultHost属性相匹配。</p>
<p>（2）Host的作用</p>
<p>Host虚拟主机的作用，是运行多个Web应用（一个Context代表一个Web应用），并负责安装、展开、启动和结束每个Web应用。</p>
<p>Host组件代表的虚拟主机，对应了服务器中一个网络名实体(如”<a href="http://www.test.com”,或ip地址”116.25.25.25”);为了使用户可以通过网络名连接tomcat服务器,这个名字应该在dns服务器上注册./">www.test.com”，或IP地址”116.25.25.25”)；为了使用户可以通过网络名连接Tomcat服务器，这个名字应该在DNS服务器上注册。</a></p>
<p>客户端通常使用主机名来标识它们希望连接的服务器；该主机名也会包含在HTTP请求头中。Tomcat从HTTP头中提取出主机名，寻找名称匹配的主机。如果没有匹配，请求将发送至默认主机。因此默认主机不需要是在DNS服务器中注册的网络名，因为任何与所有Host名称不匹配的请求，都会路由至默认主机。</p>
<p>（3）Host的配置</p>
<p>在第一部分的例子中，Host的配置如下：</p>
<blockquote>
<p><code>&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;</code></p>
</blockquote>
<p>下面对其中配置的属性进行说明：</p>
<p>name属性指定虚拟主机的主机名，一个Engine中有且仅有一个Host组件的name属性与Engine组件的defaultHost属性相匹配；一般情况下，主机名需要是在DNS服务器中注册的网络名，但是Engine指定的defaultHost不需要，原因在前面已经说明。</p>
<p>unpackWARs指定了是否将代表Web应用的WAR文件解压；如果为true，通过解压后的文件结构运行该Web应用，如果为false，直接使用WAR文件运行Web应用。</p>
<p>Host的autoDeploy和appBase属性，与Host内Web应用的自动部署有关；此外，本例中没有出现的xmlBase和deployOnStartup属性，也与Web应用的自动部署有关。</p>
<p><strong>6、Context</strong></p>
<p>（1）Context的作用</p>
<p>Context元素代表在特定虚拟主机上运行的一个Web应用。在后文中，提到Context、应用或Web应用，它们指代的都是Web应用。每个Web应用基于WAR文件，或WAR文件解压后对应的目录（这里称为应用目录）。</p>
<p>Context是Host的子容器，每个Host中可以定义任意多的Context元素。</p>
<p>在第一部分的例子中，可以看到server.xml配置文件中并没有出现Context元素的配置。这是因为，Tomcat开启了自动部署，Web应用没有在server.xml中配置静态部署，而是由Tomcat通过特定的规则自动部署。下面介绍一下Tomcat自动部署Web应用的机制。</p>
<p>（2）Web应用自动部署</p>
<p><strong>Host的配置</strong></p>
<p>要开启Web应用的自动部署，需要配置所在的虚拟主机；配置的方式就是前面提到的Host元素的deployOnStartup和autoDeploy属性。如果deployOnStartup和autoDeploy设置为true，则tomcat启动自动部署：当检测到新的Web应用或Web应用的更新时，会触发应用的部署(或重新部署)。二者的主要区别在于，deployOnStartup为true时，Tomcat在启动时检查Web应用，且检测到的所有Web应用视作新应用；autoDeploy为true时，Tomcat在运行时定期检查新的Web应用或Web应用的更新。除此之外，二者的处理相似。</p>
<p>通过配置deployOnStartup和autoDeploy可以开启虚拟主机自动部署Web应用；实际上，自动部署依赖于检查是否有新的或更改过的Web应用，而Host元素的appBase和xmlBase设置了检查Web应用更新的目录。</p>
<p>其中，appBase属性指定Web应用所在的目录，默认值是webapps，这是一个相对路径，代表Tomcat根目录下webapps文件夹。</p>
<p>xmlBase属性指定Web应用的XML配置文件所在的目录，默认值为conf/<code>&lt;engine_name&gt;</code>/<code>&lt;host_name&gt;</code>，例如第一部分的例子中，主机localhost的xmlBase的默认值是$TOMCAT_HOME/conf/Catalina/localhost。</p>
<p><strong>检查Web应用更新</strong></p>
<p>一个Web应用可能包括以下文件：XML配置文件，WAR包，以及一个应用目录(该目录包含Web应用的文件结构)；其中XML配置文件位于xmlBase指定的目录，WAR包和应用目录位于appBase指定的目录。</p>
<p>Tomcat按照如下的顺序进行扫描，来检查应用更新：</p>
<p>A、扫描虚拟主机指定的xmlBase下的XML配置文件</p>
<p>B、扫描虚拟主机指定的appBase下的WAR文件</p>
<p>C、扫描虚拟主机指定的appBase下的应用目录</p>
<p><strong><code>&lt;Context&gt;</code>元素的配置</strong></p>
<p>Context元素最重要的属性是docBase和path，此外reloadable属性也比较常用。</p>
<p>docBase指定了该Web应用使用的WAR包路径，或应用目录。需要注意的是，在自动部署场景下(配置文件位于xmlBase中)，docBase不在appBase目录中，才需要指定；如果docBase指定的WAR包或应用目录就在docBase中，则不需要指定，因为Tomcat会自动扫描appBase中的WAR包和应用目录，指定了反而会造成问题。</p>
<p>path指定了访问该Web应用的上下文路径，当请求到来时，Tomcat根据Web应用的 path属性与URI的匹配程度来选择Web应用处理相应请求。例如，Web应用app1的path属性是”/app1”，Web应用app2的path属性是”/app2”，那么请求/app1/index.html会交由app1来处理；而请求/app2/index.html会交由app2来处理。如果一个Context元素的path属性为””，那么这个Context是虚拟主机的默认Web应用；当请求的uri与所有的path都不匹配时，使用该默认Web应用来处理。</p>
<p>但是，需要注意的是，在自动部署场景下(配置文件位于xmlBase中)，不能指定path属性，path属性由配置文件的文件名、WAR文件的文件名或应用目录的名称自动推导出来。如扫描Web应用时，发现了xmlBase目录下的app1.xml，或appBase目录下的app1.WAR或app1应用目录，则该Web应用的path属性是”app1”。如果名称不是app1而是ROOT，则该Web应用是虚拟主机默认的Web应用，此时path属性推导为””。</p>
<p>reloadable属性指示tomcat是否在运行时监控在WEB-INF/classes和WEB-INF/lib目录下class文件的改动。如果值为true，那么当class文件改动时，会触发Web应用的重新加载。在开发环境下，reloadable设置为true便于调试；但是在生产环境中设置为true会给服务器带来性能压力，因此reloadable参数的默认值为false。</p>
<p>下面来看自动部署时，xmlBase下的XML配置文件app1.xml的例子：</p>
<blockquote>
<p><code>&lt;Context docBase=&quot;D:\Program Files\app1.war&quot; reloadable=&quot;true&quot;/&gt;</code></p>
</blockquote>
<p>在该例子中，docBase位于Host的appBase目录之外；path属性没有指定，而是根据app1.xml自动推导为”app1”；由于是在开发环境下，因此reloadable设置为true，便于开发调试。</p>
<p><strong>自动部署举例</strong></p>
<p>最典型的自动部署，就是当我们安装完Tomcat后，$TOMCAT_HOME/webapps目录下有如下文件夹：</p>
<div align=center><img width="100" height="200" src="../../../../images/2017-12-27/tomcat%E5%85%A5%E9%97%A8/%E7%9B%AE%E5%BD%95.png"/>

</div>

<p>当我们启动Tomcat后，可以使用<a href="http://localhost:8080/%E6%9D%A5%E8%AE%BF%E9%97%AETomcat%EF%BC%8C%E5%85%B6%E5%AE%9E%E8%AE%BF%E9%97%AE%E7%9A%84%E5%B0%B1%E6%98%AFROOT%E5%AF%B9%E5%BA%94%E7%9A%84Web%E5%BA%94%E7%94%A8%EF%BC%9B%E6%88%91%E4%BB%AC%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87http://localhost:8080/docs%E6%9D%A5%E8%AE%BF%E9%97%AEdocs%E5%BA%94%E7%94%A8%EF%BC%8C%E5%90%8C%E7%90%86%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEexamples/host-manager/manager%E8%BF%99%E5%87%A0%E4%B8%AAWeb%E5%BA%94%E7%94%A8%E3%80%82">http://localhost:8080/来访问Tomcat，其实访问的就是ROOT对应的Web应用；我们也可以通过http://localhost:8080/docs来访问docs应用，同理我们可以访问examples/host-manager/manager这几个Web应用。</a></p>
<p>（3）server.xml中静态部署Web应用</p>
<p>除了自动部署，我们也可以在server.xml中通过<code>&lt;context&gt;</code>元素静态部署Web应用。静态部署与自动部署是可以共存的。在实际应用中，并不推荐使用静态部署，因为server.xml 是不可动态重加载的资源，服务器一旦启动了以后，要修改这个文件，就得重启服务器才能重新加载。而自动部署可以在Tomcat运行时通过定期的扫描来实现，不需要重启服务器。</p>
<p>server.xml中使用Context元素配置Web应用，Context元素应该位于Host元素中。举例如下：</p>
<blockquote>
<p><code>&lt;Context path=&quot;/&quot; docBase=&quot;D:\Program Files \app1.war&quot; reloadable=&quot;true&quot;/&gt;</code></p>
</blockquote>
<p>docBase：静态部署时，docBase可以在appBase目录下，也可以不在；本例中，docBase不在appBase目录下。</p>
<p>path：静态部署时，可以显式指定path属性，但是仍然受到了严格的限制：只有当自动部署完全关闭(deployOnStartup和autoDeploy都为false)或docBase不在appBase中时，才可以设置path属性。在本例中，docBase不在appBase中，因此path属性可以设置。</p>
<p>reloadable属性的用法与自动部署时相同。</p>
<h3 id="核心组件的关联"><a href="#核心组件的关联" class="headerlink" title="核心组件的关联"></a>核心组件的关联</h3><p><strong>1、整体关系</strong></p>
<p>核心组件之间的整体关系，在上一部分有所介绍，这里总结一下：</p>
<p>Server元素在最顶层，代表整个Tomcat容器；一个Server元素中可以有一个或多个Service元素。</p>
<p>Service在Connector和Engine外面包了一层，把它们组装在一起，对外提供服务。一个Service可以包含多个Connector，但是只能包含一个Engine；Connector接收请求，Engine处理请求。</p>
<p>Engine、Host和Context都是容器，且 Engine包含Host，Host包含Context。每个Host组件代表Engine中的一个虚拟主机；每个Context组件代表在特定Host上运行的一个Web应用。</p>
<p><strong>2、如何确定请求由谁处理？</strong></p>
<p>当请求被发送到Tomcat所在的主机时，如何确定最终哪个Web应用来处理该请求呢？</p>
<p>（1）根据协议和端口号选定Service和Engine</p>
<p>Service中的Connector组件可以接收特定端口的请求，因此，当Tomcat启动时，Service组件就会监听特定的端口。在第一部分的例子中，Catalina这个Service监听了8080端口（基于HTTP协议）和8009端口（基于AJP协议）。当请求进来时，Tomcat便可以根据协议和端口号选定处理请求的Service；Service一旦选定，Engine也就确定。</p>
<p>通过在Server中配置多个Service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用。</p>
<p>（2）根据域名或IP地址选定Host</p>
<p>Service确定后，Tomcat在Service中寻找名称与域名/IP地址匹配的Host处理该请求。如果没有找到，则使用Engine中指定的defaultHost来处理该请求。在第一部分的例子中，由于只有一个Host（name属性为localhost），因此该Service/Engine的所有请求都交给该Host处理。</p>
<p>（3）根据URI选定Context/Web应用</p>
<p>这一点在Context一节有详细的说明：Tomcat根据应用的 path属性与URI的匹配程度来选择Web应用处理相应请求，这里不再赘述。</p>
<p>（4）举例</p>
<p>以请求<a href="http://localhost:8080/app1/index.html%E4%B8%BA%E4%BE%8B%EF%BC%8C%E9%A6%96%E5%85%88%E9%80%9A%E8%BF%87%E5%8D%8F%E8%AE%AE%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7%EF%BC%88http%E5%92%8C8080%EF%BC%89%E9%80%89%E5%AE%9AService%EF%BC%9B%E7%84%B6%E5%90%8E%E9%80%9A%E8%BF%87%E4%B8%BB%E6%9C%BA%E5%90%8D%EF%BC%88localhost%EF%BC%89%E9%80%89%E5%AE%9AHost%EF%BC%9B%E7%84%B6%E5%90%8E%E9%80%9A%E8%BF%87uri%EF%BC%88/app1/index.html%EF%BC%89%E9%80%89%E5%AE%9AWeb%E5%BA%94%E7%94%A8%E3%80%82">http://localhost:8080/app1/index.html为例，首先通过协议和端口号（http和8080）选定Service；然后通过主机名（localhost）选定Host；然后通过uri（/app1/index.html）选定Web应用。</a></p>
<p><strong>3、如何配置多个服务</strong></p>
<p>通过在Server中配置多个Service服务，可以实现通过不同的端口号来访问同一台机器上部署的不同Web应用。</p>
<p>在server.xml中配置多服务的方法非常简单，分为以下几步：</p>
<p>（1）复制<code>&lt;Service&gt;</code>元素，放在当前<code>&lt;Service&gt;</code>后面。</p>
<p>（2）修改端口号：根据需要监听的端口号修改<code>&lt;Connector&gt;</code>元素的port属性；必须确保该端口没有被其他进程占用，否则Tomcat启动时会报错，而无法通过该端口访问Web应用。</p>
<p>以Win7为例，可以用如下方法找出某个端口是否被其他进程占用：netstat -aon|findstr “8081″发现8081端口被PID为2064的进程占用，tasklist |findstr “2064″发现该进程为FrameworkService.exe(这是McAfee杀毒软件的进程)。</p>
<div align=center><img width="600" height="200" src="../../../../images/2017-12-27/tomcat%E5%85%A5%E9%97%A8/task.png"/>

</div>

<p>（3）修改Service和Engine的name属性</p>
<p>（4）修改Host的appBase属性（如webapps2）</p>
<p>（5）Web应用仍然使用自动部署</p>
<p>（6）将要部署的Web应用(WAR包或应用目录)拷贝到新的appBase下。</p>
<p>以第一部分的server.xml为例，多个Service的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">&quot;8005&quot;</span> <span class="attr">shutdown</span>=<span class="string">&quot;SHUTDOWN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.startup.VersionLoggerListener&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.AprLifecycleListener&quot;</span> <span class="attr">SSLEngine</span>=<span class="string">&quot;on&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.JasperListener&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">&quot;UserDatabase&quot;</span> <span class="attr">auth</span>=<span class="string">&quot;Container&quot;</span> <span class="attr">type</span>=<span class="string">&quot;org.apache.catalina.UserDatabase&quot;</span> <span class="attr">description</span>=<span class="string">&quot;User database that can be updated and saved&quot;</span> <span class="attr">factory</span>=<span class="string">&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;</span> <span class="attr">pathname</span>=<span class="string">&quot;conf/tomcat-users.xml&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8009&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;AJP/1.3&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span> <span class="attr">defaultHost</span>=<span class="string">&quot;localhost&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.realm.LockOutRealm&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">resourceName</span>=<span class="string">&quot;UserDatabase&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;localhost&quot;</span>  <span class="attr">appBase</span>=<span class="string">&quot;/opt/project/webapps&quot;</span> <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.valves.AccessLogValve&quot;</span> <span class="attr">directory</span>=<span class="string">&quot;logs&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;localhost_access_log.&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;.txt&quot;</span> <span class="attr">pattern</span>=<span class="string">&quot;%h %l %u %t <span class="symbol">&amp;quot;</span>%r<span class="symbol">&amp;quot;</span> %s %b&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">&quot;Catalina2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8084&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8010&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;AJP/1.3&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">&quot;Catalina2&quot;</span> <span class="attr">defaultHost</span>=<span class="string">&quot;localhost&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.realm.LockOutRealm&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">resourceName</span>=<span class="string">&quot;UserDatabase&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;localhost&quot;</span>  <span class="attr">appBase</span>=<span class="string">&quot;/opt/project/webapps2&quot;</span> <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.valves.AccessLogValve&quot;</span> <span class="attr">directory</span>=<span class="string">&quot;logs&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;localhost_access_log.&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;.txt&quot;</span> <span class="attr">pattern</span>=<span class="string">&quot;%h %l %u %t <span class="symbol">&amp;quot;</span>%r<span class="symbol">&amp;quot;</span> %s %b&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>再将原webapps下的docs目录拷贝到webapps2中，则通过如下两个接口都可以访问docs应用：</p>
<p><a href="http://localhost:8080/docs/">http://localhost:8080/docs/</a></p>
<p><a href="http://localhost:8084/docs/">http://localhost:8084/docs/</a></p>
<h3 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h3><p>除核心组件外，server.xml中还可以配置很多其他组件。下面只介绍第一部分例子中出现的组件，如果要了解更多内容，可以查看Tomcat官方文档。</p>
<p><strong>1、Listener</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.startup.VersionLoggerListener&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.AprLifecycleListener&quot;</span> <span class="attr">SSLEngine</span>=<span class="string">&quot;on&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.JasperListener&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>Listener(即监听器)定义的组件，可以在特定事件发生时执行特定的操作；被监听的事件通常是Tomcat的启动和停止。</p>
<p>监听器可以在Server、Engine、Host或Context中，本例中的监听器都是在Server中。实际上，本例中定义的6个监听器，都只能存在于Server组件中。监听器不允许内嵌其他组件。</p>
<p>监听器需要配置的最重要的属性是className，该属性规定了监听器的具体实现类，该类必须实现了org.apache.catalina.LifecycleListener接口。</p>
<p>下面依次介绍例子中配置的监听器：</p>
<ul>
<li>VersionLoggerListener：当Tomcat启动时，该监听器记录Tomcat、Java和操作系统的信息。该监听器必须是配置的第一个监听器。</li>
<li>AprLifecycleListener：Tomcat启动时，检查APR库，如果存在则加载。APR，即Apache Portable Runtime，是Apache可移植运行库，可以实现高可扩展性、高性能，以及与本地服务器技术更好的集成。</li>
<li>JasperListener：在Web应用启动之前初始化Jasper，Jasper是JSP引擎，把JVM不认识的JSP文件解析成java文件，然后编译成class文件供JVM使用。</li>
<li>JreMemoryLeakPreventionListener：与类加载器导致的内存泄露有关。</li>
<li>GlobalResourcesLifecycleListener：通过该监听器，初始化&lt; GlobalNamingResources&gt;标签中定义的全局JNDI资源；如果没有该监听器，任何全局资源都不能使用。&lt; GlobalNamingResources&gt;将在后文介绍。</li>
<li>ThreadLocalLeakPreventionListener：当Web应用因thread-local导致的内存泄露而要停止时，该监听器会触发线程池中线程的更新。当线程执行完任务被收回线程池时，活跃线程会一个一个的更新。只有当Web应用(即Context元素)的renewThreadsWhenStoppingContext属性设置为true时，该监听器才有效。</li>
</ul>
<p><strong>2、GlobalNamingResources与Realm</strong></p>
<p>第一部分的例子中，Engine组件下定义了Realm组件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.realm.LockOutRealm&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">resourceName</span>=<span class="string">&quot;UserDatabase&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Realm，可以把它理解成“域”；Realm提供了一种用户密码与web应用的映射关系，从而达到角色安全管理的作用。在本例中，Realm的配置使用name为UserDatabase的资源实现。而该资源在Server元素中使用GlobalNamingResources配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">&quot;UserDatabase&quot;</span> <span class="attr">auth</span>=<span class="string">&quot;Container&quot;</span> <span class="attr">type</span>=<span class="string">&quot;org.apache.catalina.UserDatabase&quot;</span> <span class="attr">description</span>=<span class="string">&quot;User database that can be updated and saved&quot;</span> <span class="attr">factory</span>=<span class="string">&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;</span> <span class="attr">pathname</span>=<span class="string">&quot;conf/tomcat-users.xml&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>3、Valve</strong></p>
<p>在第一部分的例子中，Host元素内定义了Valve组件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.valves.AccessLogValve&quot;</span> <span class="attr">directory</span>=<span class="string">&quot;logs&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;localhost_access_log.&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;.txt&quot;</span> <span class="attr">pattern</span>=<span class="string">&quot;%h %l %u %t <span class="symbol">&amp;quot;</span>%r<span class="symbol">&amp;quot;</span> %s %b&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>单词Valve的意思是“阀门”，在Tomcat中代表了请求处理流水线上的一个组件；Valve可以与Tomcat的容器(Engine、Host或Context)关联。</p>
<p>不同的Valve有不同的特性，下面介绍一下本例中出现的AccessLogValve。</p>
<p>AccessLogValve的作用是通过日志记录其所在的容器中处理的所有请求，在本例中，Valve放在Host下，便可以记录该Host处理的所有请求。AccessLogValve记录的日志就是访问日志，每天的请求会写到一个日志文件里。AccessLogValve可以与Engine、Host或Context关联；在本例中，只有一个Engine，Engine下只有一个Host，Host下只有一个Context，因此AccessLogValve放在三个容器下的作用其实是类似的。</p>
<p>本例的AccessLogValve属性的配置，使用的是默认的配置；下面介绍AccessLogValve中各个属性的作用：</p>
<p>（1）className：规定了Valve的类型，是最重要的属性；本例中，通过该属性规定了这是一个AccessLogValve。</p>
<p>（2）directory：指定日志存储的位置，本例中，日志存储在$TOMCAT_HOME/logs目录下。</p>
<p>（3）prefix：指定了日志文件的前缀。</p>
<p>（4）suffix：指定了日志文件的后缀。通过directory、prefix和suffix的配置，在$TOMCAT_HOME/logs目录下，可以看到如下所示的日志文件。</p>
<div align=center><img width="400" height="200" src="../../../../images/2017-12-27/tomcat%E5%85%A5%E9%97%A8/log.png"/>

</div>

<p>（5）pattern：指定记录日志的格式，本例中各项的含义如下：</p>
<ul>
<li>%h：远程主机名或IP地址；如果有nginx等反向代理服务器进行请求分发，该主机名/IP地址代表的是nginx，否则代表的是客户端。后面远程的含义与之类似，不再解释。</li>
<li>%l：远程逻辑用户名，一律是”-”，可以忽略。</li>
<li>%u：授权的远程用户名，如果没有，则是”-”。</li>
<li>%t：访问的时间。</li>
<li>%r：请求的第一行，即请求方法(get/post等)、uri、及协议。</li>
<li>%s：响应状态，200,404等等。</li>
<li>%b：响应的数据量，不包括请求头，如果为0，则是””-。</li>
</ul>
<p>例如，下面是访问日志中的一条记录</p>
<div align=center><img width="600" height="200" src="../../../../images/2017-12-27/tomcat%E5%85%A5%E9%97%A8/access_log.png"/>

</div>

<p>pattern的配置中，除了上述各项，还有一个非常常用的选项是%D，含义是请求处理的时间(单位是毫秒)，对于统计分析请求的处理速度帮助很大。</p>
<p>开发人员可以充分利用访问日志，来分析问题、优化应用。例如，分析访问日志中各个接口被访问的比例，不仅可以为需求和运营人员提供数据支持，还可以使自己的优化有的放矢；分析访问日志中各个请求的响应状态码，可以知道服务器请求的成功率，并找出有问题的请求；分析访问日志中各个请求的响应时间，可以找出慢请求，并根据需要进行响应时间的优化。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li>Tomcat官方文档</li>
<li>《How Tomcat Works》</li>
<li>《深入分析Java Web技术内幕》</li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&mid=2651478920&idx=1&sn=c3f23f9bc0707930e5634e5ae61b499c&chksm=bd2537f78a52bee1c04ad1fb410e2d62c6714f6851a21ab36d26c117dd0cdf02925f4295485b&mpshare=1&scene=24&srcid=08266j3OTBuUem8l94WhpTAK#rd">详解 Tomcat 配置文件 server.xml</a></li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>异步编程之CompletableFuture</title>
    <url>/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B9%8BCompletableFuture/</url>
    <content><![CDATA[<p>在Java8中新增了<code>CompletableFuture</code>类，该类实现了<code>Future</code>和<code>CompletionStage</code>接口。提供了强大的<code>Future</code>扩展功能，简化了异步编程的复杂性，提供了函数式编程的能力。可通过异步回调方式处理结果，还可以对任务进行组合处理。<span id="more"></span></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><div align=center><img src="../../../../images/2021/10-12/completable-mind.png" algin="center"/></div><!-- more -->



<h1 id="创建异步任务"><a href="#创建异步任务" class="headerlink" title="创建异步任务"></a>创建异步任务</h1><p><code>CompletableFuture</code>提供了四个静态方法来创建一个异步操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 有返回值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span></span><br></pre></td></tr></table></figure>

<p>没有指定<code>Executor</code>的话默认会使用<code>ForkJoinPool.commonPool()</code> 作为缺省线程池执行异步代码，其中<code>ForkJoinPool.commonPool()</code>核心线程数量为<strong>CPU-1</strong>核心数。如果指定线程池，则使用指定的线程池执行任务。</p>
<h2 id="runAsync"><a href="#runAsync" class="headerlink" title="runAsync"></a>runAsync</h2><p>以<code>Runnable</code>函数式接口类型为参数，无返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// runAsync直接执行，无返回值</span></span><br><span class="line">  CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;runAsync线程名称: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">  &#125;);</span><br><span class="line">  future.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runAsync线程名称: ForkJoinPool.commonPool-worker-1</span></span><br></pre></td></tr></table></figure>

<h2 id="supplyAsync"><a href="#supplyAsync" class="headerlink" title="supplyAsync"></a>supplyAsync</h2><p>以<code>Supplier&lt;U&gt;</code>函数式接口类型为参数,<code>CompletableFuture</code>的计算结果类型为<code>U</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">supplyAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// supplyAsync支持返回值</span></span><br><span class="line">  CompletableFuture&lt;Long&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;supplyAsync线程名称: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">  &#125;);</span><br><span class="line">  System.out.println(<span class="string">&quot;阻塞获取结果。结果为：&quot;</span> + future.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// supplyAsync线程名称: ForkJoinPool.commonPool-worker-1</span></span><br><span class="line"><span class="comment">// 阻塞获取结果。结果为：1640446068495</span></span><br></pre></td></tr></table></figure>

<p>以异步场景为例，可与List结合使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先将 List&lt;Integer&gt; 转换成 -&gt; List&lt;CompletableFuture&lt;String&gt;&gt;的list 然后对这个list进行join操作</span></span><br><span class="line">List&lt;Integer&gt; collect = Lists.newArrayList(<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">        .stream()</span><br><span class="line">        .map(i -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            Uninterruptibles.sleepUninterruptibly(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;))</span><br><span class="line">        .collect(Collectors.toList())</span><br><span class="line">        .stream()</span><br><span class="line">        .map(CompletableFuture::join).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h1 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h1><h2 id="thenRun-thenRunAsync"><a href="#thenRun-thenRunAsync" class="headerlink" title="thenRun/thenRunAsync"></a>thenRun/thenRunAsync</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenRun</span><span class="params">(Runnable action)</span></span>;</span><br></pre></td></tr></table></figure>

<p>执行完第一个任务再执行第二个任务，前后两个任务没有参数传递，第二个任务(<code>thenRun</code>)也没有返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenRun</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// supplyAsync执行完成后执行thenRun(无参数，无返回)</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;supplyAsync线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。结果为：&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;).thenRun(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;thenRun线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。无参数，无返回值&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;阻塞获取结果。结果为：&quot;</span> + future.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// supplyAsync线程名称: ForkJoinPool.commonPool-worker-1。结果为：64</span></span><br><span class="line"><span class="comment">// thenRun线程名称: main。无参数，无返回值</span></span><br><span class="line"><span class="comment">// 阻塞获取结果。结果为：null</span></span><br></pre></td></tr></table></figure>

<h3 id="thenRun和thenRunAsync区别"><a href="#thenRun和thenRunAsync区别" class="headerlink" title="thenRun和thenRunAsync区别"></a>thenRun和thenRunAsync区别</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor asyncPool = useCommonPool? ForkJoinPool.commonPool() : <span class="keyword">new</span> ThreadPerTaskExecutor();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenRun</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> uniRunStage(<span class="keyword">null</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> uniRunStage(asyncPool, action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在执行第一个任务的时候传入了一个自定义线程池：</p>
<ul>
<li>调用<code>thenRun</code>方法执行第二个任务时，第二个任务和第一个任务共用一个线程池；</li>
<li>调用<code>thenRunAsync</code>方法执行第二个任务时，第一个任务使用自己传入的线程池，第二个任务使用<code>ForkJoinPool</code>；</li>
</ul>
<p>后面所说的<code>thenAccept</code>和<code>thenAcceptAsync</code>、<code>thenApply</code>和<code>thenApplyAsync</code>等，它们之间的区别也是如此。</p>
<h2 id="thenAccept-thenAcceptAsync"><a href="#thenAccept-thenAcceptAsync" class="headerlink" title="thenAccept/thenAcceptAsync"></a>thenAccept/thenAcceptAsync</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenAccept</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br></pre></td></tr></table></figure>

<p>执行完第一个任务后，将执行结果作为入参传递到回调方法(<code>thenAccept</code>)中，回调方法无返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenAccept</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// supplyAsync执行完成后执行thenAccept(参数为上个任务的结果，无返回值)</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;supplyAsync线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。结果为：&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;).thenAccept(arg -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> result = arg * <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;thenAccept线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。结果为：&quot;</span> + result);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;阻塞获取结果。结果为：&quot;</span> + future.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// supplyAsync线程名称: ForkJoinPool.commonPool-worker-1。结果为：66</span></span><br><span class="line"><span class="comment">// thenAccept线程名称: main。结果为：660</span></span><br><span class="line"><span class="comment">// 阻塞获取结果。结果为：null</span></span><br></pre></td></tr></table></figure>

<h2 id="thenApply-thenApplyAsync"><a href="#thenApply-thenApplyAsync" class="headerlink" title="thenApply/thenApplyAsync"></a>thenApply/thenApplyAsync</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApply</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span></span><br></pre></td></tr></table></figure>

<p>执行完第一个任务后，将执行结果作为入参传递到回调方法(<code>thenApply</code>)中，回调方法有返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenApply</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 执行完supplyAsync拿到返回结果后执行thenApply(参数为上个任务的结果，有返回值)</span></span><br><span class="line">    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;supplyAsync线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。结果为：&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;).thenApply(arg -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> result = arg * <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;thenApply线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。结果为：&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;阻塞获取结果。结果为：&quot;</span> + future.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// supplyAsync线程名称: ForkJoinPool.commonPool-worker-1。结果为：44</span></span><br><span class="line"><span class="comment">// thenApply线程名称: main。结果为：440</span></span><br><span class="line"><span class="comment">// 阻塞获取结果。结果为：440</span></span><br></pre></td></tr></table></figure>

<h2 id="exceptionally"><a href="#exceptionally" class="headerlink" title="exceptionally"></a>exceptionally</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">exceptionally</span><span class="params">(Function&lt;Throwable, ? extends T&gt; fn)</span></span></span><br></pre></td></tr></table></figure>

<p>某个任务执行异常时，执行的回调方法，并且将抛出异常作为参数，传递到回调方法，<code>exceptionally</code>方法有返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exceptionally</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// supplyAsync中发生异常进入exceptionally块，最终结果为exceptionally中返回值</span></span><br><span class="line">    CompletableFuture&lt;Object&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;supplyAsync线程名称: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;系统异常&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;阻塞获取结果。结果为：&quot;</span> + future.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// supplyAsync线程名称: ForkJoinPool.commonPool-worker-1</span></span><br><span class="line"><span class="comment">// java.util.concurrent.CompletionException: java.lang.RuntimeException</span></span><br><span class="line"><span class="comment">// Caused by: java.lang.RuntimeException</span></span><br><span class="line"><span class="comment">//	at com.user.provider.utils.Test.lambda$exceptionally$19(Test.java:160)</span></span><br><span class="line"><span class="comment">//	at java.util.concurrent.CompletableFuture$AsyncSupply.run$$$capture(CompletableFuture.java:1590)</span></span><br><span class="line"><span class="comment">// 	... 7 more</span></span><br><span class="line"><span class="comment">// 阻塞获取结果。结果为：系统异常</span></span><br></pre></td></tr></table></figure>

<h2 id="whenComplete"><a href="#whenComplete" class="headerlink" title="whenComplete"></a>whenComplete</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span></span></span><br></pre></td></tr></table></figure>

<p>某个任务执行完成后，将上个任务的结果和异常传递到回调方法<code>whenComplete</code>中，无返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">whenComplete</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// supplyAsync执行完成后执行whenComplete(参数为上个任务的结果，无返回值)</span></span><br><span class="line">    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;supplyAsync线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。结果为：&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;).whenComplete((arg, e) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;whenComplete线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。参数为：&quot;</span> + arg);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;阻塞获取结果。结果为：&quot;</span> + future.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// supplyAsync线程名称: ForkJoinPool.commonPool-worker-1。结果为：66</span></span><br><span class="line"><span class="comment">// whenComplete线程名称: main。参数为：66</span></span><br><span class="line"><span class="comment">// 阻塞获取结果。结果为：66</span></span><br></pre></td></tr></table></figure>

<h2 id="handle"><a href="#handle" class="headerlink" title="handle"></a>handle</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">handle</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn)</span> </span></span><br></pre></td></tr></table></figure>

<p>某个任务执行完成后，将上个任务的结果和异常传递到回调方法<code>handle</code>中，有返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// supplyAsync执行完成后执行handle(参数为上个任务的结果，有返回值)</span></span><br><span class="line">    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;supplyAsync线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。结果为：&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;).handle((arg, e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> result = arg * <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;handle线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。结果为：&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;阻塞获取结果。结果为：&quot;</span> + future.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// supplyAsync线程名称: ForkJoinPool.commonPool-worker-1。结果为：45</span></span><br><span class="line"><span class="comment">// handle线程名称: ForkJoinPool.commonPool-worker-1。结果为：450</span></span><br><span class="line"><span class="comment">// 阻塞获取结果。结果为：450</span></span><br></pre></td></tr></table></figure>

<h1 id="任务组合"><a href="#任务组合" class="headerlink" title="任务组合"></a>任务组合</h1><h2 id="AND组合关系"><a href="#AND组合关系" class="headerlink" title="AND组合关系"></a>AND组合关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombine</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;Void&gt; <span class="title">thenAcceptBoth</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">runAfterBoth</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action)</span></span></span><br></pre></td></tr></table></figure>

<p><code>thenCombine</code>/<code>thenAcceptBoth</code>/<code>runAfterBoth</code>都表示：<strong>将两个<code>CompletableFuture</code>组合起来，只有这两个都正常执行完成才会执行某个任务</strong>。区别为：</p>
<ul>
<li><code>thenCombine</code>：将两个任务的执行结果作为方法入参，传递到指定方法中，<strong>有返回值</strong></li>
<li><code>thenAcceptBoth</code>: 会将两个任务的执行结果作为方法入参，传递到指定方法中，<strong>无返回值</strong></li>
<li><code>runAfterBoth</code>：<strong>不会把执行结果当做方法入参，没有返回值</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenCombine</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// supplyAsync1和supplyAsync2都执行完成后执行thenCombine(接收两个参数，有返回值)</span></span><br><span class="line">    CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;supplyAsync1线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。结果为：100&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; f2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;supplyAsync2线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。结果为：200&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future = f1.thenCombine(f2, (arg1, arg2) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;thenCombine线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。结果1为：&quot;</span> + arg1 + <span class="string">&quot;。结果2为：&quot;</span> + arg2);</span><br><span class="line">        <span class="keyword">return</span> arg1 + arg2;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;阻塞获取结果。结果为：&quot;</span> + future.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// supplyAsync1线程名称: ForkJoinPool.commonPool-worker-1。结果为：100</span></span><br><span class="line"><span class="comment">// supplyAsync2线程名称: ForkJoinPool.commonPool-worker-1。结果为：200</span></span><br><span class="line"><span class="comment">// thenCombine线程名称: main。结果1为：100。结果2为：200</span></span><br><span class="line"><span class="comment">// 阻塞获取结果。结果为：300</span></span><br></pre></td></tr></table></figure>

<h2 id="OR组合关系"><a href="#OR组合关系" class="headerlink" title="OR组合关系"></a>OR组合关系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">applyToEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Function&lt;? <span class="keyword">super</span> T, U&gt; fn)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">acceptEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">runAfterEither</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>applyToEither</code>/<code>acceptEither</code>/<code>runAfterEither</code>都表示：将两个<code>CompletableFuture</code>组合起来，只要其中一个执行完了就会执行下个任务。</p>
<p>区别在于：</p>
<ul>
<li><code>applyToEither</code>：将已经执行完成的任务结果作为方法入参，传递到指定方法中，<strong>有返回值</strong></li>
<li><code>acceptEither</code>：将已经执行完成的任务结果作为方法入参，传递到指定方法中，<strong>无返回值</strong></li>
<li><code>runAfterEither</code>：<strong>不会把执行结果当做方法入参，没有返回值</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">acceptEither</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// supplyAsync1、supplyAsync2其中一个执行完成后执行acceptEither(接收一个参数，为f1、f2先执行完的结果。无返回值)</span></span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        Uninterruptibles.sleepUninterruptibly(random.nextInt(<span class="number">200</span>), TimeUnit.MILLISECONDS);</span><br><span class="line">        System.out.println(<span class="string">&quot;supplyAsync1线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。结果为：100&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; f2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        Uninterruptibles.sleepUninterruptibly(random.nextInt(<span class="number">200</span>), TimeUnit.MILLISECONDS);</span><br><span class="line">        System.out.println(<span class="string">&quot;supplyAsync2线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。结果为：200&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Void&gt; future = f1.acceptEither(f2, arg -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;acceptEither线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。参数为：&quot;</span> + arg + <span class="string">&quot;。无返回值&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;阻塞获取结果。结果为：&quot;</span> + future.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// supplyAsync2线程名称: ForkJoinPool.commonPool-worker-2。结果为：200</span></span><br><span class="line"><span class="comment">// acceptEither线程名称: ForkJoinPool.commonPool-worker-2。参数为：200。无返回值</span></span><br><span class="line"><span class="comment">// 阻塞获取结果。结果为：null</span></span><br></pre></td></tr></table></figure>

<h2 id="anyOf"><a href="#anyOf" class="headerlink" title="anyOf"></a>anyOf</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Object&gt; <span class="title">anyOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span></span><br></pre></td></tr></table></figure>

<p>任意一个任务执行完，就执行<code>anyOf</code>返回的<code>CompletableFuture</code>。如果执行的任务异常，<code>anyOf</code>的<code>CompletableFuture</code>执行<code>get()</code>方法会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">anyOf</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        Uninterruptibles.sleepUninterruptibly(random.nextInt(<span class="number">200</span>), TimeUnit.MILLISECONDS);</span><br><span class="line">        System.out.println(<span class="string">&quot;supplyAsync1线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。结果为：100&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; f2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        Uninterruptibles.sleepUninterruptibly(random.nextInt(<span class="number">100</span>), TimeUnit.MILLISECONDS);</span><br><span class="line">        System.out.println(<span class="string">&quot;supplyAsync2线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。结果为：200&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Object&gt; future = CompletableFuture.anyOf(f1, f2).whenComplete((arg, throwable) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;anyOf线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。参数为：&quot;</span> + arg + <span class="string">&quot;。无返回值&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;阻塞获取结果。结果为：&quot;</span> + future.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// supplyAsync2线程名称: ForkJoinPool.commonPool-worker-2。结果为：200</span></span><br><span class="line"><span class="comment">// anyOf线程名称: ForkJoinPool.commonPool-worker-2。参数为：200。无返回值</span></span><br><span class="line"><span class="comment">// 阻塞获取结果。结果为：200</span></span><br></pre></td></tr></table></figure>

<h2 id="allOf"><a href="#allOf" class="headerlink" title="allOf"></a>allOf</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">allOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span></span><br></pre></td></tr></table></figure>

<p>所有任务都执行完成后，才执行<code>allOf</code>返回的<code>CompletableFuture</code>。如果任意一个任务异常，<code>allOf</code>的<code>CompletableFuture</code>执行<code>get()</code>方法都会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">allOf</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        Uninterruptibles.sleepUninterruptibly(random.nextInt(<span class="number">200</span>), TimeUnit.MILLISECONDS);</span><br><span class="line">        System.out.println(<span class="string">&quot;supplyAsync1线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。结果为：100&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; f2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        Uninterruptibles.sleepUninterruptibly(random.nextInt(<span class="number">100</span>), TimeUnit.MILLISECONDS);</span><br><span class="line">        System.out.println(<span class="string">&quot;supplyAsync2线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。结果为：200&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.allOf(f1, f2).whenComplete((unused, throwable) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;allOf线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。参数为：&quot;</span> + unused + <span class="string">&quot;。无返回值&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;阻塞获取结果。结果为：&quot;</span> + future.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// supplyAsync2线程名称: ForkJoinPool.commonPool-worker-2。结果为：200</span></span><br><span class="line"><span class="comment">// supplyAsync1线程名称: ForkJoinPool.commonPool-worker-1。结果为：100</span></span><br><span class="line"><span class="comment">// allOf线程名称: ForkJoinPool.commonPool-worker-1。参数为：null。无返回值</span></span><br><span class="line"><span class="comment">// 阻塞获取结果。结果为：null</span></span><br></pre></td></tr></table></figure>

<h2 id="thenCompose"><a href="#thenCompose" class="headerlink" title="thenCompose"></a>thenCompose</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenCompose</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span></span></span><br></pre></td></tr></table></figure>

<p>在某个任务执行完成后，将该任务的执行结果作为方法入参去执行指定的方法。该方法会返回一个新的<code>CompletableFuture</code>实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenCompose</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        Uninterruptibles.sleepUninterruptibly(random.nextInt(<span class="number">200</span>), TimeUnit.MILLISECONDS);</span><br><span class="line">        System.out.println(<span class="string">&quot;supplyAsync线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。结果为：100&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;).thenCompose(arg -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        Uninterruptibles.sleepUninterruptibly(random.nextInt(<span class="number">100</span>), TimeUnit.MILLISECONDS);</span><br><span class="line">        System.out.println(<span class="string">&quot;thenCompose线程名称: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;。接收参数为：&quot;</span> + arg + <span class="string">&quot;。返回：200&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;));</span><br><span class="line">    System.out.println(<span class="string">&quot;阻塞获取结果。结果为：&quot;</span> + future.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// supplyAsync线程名称: ForkJoinPool.commonPool-worker-1。结果为：100</span></span><br><span class="line"><span class="comment">// thenCompose线程名称: ForkJoinPool.commonPool-worker-2。接收参数为：100。返回：200</span></span><br><span class="line"><span class="comment">// 阻塞获取结果。结果为：200</span></span><br></pre></td></tr></table></figure>

<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="CompletableFuture-get方法是阻塞的"><a href="#CompletableFuture-get方法是阻塞的" class="headerlink" title="CompletableFuture.get方法是阻塞的"></a>CompletableFuture.get方法是阻塞的</h2><p><code>CompletableFuture</code>的<code>get()</code>方法是阻塞的，如果使用它来获取异步调用的返回值，最好添加超时时间。</p>
<blockquote>
<p>CompletableFuture.get()：获取返回值抛出异常。</p>
<p>CompletableFuture.join()：获取返回值不抛出异常。</p>
</blockquote>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><code>CompletableFuture</code>默认使用<code>ForkJoinPool.commonPool</code>线程池，核心数量为服务器<strong>CPU-1</strong>。当有大量请求处理且任务耗时较久时就会响应很慢。建议使用自定义线程池，配置自定义线程池参数。</p>
<h2 id="Future需要获取返回值才能获取异常信息"><a href="#Future需要获取返回值才能获取异常信息" class="headerlink" title="Future需要获取返回值才能获取异常信息"></a>Future需要获取返回值才能获取异常信息</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span> / <span class="number">0</span>;</span><br><span class="line">&#125;).thenAccept(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不加get()方法这一行，看不到异常信息</span></span><br><span class="line">future.get();</span><br></pre></td></tr></table></figure>

<p><code>Future</code>需要获取返回值，才能获取到异常信息。如果不加 <code>get()</code>/<code>join()</code>方法，看不到异常信息。使用的时候需要考虑是否加<code>try...catch...</code>或者使用<code>exceptionally</code>方法。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Spring</title>
    <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Spring在当前Java项目开发中可谓是核心，无论是SpringMVC、SpringBoot、SpringCloud都离不开Spring这个核心。自己对Spring的了解也停留在一知半解状态。<div align=center><img width="800" height="200" src="../../../../images/2018-5/Spring/Spring.jpg" algin="center"/></div><span id="more"></span></p>
<p>说起Spring，都知道是一个轻量级开源企业开发框架，包含控制反转（IOC）和面向切面（AOP）两大特性。</p>
<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="什么是IOC（DI）"><a href="#什么是IOC（DI）" class="headerlink" title="什么是IOC（DI）"></a>什么是IOC（DI）</h2><p>　　IOC（Inversion Of Control，控制反转）。对于Spring框架来说，就是<strong>由Spring来负责控制对象的生命周期和对象间的关系。</strong>在一个对象中，如果要使用其他的对象，就必须得到它（自己new一个或者JNDI中查询一个），使用完对象之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类耦合起来。</p>
<p>　　所有的类都会在Spring容器中登记，告诉Spring自己是什么，需要什么，然后Spring会在系统运行到适当的时候，把你需要的东西主动给你，同时也把你交给其他需要你的东西。<strong>所有类的创建、销毁都由Spring来控制，也就是说控制对象生命周期的不再是引用它的对象，而是Spring容器。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被Spring控制，所以这叫做控制反转。</strong></p>
<p>　　IOC的一个重点是<strong>在系统运行中，动态的向某个对象提供它所需要的其他对象。</strong>这一点是通过<strong>DI（Dependency Injection，依赖注入）</strong>来实现的。比如对象A需要操作数据库，本来需要在A中自己编写代码来获得一个Connection对象，有了Spring我们就只需要告诉Spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，Spring会在适当的时候制造一个Connection，然后像打针一样注射到A中，这样就完成了各个对象之间关系的控制。A需要依赖Connection才能正常运行，而这个Connection是由Spring注入到A中的，依赖注入的名字就是这么来的。那么DI是如何实现的呢？<strong>Java1.3之后一个重要特征就是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，Spring就是通过反射来实现注入的。</strong></p>
<blockquote>
<p>　　在没有使用Spring的时候，每个对象在需要使用他的合作对象时，自己均要使用像new object() 这样的语法来将合作对象创建出来，这个合作对象是由自己主动创建出来的，创建合作对象的主动权在自己手上，自己需要哪个合作对象，就主动去创建，创建合作对象的主动权和创建时机是由自己把控的，而这样就会使得对象间的耦合度高了，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起，而使用了Spring之后就不一样了，创建合作对象B的工作是由Spring来做的，Spring创建好B对象，然后存储到一个容器里面，当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用，至于Spring是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题(你是什么时候生的，怎么生出来的我可不关心，能帮我干活就行)，A得到Spring给我们的对象之后，两个人一起协作完成要完成的工作即可。</p>
</blockquote>
<p>　　所以控制反转IOC（Inversion Of Control）是说<strong>创建对象的控制权进行转移，以前创建对象的主动权和创建对象的时机是由自己把控的，而现在这种权利转移到了第三方。</strong>比如交给了IOC容器，它就是一个专门来创建对象的工厂，你需要什么对象，它就给你什么对象，有了IOC容器，依赖关系就变了，原来的依赖关系就没了，他们都依赖IOC容器，通过IOC容器来建立它们之间的关系。</p>
<h2 id="IOC的优点"><a href="#IOC的优点" class="headerlink" title="IOC的优点"></a>IOC的优点</h2><h3 id="可维护性比较好"><a href="#可维护性比较好" class="headerlink" title="可维护性比较好"></a>可维护性比较好</h3><p>　　便于进行单元测试，便于调试程序和诊断故障。代码中的每一个Class都可以单独测试，彼此之间互不影响，只要保证自身的功能无误即可，这就是组件之间低耦合或者无耦合带来的好处。</p>
<h3 id="可复用性好"><a href="#可复用性好" class="headerlink" title="可复用性好"></a>可复用性好</h3><p>　　可以把具有普遍性的常用组件独立出来，反复利用到项目中的其它部分，或者是其它项目，当然这也是面向对象的基本特征。IOC不仅更好地贯彻了这个原则，提高了模块的可复用性。</p>
<h3 id="分层、解耦"><a href="#分层、解耦" class="headerlink" title="分层、解耦"></a>分层、解耦</h3><p>　　IOC生成对象的方式转为外置方式，也就是把对象生成放在配置文件里进行定义，这样，当我们更换一个实现子类将会变得很简单，只要修改配置文件就可以了，完全具有热插拨的特性。</p>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>　　AOP（Aspect-OrientedProgramming，面向切面编程）。例如日志功能，日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>　　而AOP技术则恰恰相反，它利用一种称为“横切”的技术，<strong>剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即切面。</strong>所谓“切面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于<strong>减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</strong>AOP代表的是一个横向的关系。</p>
<p>　　使用“横切”技术，AOP把软件系统分为两个部分：<strong>核心关注点和横切关注点。</strong>业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p>
<p>　　实现AOP的技术，主要分为两大类：一是采用<strong>动态代理</strong>技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用<strong>静态织入</strong>（静态代理）的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“Aspect”的代码。</p>
<p>　　AOP的优点：<strong>便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</strong></p>
<p>具体代理模式可参见<a href="http://rainbowhorse.site/Spring%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><em><strong>Spring之动态代理</strong></em></a></p>
<h1 id="Spring单例、线程安全"><a href="#Spring单例、线程安全" class="headerlink" title="Spring单例、线程安全"></a>Spring单例、线程安全</h1><h2 id="Spring中的线程安全"><a href="#Spring中的线程安全" class="headerlink" title="Spring中的线程安全"></a>Spring中的线程安全</h2><p>　　<strong>Spring中管理bean实例默认情况下都是单例的【singleton】</strong>，还有prototype类型，按其作用域来讲有singleton、prototype、request、session、global、session。</p>
<p>　　Spring中的单例与设计模式里面的单例略有不同，设计模式的单例是在整个应用中只有一个实例，而Spring中的单例是在一个IOC容器中就有一个实例。但Spring中的单例也不会影响应用的并发访问【不会出现各个线程之间的等待问题或是死锁问题】，因为大多数时候客户端都在访问我们应用中的业务对象，而这些业务对象并没有做线程的并发限制，只是在这个时候我们不应该在业务对象中设置那些容易出错的成员变量，在并发访问的时候这些成员变量将会是并发线程中的共享对象，那么这个时候就会出现意外情况。</p>
<p>　　<strong>实体bean不是单例的，并没有交给Spring来管理，每次我们要手动new出来的【Item item = new Item()】，所以即使是那些处理我们提交数据的业务处理类是被多线程共享的，但是他们处理的数据并不是共享的，数据是每一个线程都有自己的一份，所以在数据这个方面是不会出现线程同步方面的问题的。但是那些在Dao中的xxxDao或Controller中的xxxService，这些对象都是单例的，那么就会出现线程同步的问题。但是这些对象虽然会被多个线程并发访问，可我们访问的是他们里面的方法，这些类里面通常不会含有成员变量，Dao里面的ibatisDao是框架里面封装好的，已经被测试，不会发生线程同步问题。所以出现问题的地方就是我们自己系统里面的业务对象，所以<code>一定要注意这些业务对象里面千万不能独立成员变量，否则会出问题</code>。</strong></p>
<p>　　<strong>Spring中容器托管的类如果没有特殊声明（scope=“prototype”），则默认为单例模式。</strong>当多个用户同时请求一个服务时，容器会给每一个请求分配一个线程，这是多个线程并发执行该请求多对应的业务逻辑（成员方法）。此时就要注意，如果该处理逻辑中有对该单列状态的修改（成员变量），则必须考虑线程同步问题；否则由于在业务逻辑中执行所需的局部变量会分配在栈空间中，所以不需要同步。</p>
<p>　　其实函数本身是代码，代码是只读的，无论多少个线程同时调都无所谓（因为只是读的），但是函数中肯定是要用到数据的，<strong>如果数据是函数参数、局部变量，那么这些数据都是存在每个线程自己的栈上的，同时调用是没有关系的，不会涉及到线程安全资源共享的问题。 但是如果使用到了全局静态变量或者类的成员变量的时候。就会出现数据安全的问题，还有，如果我们的成员变量在函数体内如果只进行读操作，不进行写操作，也是线程安全的。</strong> </p>
<p>　　总而言之，单例的方法在同一个时刻是可以被多个线程同时调用的。在写程序的时候要尽可能少的使用类的成员变量，如果使用成员变量，尽量保证只对成员变量进行读操作。</p>
<blockquote>
<p>当很多用户去修改自己信息的时候，用户线程会通过调用dao（dao都是给注入有配链接池的数据源的），dao会拿到链接池中的一个链接，将我们要处理的信息（SQL语句等）交付给数据库，数据库会按照自己的多线程处理机制完成线程的同步，然后进行数据安全处理，线程在完成数据处理后会将占有的链接放回到链接池中。 </p>
</blockquote>
<h2 id="Spring中同步机制"><a href="#Spring中同步机制" class="headerlink" title="Spring中同步机制"></a>Spring中同步机制</h2><p>　　单例模式的意思就是只有一个实例。单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。</p>
<p>　　当多用户同时请求一个服务时，容器会给每一个请求分配一个线程，这是多个线程会并发执行该请求多对应的业务逻辑（成员方法），此时就要注意了，如果该处理逻辑中有对该单列状态的修改（体现为该单列的成员属性），则必须考虑线程同步问题。</p>
<h3 id="同步机制比较"><a href="#同步机制比较" class="headerlink" title="同步机制比较"></a>同步机制比较</h3><p><em>ThreadLocal</em>和<em>线程同步机制</em>都是为了解决多线程中相同变量的访问冲突问题。 </p>
<p>　　在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。</p>
<p>　　而ThreadLocal则从另一个角度来解决多线程的并发访问。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的*get()*返回的是Object对象，需要强制类型转换。但JDK 5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用 。</p>
<p>　　概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。 </p>
<h3 id="Spring使用ThreadLocal解决线程安全问题"><a href="#Spring使用ThreadLocal解决线程安全问题" class="headerlink" title="Spring使用ThreadLocal解决线程安全问题"></a>Spring使用ThreadLocal解决线程安全问题</h3><p>　　<strong>在一般情况下，只有无状态的Bean才可以在多线程环境下共享。</strong>在Spring中，绝大部分Bean都可以声明为<em>singleton</em>作用域。就是因为Spring对一些Bean（如<em>RequestContextHolder</em>、<em>TransactionSynchronizationManager</em>、<em>LocaleContextHolder</em>等）中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，这样有状态的Bean就可以在多线程中共享了。 </p>
<p>　　一般的Web应用划分为表现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程。<br><em>ThreadLocal</em>是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，<em>ThreadLocal</em>比直接使用<em>synchronized</em>同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。 </p>
<h3 id="线程安全问题都是由成员变量引起的"><a href="#线程安全问题都是由成员变量引起的" class="headerlink" title="线程安全问题都是由成员变量引起的"></a>线程安全问题都是由成员变量引起的</h3><p>　　若每个线程中对成员变量（全局变量、静态变量）只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。<br>1） 常量始终是线程安全的，因为只存在读操作。<br>2）每次调用方法前都新建一个实例是线程安全的，因为不会访问共享的资源。<br>3）局部变量是线程安全的。因为每执行一个方法，都会在独立的空间创建局部变量，它不是共享的资源。局部变量包括方法的参数变量和方法内变量。<br>　　有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。<br>　　无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象，不能保存数据，是不变类，是线程安全的。</p>
<p>　　无状态的Bean适合用不变模式，技术就是单例模式，这样可以共享实例，提高性能。有状态的Bean，多线程环境下不安全，那么适合用Prototype原型模式。Prototype: 每次对bean的请求都会创建一个新的bean实例。 </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Spring中DAO和Service都是以单实例的bean形式存在，Spring通过ThreadLocal类将有状态的变量（例如数据库连接Connection）本地线程化，从而做到多线程状况下的安全。在一次请求响应的处理线程中， 该线程贯通展示、服务、数据持久化三层，通过ThreadLocal使得所有关联的对象引用到的都是同一个变量。  </li>
<li>在事务属性为REQUIRED时，在相同线程中进行相互嵌套调用的事务方法工作于相同的事务中。如果互相嵌套调用的事务方法工作在不同线程中，则不同线程下的事务方法工作在独立的事务中。 </li>
<li>程序只要使用SpringDAO模板，例如JdbcTemplate进行数据访问，一定没有数据库连接泄露问题！如果程序中显式的获取了数据连接Connection，则需要手工关闭它，否则就会泄露！ </li>
<li>当Spring事务方法运行时，就产生一个事务上下文，它在本事务执行线程中对同一个数据源绑定了一个唯一的数据连接，所有被该事务上下文传播的方法都共享这个连接。要获取这个连接，如要使用Spirng的资源获取工具类DataSourceUtils。 </li>
<li>事务管理上下文就好比一个盒子，所有的事务都放在里面。如果在某个事务方法中开启一个新线程，新线程中执行另一个事务方法，则由上面第二条可知这两个方法运行于两个独立的事务中，但是：如果使用DataSourcesUtils，则新线程中的方法可以从事务上下文中获取原线程中的数据连接！ </li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cnblogs.com/RunForLove/p/5706820.html"><em><strong>Spring容器深入</strong></em></a></p>
<p><a href="http://haidaoqi3630.iteye.com/blog/1920944"><em><strong>Spring单例、线程安全、事务等疑惑 收集</strong></em></a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>说说Spring中的事务</title>
    <url>/%E8%AF%B4%E8%AF%B4Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在开发过程中，合理的使用事务是非常重要的。使用事务常常是为了维护高度的数据完整性和一致性。如果不关心数据的质量，就不必使用事务。毕竟，Java平台中的事务支持会降低性能，引发锁定问题和数据库并发性问题，而且会增加应用程序的复杂性。最近在面试中也是频频出现，在这里回顾加深一下。<div align=center><img width="800" height="200" src="../../../../images/2018-5/transaction/spring.jpg" algin="center"/></div><span id="more"></span></p>
<h1 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h1><p>数据库中事务有四大特性，简称为 <strong>ACID</strong> 特性。</p>
<h2 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性(Atomicity)"></a>原子性(Atomicity)</h2><p>事务的原子性是指事务是一个不可分割的工作单位，这组操作要么全部发生，否则全部不发生。</p>
<h2 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性(Consistency)"></a>一致性(Consistency)</h2><p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>
<h2 id="隔离性-Isolation"><a href="#隔离性-Isolation" class="headerlink" title="隔离性(Isolation)"></a>隔离性(Isolation)</h2><p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<h2 id="持久性-Durability"><a href="#持久性-Durability" class="headerlink" title="持久性(Durability)"></a>持久性(Durability)</h2><p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><h2 id="事务并发带来的问题"><a href="#事务并发带来的问题" class="headerlink" title="事务并发带来的问题"></a>事务并发带来的问题</h2><h3 id="脏读-Dirty-Reads"><a href="#脏读-Dirty-Reads" class="headerlink" title="脏读(Dirty Reads)"></a>脏读(Dirty Reads)</h3><p>脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</p>
<p>当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。</p>
<p>例如：用户A向用户B转账100元，对应SQL命令如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">100</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;B&#x27;</span>;  (此时A通知B)</span><br><span class="line"></span><br><span class="line">update account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">100</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（<em>此时即发生了脏读</em>），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。</p>
<h3 id="不可重复读-Non-Repeatable-Reads"><a href="#不可重复读-Non-Repeatable-Reads" class="headerlink" title="不可重复读(Non-Repeatable Reads)"></a>不可重复读(Non-Repeatable Reads)</h3><p>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p>
<p>例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发生了不可重复读。</p>
<blockquote>
<p>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</p>
</blockquote>
<h3 id="幻读-虚读-Phantom-Reads"><a href="#幻读-虚读-Phantom-Reads" class="headerlink" title="幻读(虚读)(Phantom Reads)"></a>幻读(虚读)(Phantom Reads)</h3><p>幻读是事务非独立执行时发生的一种现象。</p>
<p>例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p>
<blockquote>
<p>不可重复读是指同一查询在同一事务中多次进行，由于其他提交事务所做的<strong>修改或删除</strong>，每次返回不同的结果集，此时发生非重复读。</p>
<p>幻像读是指同一查询在同一事务中多次进行，由于其他提交事务所做的<strong>插入</strong>操作，每次返回不同的结果集，此时发生幻像读。</p>
</blockquote>
<h2 id="四种隔离级别-Isolation-Level"><a href="#四种隔离级别-Isolation-Level" class="headerlink" title="四种隔离级别(Isolation Level)"></a>四种隔离级别(Isolation Level)</h2><ul>
<li><strong>Serializable</strong> (串行化)：可避免脏读、不可重复读、幻读的发生。</li>
<li><strong>Repeatable read</strong> (可重复读)：可避免脏读、不可重复读的发生。</li>
<li><strong>Read committed</strong> (读已提交)：可避免脏读的发生。</li>
<li><strong>Read uncommitted</strong> (读未提交)：最低级别，任何情况都无法保证。</li>
</ul>
<p>以上四种隔离级别最高的是<em>Serializable</em>级别，最低的是<em>Read uncommitted</em>级别，当然级别越高，执行效率就越低。像<em>Serializable</em>这样的级别，就是以锁表的方式(类似于Java多线程中的锁) 使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。**<code>MySQL数据库中默认的隔离级别为Repeatable read (可重复读)</code>**。</p>
<p>在MySQL数据库中查看当前事务的隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@tx</span>_isolation;</span><br></pre></td></tr></table></figure>

<h1 id="传播方式-Propagation"><a href="#传播方式-Propagation" class="headerlink" title="传播方式(Propagation)"></a>传播方式(Propagation)</h1><h2 id="REQUIRED（默认）"><a href="#REQUIRED（默认）" class="headerlink" title="REQUIRED（默认）"></a><strong>REQUIRED（默认）</strong></h2><p>如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务(S<em>upport a current transaction, create a new one if none exists.</em>)。</p>
<p>被设置成这个级别时，会为每一个被调用的方法创建一个逻辑事务域。如果前面的方法已经创建了事务，那么后面的方法支持当前的事务，如果当前没有事务会重新建立事务。</p>
<h2 id="REQUIRES-NEW"><a href="#REQUIRES-NEW" class="headerlink" title="REQUIRES_NEW"></a><strong>REQUIRES_NEW</strong></h2><p>新建事务，如果当前存在事务，把当前事务挂起(<em>Create a new transaction, suspend the current transaction if one exists.</em>)。</p>
<h2 id="SUPPORTS"><a href="#SUPPORTS" class="headerlink" title="SUPPORTS"></a><strong>SUPPORTS</strong></h2><p>支持当前事务，如果当前没有事务，就以非事务方式执行(<em>Support a current transaction, execute non-transactionally if none exists.</em>)。</p>
<h2 id="NOT-SUPPORTED"><a href="#NOT-SUPPORTED" class="headerlink" title="NOT_SUPPORTED"></a><strong>NOT_SUPPORTED</strong></h2><p>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起(<em>Execute non-transactionally, suspend the current transaction if one exists.</em>)。</p>
<h2 id="NEVER"><a href="#NEVER" class="headerlink" title="NEVER"></a><strong>NEVER</strong></h2><p>以非事务方式执行，如果当前存在事务，则抛出异常(<em>Execute non-transactionally, throw an exception if a transaction exists.</em>)。</p>
<h2 id="NESTED"><a href="#NESTED" class="headerlink" title="NESTED"></a><strong>NESTED</strong></h2><p>支持当前事务，新增Savepoint点，与当前事务同步提交或回滚(<em>Execute within a nested transaction if a current transaction exists, behave like PROPAGATION_REQUIRED else.</em>)。</p>
<h2 id="MANDATORY"><a href="#MANDATORY" class="headerlink" title="MANDATORY"></a><strong>MANDATORY</strong></h2><p>支持当前事务，如果当前没有事务，就抛出异常(<em>Support a current transaction, throw an exception if none exists.</em>)。</p>
<h2 id="REQUIRES-NEW和NESTED区别"><a href="#REQUIRES-NEW和NESTED区别" class="headerlink" title="REQUIRES_NEW和NESTED区别"></a>REQUIRES_NEW和NESTED区别</h2><p><em>**<code>REQUIRES_NEW</code><em>*<em>启动一个新的，不依赖于环境的 “内部” 事务。这个事务将被完全</em>commited*或</em>rolledback<em>而不依赖于外部事务，它拥有自己的隔离范围，自己的锁等等。当内部事务开始执行时，外部事务将被挂起，内务事务结束时，外部事务将继续执行。</em>REQUIRES_NEW</em>常用于日志记录、交易失败仍需留痕等场景。</p>
<p>***<code>PROPAGATION_NESTED</code><em>*<em>开始一个”嵌套”的事务，它是已经存在事务的一个真正的子事务。嵌套事务开始执行时，它将取得一个</em>savepoint*。 如果这个嵌套事务失败，将回滚到此</em>savepoint*.。嵌套事务是外部事务的一部分,，只有外部事务结束后它才会被提交。</p>
<p>由此可见，<strong>PROPAGATION_REQUIRES_NEW</strong>和<strong>PROPAGATION_NESTED</strong>的最大区别在于，<em>PROPAGATION_REQUIRES_NEW</em>完全是一个新的事务，而<em>PROPAGATION_NESTED</em>则是外部事务的子事务，如果外部事务<em>commit</em>，嵌套事务也会被<em>commit</em>，这个规则同样适用于<em>rollback</em>。</p>
<h1 id="Spring事务陷阱"><a href="#Spring事务陷阱" class="headerlink" title="Spring事务陷阱"></a>Spring事务陷阱</h1><h2 id="同一方法中执行多次表更新（无事务）"><a href="#同一方法中执行多次表更新（无事务）" class="headerlink" title="同一方法中执行多次表更新（无事务）"></a>同一方法中执行多次表更新（无事务）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TradeData <span class="title">placeTrade</span><span class="params">(TradeData trade)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      insertTrade(trade);</span><br><span class="line">      updateAcct(trade);</span><br><span class="line">      <span class="keyword">return</span> trade;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception up) &#123;</span><br><span class="line">      <span class="comment">//log the error</span></span><br><span class="line">      <span class="keyword">throw</span> up;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>insertTrade()</code> 和 <code>updateAcct()</code> 方法使用不带事务的标准 JDBC 代码。<code>insertTrade()</code> 方法结束后，数据库保存（并提交了）交易订单。如果 <code>updateAcct()</code> 方法由于任意原因失败，交易订单仍然会在 <code>placeTrade()</code> 方法结束时保存在 <code>TRADE</code> 表内，这会导致数据库出现不一致的数据。如果 <code>placeTrade()</code> 方法使用了事务，这两个活动都会包含在一个事务中，如果帐户更新失败，交易订单就会回滚。</p>
<h2 id="利用-Transaction注解事务"><a href="#利用-Transaction注解事务" class="headerlink" title="利用@Transaction注解事务"></a>利用@Transaction注解事务</h2><p>例二：将只读标志与 <strong><code>SUPPORTS</code></strong> 传播模式结合使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = true, propagation=Propagation.SUPPORTS)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">insertTrade</span><span class="params">(TradeData trade)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   	insert(trade);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行到例二的 <code>insertTrade()</code> 方法时，结果是：<strong>正确插入交易订单并提交数据</strong>。</p>
<p>交易订单会被正确地插入到数据库中，即使只读标志被设置为 <code>true</code>，且事务传播模式被设置为 <code>SUPPORTS</code>。但这是如何做到的呢？由于传播模式被设置为 <code>SUPPORTS</code>，所以不会启动任何事务，因此该方法有效地利用了一个本地（数据库）事务。<strong>只读标志只在事务启动时应用</strong>。在本例中，因为没有启动任何事务，所以只读标志被忽略。</p>
<p>例三：将只读标志与 <strong><code>REQUIRED</code></strong> 传播模式结合使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(readOnly = true, propagation=Propagation.REQUIRED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">insertTrade</span><span class="params">(TradeData trade)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> 	 em.persist(trade);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行到例三的 <code>insertTrade()</code> 方法时，结果是：<strong>抛出一个只读连接异常</strong>。</p>
<p>表示正在试图对一个只读连接执行更新。因为启动了一个事务（<code>REQUIRED</code>），而连接被设置为只读。毫无疑问，在试图执行 SQL 语句时，会得到一个异常，告诉该连接是一个只读连接。</p>
<p>关于只读标志很奇怪的一点是：要使用它，必须启动一个事务。如果只是读取数据，需要事务吗？答案是根本不需要。<strong>启动一个事务来执行只读操作会增加处理线程的开销，并会导致数据库发生共享读取锁定</strong>（具体取决于使用的数据库类型和设置的隔离级别）。</p>
<p>例四：使用只读标志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TradeData <span class="title">getTrade</span><span class="params">(<span class="keyword">long</span> tradeId)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> em.find(tradeId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行到例四的 <code>getTrade()</code> 方法时，结果是：<strong>启动一个事务，获取交易订单，然后提交事务</strong>。</p>
<p><code>@Transactional</code> 注释的**默认传播模式是 <code>REQUIRED</code>**。这意味着事务会在不必要的情况下启动。根据使用的数据库，这会引起不必要的共享锁，可能会使数据库中出现死锁的情况。此外，启动和停止事务将消耗不必要的处理时间和资源。总的来说，在使用基于ORM的框架时，只读标志基本上毫无用处，在大多数情况下会被忽略。但如果坚持使用它，记得将传播模式设置为 <code>SUPPORTS</code>（如下例五所示），这样就不会启动事务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例五</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = true, propagation=Propagation.SUPPORTS)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TradeData <span class="title">getTrade</span><span class="params">(<span class="keyword">long</span> tradeId)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> em.find(tradeId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="REQUIRES-NEW-事务属性陷阱"><a href="#REQUIRES-NEW-事务属性陷阱" class="headerlink" title="REQUIRES_NEW 事务属性陷阱"></a><code>REQUIRES_NEW </code>事务属性陷阱</h2><p><code>REQUIRES_NEW</code> 事务属性总是会在启动方法时启动一个新的事务，使用 <code>REQUIRES_NEW</code> 事务属性都会得到不好的结果并导致数据损坏和不一致。</p>
<p>例六： 使用 <code>REQUIRES_NEW</code> 事务属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation=Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">insertTrade</span><span class="params">(TradeData trade)</span> <span class="keyword">throws</span> Exception </span>&#123;...&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Transactional(propagation=Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAcct</span><span class="params">(TradeData trade)</span> <span class="keyword">throws</span> Exception </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>例六中的两个方法都是公共方法，意味着它们可以单独调用。当使用 <code>REQUIRES_NEW</code> 属性的几个方法通过服务间通信或编排在同一逻辑工作单元内调用时，该属性就会出现问题。假设在例六中，可以独立于一些用例中的任何其他方法来调用 <code>updateAcct()</code> 方法，但也有在 <code>insertTrade()</code> 方法中调用 <code>updateAcct()</code> 方法的情况。现在如果调用 <code>updateAcct()</code> 方法后抛出异常，交易订单就会回滚，但帐户更新将会提交给数据库，如下例七所示：</p>
<p>例七：使用 <code>REQUIRES_NEW</code> 事务属性的多次更新</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation=Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">insertTrade</span><span class="params">(TradeData trade)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   em.persist(trade);</span><br><span class="line">   updateAcct(trade);</span><br><span class="line">   <span class="comment">// 这里出现异常! insertTrade回滚但是updateAcct不会回滚!</span></span><br><span class="line">   <span class="comment">// exception occurs here! Trade rolled back but account update is not!</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发生这种情况的原因是 <code>updateAcct()</code> 方法中启动了一个新事务，所以在 <code>updateAcct()</code> 方法结束后，事务将被提交。使用 <code>REQUIRES_NEW</code> 事务属性时，如果存在现有事务上下文，当前的事务会被挂起并启动一个新事务。方法结束后，新的事务被提交，原来的事务继续执行。</p>
<p><strong>由于这种行为，只有在被调用方法中的数据库操作需要保存到数据库中，而不管覆盖事务的结果如何时，才应该使用 <code>REQUIRES_NEW</code> 事务属性</strong>。比如，假设尝试的所有股票交易都必须被记录在一个审计数据库中。出于验证错误、资金不足或其他原因，不管交易是否失败，这条信息都需要被持久化。如果没有对审计方法使用 <code>REQUIRES_NEW</code> 属性，审计记录就会连同尝试执行的交易一起回滚。使用 <code>REQUIRES_NEW</code> 属性可以确保不管初始事务的结果如何，审计数据都会被保存。这里要注意的一点是，要始终使用 <code>MANDATORY</code> 或 <code>REQUIRED</code> 属性，而不是 <code>REQUIRES_NEW</code>，除非有足够的理由来使用它，类似审计示例中的那些理由。</p>
<h2 id="Spring事务REQUIRES-NEW不起作用"><a href="#Spring事务REQUIRES-NEW不起作用" class="headerlink" title="Spring事务REQUIRES_NEW不起作用"></a>Spring事务REQUIRES_NEW不起作用</h2><p>原因是A方法（<em>REQUIRES</em>）调用B方法（<em>REQUIRES_NEW</em>）在同一类中，如果两个方法写在同一个Service类中，Spring并不会重新创建新事务，如果是两不同的Service，就会创建新事务了。 </p>
<p>解决方案1：需要将两个方法分别写在不同的类中。</p>
<p>解决方案2：方法写在同一个类里，但调用B方法的时候，将<em>service</em>自己注入自己，用这个注入对象来调用B方法。</p>
<h2 id="事务回滚陷阱"><a href="#事务回滚陷阱" class="headerlink" title="事务回滚陷阱"></a>事务回滚陷阱</h2><p>例八：没有回滚支持</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation=Propagation.REQUIRED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TradeData <span class="title">placeTrade</span><span class="params">(TradeData trade)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      insertTrade(trade);</span><br><span class="line">      updateAcct(trade);</span><br><span class="line">      <span class="keyword">return</span> trade;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception up) &#123;</span><br><span class="line">      <span class="comment">//log the error</span></span><br><span class="line">      <span class="keyword">throw</span> up;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设帐户中没有足够的资金来购买需要的股票，或者还没有准备购买或出售股票，并抛出了一个受检异常，那么交易订单会保存在数据库中吗？还是整个逻辑工作单元将执行回滚？答案出乎意料：根据受检异常（不管是在 Spring Framework 中还是在 EJB 中），事务会提交它还未提交的所有工作。使用例八，这意味着，如果在执行 <code>updateAcct()</code> 方法期间抛出受控异常，就会保存交易订单，但不会更新帐户来反映交易情况。</p>
<p>这可能是在使用事务时出现的主要数据完整性和一致性问题了。<strong>运行时异常（即非受检异常）自动强制执行整个逻辑工作单元的回滚，但受检异常不会。</strong></p>
<p>例九：添加事务回滚支持 — Spring</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation=Propagation.REQUIRED, rollbackFor=Exception.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TradeData <span class="title">placeTrade</span><span class="params">(TradeData trade)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      insertTrade(trade);</span><br><span class="line">      updateAcct(trade);</span><br><span class="line">      <span class="keyword">return</span> trade;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception up) &#123;</span><br><span class="line">      <span class="comment">//log the error</span></span><br><span class="line">      <span class="keyword">throw</span> up;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Transactional</code> 注释中使用了 <code>rollbackFor</code> 参数。这个参数接受一个单一异常类或一组异常类，也可以使用 <code>rollbackForClassName</code> 参数将异常的名称指定为 Java <code>String</code> 类型。还可以使用此属性的相反形式（<code>noRollbackFor</code>）指定除某些异常以外的所有异常应该强制回滚。通常大多数开发人员指定 <code>Exception.class</code> 作为值，表示该方法中的所有异常应该强制回滚。</p>
<p>下面两种方式同样会回滚</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一，手动回滚</span></span><br><span class="line"><span class="meta">@Transactional(propagation=Propagation.REQUIRED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TradeData <span class="title">placeTrade1</span><span class="params">(TradeData trade)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      insertTrade(trade);</span><br><span class="line">      updateAcct(trade);</span><br><span class="line">      <span class="keyword">return</span> trade;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception up) &#123;</span><br><span class="line">   	  TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二，抛出RuntimeException</span></span><br><span class="line"><span class="meta">@Transactional(propagation=Propagation.REQUIRED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TradeData <span class="title">placeTrade2</span><span class="params">(TradeData trade)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      insertTrade(trade);</span><br><span class="line">      updateAcct(trade);</span><br><span class="line">      <span class="keyword">return</span> trade;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception up) &#123;</span><br><span class="line">   	  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.ibm.com/developerworks/cn/java/j-ts1.html">了解事务陷阱</a></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
</search>
